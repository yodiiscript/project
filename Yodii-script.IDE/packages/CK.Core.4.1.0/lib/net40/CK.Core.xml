<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CK.Core</name>
    </assembly>
    <members>
        <member name="T:CK.Core.ActivityLogGroupConclusion">
            <summary>
            Describes the conclusion of a group. Conclusions are simply <see cref="F:CK.Core.ActivityLogGroupConclusion.Text"/> <see cref="F:CK.Core.ActivityLogGroupConclusion.Tag"/>ged with a <see cref="T:CK.Core.CKTrait"/>.
            </summary>
        </member>
        <member name="F:CK.Core.ActivityLogGroupConclusion.Tag">
            <summary>
            The tag (never null).
            It may be combined but is often atomic like <see cref="F:CK.Core.ActivityMonitor.Tags.UserConclusion"/>, 
            or <see cref="F:CK.Core.ActivityMonitor.Tags.GetTextConclusion"/>.
            </summary>
        </member>
        <member name="F:CK.Core.ActivityLogGroupConclusion.Text">
            <summary>
            The conclusion (never null).
            </summary>
        </member>
        <member name="M:CK.Core.ActivityLogGroupConclusion.#ctor(System.String,CK.Core.CKTrait)">
            <summary>
            Initializes a new conclusion for a group.
            </summary>
            <param name="conclusion">Must not be null (may be empty).</param>
            <param name="tag">Must be null or be registered in <see cref="T:CK.Core.ActivityMonitor.Tags"/>.</param>
        </member>
        <member name="M:CK.Core.ActivityLogGroupConclusion.Equals(System.Object)">
            <summary>
            Explicit test for <see cref="F:CK.Core.ActivityLogGroupConclusion.Text"/> and <see cref="F:CK.Core.ActivityLogGroupConclusion.Tag"/> equality.
            </summary>
            <param name="obj">Object to test.</param>
            <returns>True when equal.</returns>
        </member>
        <member name="M:CK.Core.ActivityLogGroupConclusion.op_Equality(CK.Core.ActivityLogGroupConclusion,CK.Core.ActivityLogGroupConclusion)">
            <summary>
            Equality operator definition.
            </summary>
            <param name="x">First value type.</param>
            <param name="y">Second value type.</param>
            <returns>True if and only if Tag and Text are equals.</returns>
        </member>
        <member name="M:CK.Core.ActivityLogGroupConclusion.op_Inequality(CK.Core.ActivityLogGroupConclusion,CK.Core.ActivityLogGroupConclusion)">
            <summary>
            Inequality operator definition.
            </summary>
            <param name="x">First value type.</param>
            <param name="y">Second value type.</param>
            <returns>True if Tag or Text differ.</returns>
        </member>
        <member name="M:CK.Core.ActivityLogGroupConclusion.GetHashCode">
            <summary>
            Computes the hash code.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:CK.Core.ActivityLogGroupConclusion.ToString">
            <summary>
            Overriden to return <see cref="F:CK.Core.ActivityLogGroupConclusion.Text"/>.
            </summary>
            <returns>Text field.</returns>
        </member>
        <member name="T:CK.Core.ActivityMonitorGroupData">
            <summary>
            Data required by <see cref="M:CK.Core.IActivityMonitor.UnfilteredOpenGroup(CK.Core.ActivityMonitorGroupData)"/>.
            </summary>
        </member>
        <member name="T:CK.Core.ActivityMonitorLogData">
            <summary>
            Data required by <see cref="M:CK.Core.IActivityMonitor.UnfilteredLog(CK.Core.ActivityMonitorLogData)"/>.
            This is also the base class for <see cref="T:CK.Core.ActivityMonitorGroupData"/>.
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitorLogData.Level">
            <summary>
            Log level. Can not be <see cref="F:CK.Core.LogLevel.None"/>.
            If the log has been successfully filtered, the <see cref="F:CK.Core.LogLevel.IsFiltered"/> bit flag is set.
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitorLogData.MaskedLevel">
            <summary>
            The actual level (<see cref="F:CK.Core.LogLevel.Trace"/> to <see cref="F:CK.Core.LogLevel.Fatal"/>) associated to this group
            without <see cref="F:CK.Core.LogLevel.IsFiltered"/> bit flag.
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitorLogData.FileName">
            <summary>
            Name of the source file that emitted the log. Can be null.
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitorLogData.LineNumber">
            <summary>
            Line number in the source file that emitted the log. Can be null.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorLogData.EnsureExceptionData">
            <summary>
            Gets or creates the <see cref="T:CK.Core.CKExceptionData"/> that captures exception information.
            If <see cref="P:Exception"/> is null, this returns null.
            </summary>
            <returns>A data representation of the exception or null.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorLogData.#ctor(CK.Core.LogLevel,System.Exception,CK.Core.CKTrait,System.String,CK.Core.DateTimeStamp,System.String,System.Int32)">
            <summary>
            Initializes a new <see cref="T:CK.Core.ActivityMonitorLogData"/>.
            </summary>
            <param name="level">Log level. Can not be <see cref="F:CK.Core.LogLevel.None"/>.</param>
            <param name="exception">Exception of the log. Can be null.</param>
            <param name="tags">Tags (from <see cref="T:CK.Core.ActivityMonitor.Tags"/>) to associate to the log. It will be union-ed with the current <see cref="P:CK.Core.IActivityMonitor.AutoTags"/>.</param>
            <param name="text">Text of the log. Can be null or empty only if <paramref name="exception"/> is not null: the <see cref="T:Exception.Message"/> is the text.</param>
            <param name="logTime">
            Time of the log. 
            You can use <see cref="P:CK.Core.DateTimeStamp.UtcNow"/> or <see cref="M:CK.Core.ActivityMonitorExtension.NextLogTime(CK.Core.IActivityMonitor)">IActivityMonitor.NextLogTime()</see> extension method.
            </param>
            <param name="fileName">Name of the source file that emitted the log. Can be null.</param>
            <param name="lineNumber">Line number in the source file that emitted the log. Can be null.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorLogData.#ctor">
            <summary>
            Used only to initialize a ActivityMonitorGroupSender for rejected opened group.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorLogData.IsFilteredLog">
            <summary>
            Gets whether this log data has been successfully filtered (otherwise it is an unfiltered log).
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorLogData.Tags">
            <summary>
            Tags (from <see cref="T:CK.Core.ActivityMonitor.Tags"/>) associated to the log. 
            It will be union-ed with the current <see cref="P:CK.Core.IActivityMonitor.AutoTags"/>.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorLogData.Text">
            <summary>
            Text of the log. Can not be null.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorLogData.LogTime">
            <summary>
            Gets the time of the log.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorLogData.Exception">
            <summary>
            Exception of the log. Can be null.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorLogData.ExceptionData">
            <summary>
            Gets the <see cref="T:CK.Core.CKExceptionData"/> that captures exception information 
            if it exists. Returns null if no <see cref="P:Exception"/> exists.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorLogData.IsTextTheExceptionMessage">
            <summary>
            Gets whether the <see cref="P:CK.Core.ActivityMonitorLogData.Text"/> is actually the <see cref="P:Exception"/> message.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorGroupData.#ctor(CK.Core.LogLevel,CK.Core.CKTrait,System.String,CK.Core.DateTimeStamp,System.Exception,System.Func{System.String},System.String,System.Int32)">
            <summary>
            Initializes a new <see cref="T:CK.Core.ActivityMonitorGroupData"/>.
            </summary>
            <param name="level">Log level. Can not be <see cref="F:CK.Core.LogLevel.None"/>.</param>
            <param name="tags">Tags (from <see cref="T:CK.Core.ActivityMonitor.Tags"/>) to associate to the log. It will be union-ed with the current <see cref="P:CK.Core.IActivityMonitor.AutoTags"/>.</param>
            <param name="text">Text of the log. Can be null or empty only if <paramref name="exception"/> is not null: the <see cref="P:System.Exception.Message"/> is the text.</param>
            <param name="logTime">
            Time of the log.
            You may use <see cref="P:CK.Core.DateTimeStamp.UtcNow"/> or <see cref="M:CK.Core.ActivityMonitorExtension.NextLogTime(CK.Core.IActivityMonitor)">IActivityMonitor.NextLogTime()</see> extension method.
            </param>
            <param name="exception">Exception of the log. Can be null.</param>
            <param name="getConclusionText">Optional function that provides delayed obtention of the group conclusion: will be called on group closing.</param>
            <param name="fileName">Name of the source file that emitted the log. Can be null.</param>
            <param name="lineNumber">Line number in the source file that emitted the log. Can be null.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorGroupData.#ctor">
            <summary>
            Used only to initialize a ActivityMonitorGroupSender for rejected opened group.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorGroupData.ConsumeConclusionText">
            <summary>
            Calls <see cref="P:CK.Core.ActivityMonitorGroupData.GetConclusionText"/> and sets it to null.
            </summary>
        </member>
        <member name="T:CK.Core.ActivityMonitorClient">
            <summary>
            Base class that explicitly implements <see cref="T:CK.Core.IActivityMonitorClient"/> (to hide it from public interface, except its <see cref="P:CK.Core.ActivityMonitorClient.MinimalFilter"/>).
            </summary>
        </member>
        <member name="T:CK.Core.IActivityMonitorClient">
            <summary>
            Listener for <see cref="T:CK.Core.IActivityMonitor"/> registered in a <see cref="T:CK.Core.IActivityMonitorOutput"/>.
            </summary>
        </member>
        <member name="M:CK.Core.IActivityMonitorClient.OnUnfilteredLog(CK.Core.ActivityMonitorLogData)">
            <summary>
            Called for each <see cref="M:CK.Core.IActivityMonitor.UnfilteredLog(CK.Core.ActivityMonitorLogData)"/>.
            The <see cref="P:CK.Core.ActivityMonitorLogData.Exception"/> is always null since exceptions
            are carried by groups.
            </summary>
            <param name="data">Log data. Never null.</param>
        </member>
        <member name="M:CK.Core.IActivityMonitorClient.OnOpenGroup(CK.Core.IActivityLogGroup)">
            <summary>
            Called for each <see cref="M:CK.Core.IActivityMonitor.UnfilteredOpenGroup(CK.Core.ActivityMonitorGroupData)"/>.
            </summary>
            <param name="group">The newly opened <see cref="T:CK.Core.IActivityLogGroup"/>.</param>
        </member>
        <member name="M:CK.Core.IActivityMonitorClient.OnGroupClosing(CK.Core.IActivityLogGroup,System.Collections.Generic.List{CK.Core.ActivityLogGroupConclusion}@)">
            <summary>
            Called once the user conclusions are known at the group level but before 
            the group is actually closed: clients can update the conclusions for the group.
            Does nothing by default.
            </summary>
            <param name="group">The closing group.</param>
            <param name="conclusions">
            Mutable conclusions associated to the closing group. 
            This can be null if no conclusions have been added yet. 
            It is up to the first client that wants to add a conclusion to instantiate a new List object to carry the conclusions.
            </param>
        </member>
        <member name="M:CK.Core.IActivityMonitorClient.OnGroupClosed(CK.Core.IActivityLogGroup,System.Collections.Generic.IReadOnlyList{CK.Core.ActivityLogGroupConclusion})">
            <summary>
            Called when the group is actually closed.
            </summary>
            <param name="group">The closed group.</param>
            <param name="conclusions">Texts that conclude the group. Never null but can be empty.</param>
        </member>
        <member name="M:CK.Core.IActivityMonitorClient.OnTopicChanged(System.String,System.String,System.Int32)">
            <summary>
            Called when a new <see cref="P:CK.Core.IActivityMonitor.Topic"/> is set.
            </summary>
            <param name="newTopic">The new topic string (never null but can be empty).</param>
            <param name="fileName">Source file name where <see cref="M:CK.Core.IActivityMonitor.SetTopic(System.String,System.String,System.Int32)"/> has been called.</param>
            <param name="lineNumber">Source line number where IActivityMonitor.SetTopic has been called.</param>
        </member>
        <member name="M:CK.Core.IActivityMonitorClient.OnAutoTagsChanged(CK.Core.CKTrait)">
            <summary>
            Called when <see cref="P:CK.Core.IActivityMonitor.AutoTags"/> changed.
            </summary>
            <param name="newTrait">The new tags (never null but can be empty).</param>
        </member>
        <member name="F:CK.Core.ActivityMonitorClient.Empty">
            <summary>
            Empty <see cref="T:CK.Core.IActivityMonitorClient"/> (null object design pattern).
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorClient.#ctor">
            <summary>
            Initialize a new <see cref="T:CK.Core.ActivityMonitorClient"/> that does nothing.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorClient.OnUnfilteredLog(CK.Core.ActivityMonitorLogData)">
            <summary>
            Called for each <see cref="M:CK.Core.IActivityMonitor.UnfilteredLog(CK.Core.ActivityMonitorLogData)"/>. Does nothing by default.
            The <see cref="P:CK.Core.ActivityMonitorLogData.Exception"/> is always null since exceptions
            are carried by groups.
            </summary>
            <param name="data">Log data. Never null.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorClient.OnOpenGroup(CK.Core.IActivityLogGroup)">
            <summary>
            Called for each <see cref="M:CK.Core.IActivityMonitor.UnfilteredOpenGroup(CK.Core.ActivityMonitorGroupData)"/>.
            Does nothing by default.
            </summary>
            <param name="group">The newly opened <see cref="T:CK.Core.IActivityLogGroup"/>.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorClient.OnGroupClosing(CK.Core.IActivityLogGroup,System.Collections.Generic.List{CK.Core.ActivityLogGroupConclusion}@)">
            <summary>
            Called once the user conclusions are known at the group level but before 
            the group is actually closed: clients can update the conclusions for the group.
            Does nothing by default.
            </summary>
            <param name="group">The closing group.</param>
            <param name="conclusions">
            Mutable conclusions associated to the closing group. 
            This can be null if no conclusions have been added yet. 
            It is up to the first client that wants to add a conclusion to instantiate a new List object to carry the conclusions.
            </param>
        </member>
        <member name="M:CK.Core.ActivityMonitorClient.OnGroupClosed(CK.Core.IActivityLogGroup,System.Collections.Generic.IReadOnlyList{CK.Core.ActivityLogGroupConclusion})">
            <summary>
            Called when the group is actually closed.
            Does nothing by default.
            </summary>
            <param name="group">The closed group.</param>
            <param name="conclusions">Text that conclude the group. Never null but can be empty.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorClient.OnTopicChanged(System.String,System.String,System.Int32)">
            <summary>
            Called when <see cref="P:CK.Core.IActivityMonitor.Topic"/> changed.
            Does nothing by default.
            </summary>
            <param name="newTopic">The new topic.</param>
            <param name="fileName">Source file name where <see cref="M:CK.Core.IActivityMonitor.SetTopic(System.String,System.String,System.Int32)"/> has been called.</param>
            <param name="lineNumber">Source line number where IActivityMonitor.SetTopic has been called.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorClient.OnAutoTagsChanged(CK.Core.CKTrait)">
            <summary>
            Called when <see cref="P:CK.Core.IActivityMonitor.AutoTags"/> changed.
            Does nothing by default.
            </summary>
            <param name="newTags">The new auto tags.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorClient.CreateMultipleRegisterOnBoundClientException(CK.Core.IActivityMonitorBoundClient)">
            <summary>
            Creates a standardized exception that can be thrown by <see cref="M:CK.Core.IActivityMonitorBoundClient.SetMonitor(CK.Core.Impl.IActivityMonitorImpl,System.Boolean)"/>.
            </summary>
            <param name="boundClient">The bound client.</param>
            <returns>An exception with an explicit message.</returns>
        </member>
        <member name="P:CK.Core.ActivityMonitorClient.MinimalFilter">
            <summary>
            Gets the minimal log level that this Client expects: defaults to <see cref="F:CK.Core.LogFilter.Undefined"/>.
            </summary>
        </member>
        <member name="T:CK.Core.ActivityMonitorConsoleClient">
            <summary>
            Displays the activity to the console.
            </summary>
        </member>
        <member name="T:CK.Core.ActivityMonitorTextWriterClient">
            <summary>
            Formats the activity and pushes piece of texts to an <see cref="T:System.Action`1"/> where T is a string.
            </summary>
        </member>
        <member name="T:CK.Core.ActivityMonitorTextHelperClient">
            <summary>
            Base class for <see cref="T:CK.Core.IActivityMonitorClient"/> that tracks groups and level changes in order
            to ease text-based renderer.
            </summary>
        </member>
        <member name="T:CK.Core.IActivityMonitorBoundClient">
            <summary>
            Specialized <see cref="T:CK.Core.IActivityMonitorClient"/> that is bound to one <see cref="T:CK.Core.IActivityMonitor"/>.
            Clients that can not be registered into multiple outputs (and receive logs from multiple monitors at the same time) should implement this 
            interface in order to control their registration/un-registration.
            </summary>
        </member>
        <member name="M:CK.Core.IActivityMonitorBoundClient.SetMonitor(CK.Core.Impl.IActivityMonitorImpl,System.Boolean)">
            <summary>
            Called by <see cref="T:CK.Core.IActivityMonitorOutput"/> when registering or unregistering
            this client.
            </summary>
            <param name="source">The monitor that will send log.</param>
            <param name="forceBuggyRemove">
            True if this client must be removed because one of its method thrown an exception. The <paramref name="source"/> is null.
            </param>
        </member>
        <member name="P:CK.Core.IActivityMonitorBoundClient.MinimalFilter">
            <summary>
            Gets the minimal log level that this Client expects. 
            Should default to <see cref="F:CK.Core.LogLevelFilter.None"/>.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorTextHelperClient.#ctor(CK.Core.LogFilter)">
            <summary>
            Initialize a new <see cref="T:CK.Core.ActivityMonitorTextHelperClient"/> with a filter.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorTextHelperClient.#ctor">
            <summary>
            Initialize a new <see cref="T:CK.Core.ActivityMonitorTextHelperClient"/>.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorTextHelperClient.OnEnterLevel(CK.Core.ActivityMonitorLogData)">
            <summary>
            Called for the first text of a <see cref="T:CK.Core.LogLevel"/>.
            </summary>
            <param name="data">Log data.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorTextHelperClient.OnContinueOnSameLevel(CK.Core.ActivityMonitorLogData)">
            <summary>
            Called for text with the same <see cref="T:CK.Core.LogLevel"/> as the previous ones.
            </summary>
            <param name="data">Log data.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorTextHelperClient.OnLeaveLevel(CK.Core.LogLevel)">
            <summary>
            Called when current log level changes.
            </summary>
            <param name="level">The previous log level (without <see cref="F:CK.Core.LogLevel.IsFiltered"/>).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorTextHelperClient.OnGroupOpen(CK.Core.IActivityLogGroup)">
            <summary>
            Called whenever a group is opened.
            </summary>
            <param name="group">The newly opened group.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorTextHelperClient.OnGroupClose(CK.Core.IActivityLogGroup,System.Collections.Generic.IReadOnlyList{CK.Core.ActivityLogGroupConclusion})">
            <summary>
            Called when the group is actually closed.
            </summary>
            <param name="group">The closing group.</param>
            <param name="conclusions">Texts that concludes the group. Never null but can be empty.</param>
        </member>
        <member name="P:CK.Core.ActivityMonitorTextHelperClient.Filter">
            <summary>
            Gets or sets the filter for this client.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorTextWriterClient.#ctor(System.Action{System.String},CK.Core.LogFilter)">
            <summary>
            Initializes a new <see cref="T:CK.Core.ActivityMonitorTextWriterClient"/> bound to a 
            function that must write a string, with a filter.
            </summary>
            <param name="writer">Function that writes the content.</param>
            <param name="filter">Filter to apply</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorTextWriterClient.#ctor(System.Action{System.String})">
            <summary>
            Initializes a new <see cref="T:CK.Core.ActivityMonitorTextWriterClient"/> bound to a 
            function that must write a string.
            </summary>
            <param name="writer">Function that writes the content.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorTextWriterClient.OnEnterLevel(CK.Core.ActivityMonitorLogData)">
            <summary>
            Writes all the information.
            </summary>
            <param name="data">Log data.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorTextWriterClient.OnContinueOnSameLevel(CK.Core.ActivityMonitorLogData)">
            <summary>
            Writes all information.
            </summary>
            <param name="data">Log data.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorTextWriterClient.OnLeaveLevel(CK.Core.LogLevel)">
            <summary>
            Updates the internally maintained prefix for lines.
            </summary>
            <param name="level">Previous level.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorTextWriterClient.OnGroupOpen(CK.Core.IActivityLogGroup)">
            <summary>
            Writes a group opening.
            </summary>
            <param name="g">Group information.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorTextWriterClient.OnGroupClose(CK.Core.IActivityLogGroup,System.Collections.Generic.IReadOnlyList{CK.Core.ActivityLogGroupConclusion})">
            <summary>
            Writes group conclusion and updates internally managed line prefix.
            </summary>
            <param name="g">Group that must be closed.</param>
            <param name="conclusions">Conclusions for the group.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorTextWriterClient.DumpException(System.Text.StringBuilder,System.String,System.Boolean,System.Exception)">
            <summary>
            Recursively dumps an <see cref="T:System.Exception"/> as readable text.
            </summary>
            <param name="w">The TextWriter to write to.</param>
            <param name="prefix">Prefix that will start all lines.</param>
            <param name="displayMessage">Whether the exception message must be displayed or skip.</param>
            <param name="ex">The exception to display.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorConsoleClient.#ctor">
            <summary>
            Initializes a new <see cref="T:CK.Core.ActivityMonitorConsoleClient"/>.
            </summary>
        </member>
        <member name="T:CK.Core.ActivityMonitorErrorCounter">
            <summary>
            Count fatal, error or warn that occurred. 
            It can also automatically adds a conclusion to closed groups that summarizes
            the number of fatals, errors and warnings.
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitorErrorCounter.TagErrorCounter">
            <summary>
            Gets the tag used for generated error conclusions ("c:ErrorCounter") when <see cref="P:CK.Core.ActivityMonitorErrorCounter.GenerateConclusion"/> is true.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorErrorCounter.#ctor(System.Boolean)">
            <summary>
            Initializes a new error counter with <see cref="P:CK.Core.ActivityMonitorErrorCounter.GenerateConclusion"/> sets to false.
            </summary>
            <param name="generateConclusion">True to generate a conclusion. See <see cref="P:CK.Core.ActivityMonitorErrorCounter.GenerateConclusion"/>.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorErrorCounter.OnUnfilteredLog(CK.Core.ActivityMonitorLogData)">
            <summary>
            Updates error counters.
            </summary>
            <param name="data">Log data. Never null.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorErrorCounter.OnOpenGroup(CK.Core.IActivityLogGroup)">
            <summary>
            Updates error counters.
            </summary>
            <param name="group">The newly opened <see cref="T:CK.Core.IActivityLogGroup"/>.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorErrorCounter.OnGroupClosing(CK.Core.IActivityLogGroup,System.Collections.Generic.List{CK.Core.ActivityLogGroupConclusion}@)">
            <summary>
            Handles group conclusion.
            </summary>
            <param name="group">The closing group.</param>
            <param name="conclusions">
            Mutable conclusions associated to the closing group. 
            This can be null if no conclusions have been added yet. 
            It is up to the first client that wants to add a conclusion to instantiate a new List object to carry the conclusions.
            </param>
        </member>
        <member name="M:CK.Core.ActivityMonitorErrorCounter.OnGroupClosed(CK.Core.IActivityLogGroup,System.Collections.Generic.IReadOnlyList{CK.Core.ActivityLogGroupConclusion})">
            <summary>
            Restores current to the previous one (or keep it on the root if no opened group exist).
            </summary>
            <param name="group">The log group.</param>
            <param name="conclusions">Texts that conclude the group.</param>
        </member>
        <member name="P:CK.Core.ActivityMonitorErrorCounter.Root">
            <summary>
            Gets the root <see cref="T:CK.Core.ActivityMonitorErrorCounter.State"/>.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorErrorCounter.Current">
            <summary>
            Gets the current <see cref="T:CK.Core.ActivityMonitorErrorCounter.State"/>.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorErrorCounter.GenerateConclusion">
            <summary>
            Gets or sets whether the Group conclusion must be generated.
            Defaults to false.
            </summary>
        </member>
        <member name="T:CK.Core.ActivityMonitorErrorCounter.State">
            <summary>
            Encapsulates error information.
            The <see cref="M:CK.Core.ActivityMonitorErrorCounter.State.ToString"/> method displays the conclusion in a default text format.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorErrorCounter.State.ClearError">
            <summary>
            Resets <see cref="P:CK.Core.ActivityMonitorErrorCounter.State.FatalCount"/> and <see cref="P:CK.Core.ActivityMonitorErrorCounter.State.ErrorCount"/>.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorErrorCounter.State.ClearWarn(System.Boolean)">
            <summary>
            Resets current <see cref="P:CK.Core.ActivityMonitorErrorCounter.State.WarnCount"/>, and optionnaly <see cref="P:CK.Core.ActivityMonitorErrorCounter.State.FatalCount"/> and <see cref="P:CK.Core.ActivityMonitorErrorCounter.State.ErrorCount"/>.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorErrorCounter.State.ToString">
            <summary>
            Gets the current message if <see cref="P:CK.Core.ActivityMonitorErrorCounter.State.HasWarnOrError"/> is true, otherwise null.
            </summary>
            <returns>Formatted message or null if no error nor warning occurred.</returns>
        </member>
        <member name="P:CK.Core.ActivityMonitorErrorCounter.State.FatalCount">
            <summary>
            Gets the current number of fatal errors.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorErrorCounter.State.ErrorCount">
            <summary>
            Gets the current number of errors.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorErrorCounter.State.WarnCount">
            <summary>
            Gets the current number of warnings.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorErrorCounter.State.MaxLogLevel">
            <summary>
            Gets the current maximum <see cref="T:CK.Core.LogLevel"/>.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorErrorCounter.State.HasError">
            <summary>
            Gets whether an error or a fatal occurred.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorErrorCounter.State.HasWarnOrError">
            <summary>
            Gets whether a fatal, an error or a warn occurred.
            </summary>
        </member>
        <member name="T:CK.Core.ActivityMonitorPathCatcher">
            <summary>
            The "Path Catcher" captures the current path of the opened groups and the last, current, line and exposes it thanks to 
            a read only list of <see cref="T:CK.Core.ActivityMonitorPathCatcher.PathElement"/> (the <see cref="P:CK.Core.ActivityMonitorPathCatcher.DynamicPath"/> property),
            plus two other specific paths, the <see cref="P:CK.Core.ActivityMonitorPathCatcher.LastErrorPath"/> and the <see cref="P:CK.Core.ActivityMonitorPathCatcher.LastWarnOrErrorPath"/>.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorPathCatcher.#ctor">
            <summary>
            Initializes a new <see cref="T:CK.Core.ActivityMonitorPathCatcher"/>.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorPathCatcher.ClearLastErrorPath">
            <summary>
            Clears current <see cref="P:CK.Core.ActivityMonitorPathCatcher.LastErrorPath"/> (sets it to null).
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorPathCatcher.ClearLastWarnPath(System.Boolean)">
            <summary>
            Clears current <see cref="P:CK.Core.ActivityMonitorPathCatcher.LastWarnOrErrorPath"/> (sets it to null), and
            optionally clears <see cref="P:CK.Core.ActivityMonitorPathCatcher.LastErrorPath"/>.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorPathCatcher.OnUnfilteredLog(CK.Core.ActivityMonitorLogData)">
            <summary>
            Appends or updates the last <see cref="T:CK.Core.ActivityMonitorPathCatcher.PathElement"/> of <see cref="P:CK.Core.ActivityMonitorPathCatcher.DynamicPath"/>
            and handles errors or warning.
            </summary>
            <param name="data">Log data. Never null.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorPathCatcher.OnOpenGroup(CK.Core.IActivityLogGroup)">
            <summary>
            Appends or updates the last <see cref="T:CK.Core.ActivityMonitorPathCatcher.PathElement"/> of <see cref="P:CK.Core.ActivityMonitorPathCatcher.DynamicPath"/>
            and handles errors or warning.
            </summary>
            <param name="group">The newly opened <see cref="T:CK.Core.IActivityLogGroup"/>.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorPathCatcher.OnGroupClosed(CK.Core.IActivityLogGroup,System.Collections.Generic.IReadOnlyList{CK.Core.ActivityLogGroupConclusion})">
            <summary>
            Removes one or two last <see cref="T:CK.Core.ActivityMonitorPathCatcher.PathElement"/> of <see cref="P:CK.Core.ActivityMonitorPathCatcher.DynamicPath"/>.
            </summary>
            <param name="group">The closed group.</param>
            <param name="conclusions">Texts that conclude the group. Never null but can be empty.</param>
        </member>
        <member name="P:CK.Core.ActivityMonitorPathCatcher.IsLocked">
            <summary>
            Gets or sets whether this <see cref="T:CK.Core.ActivityMonitorPathCatcher"/> can be removed from its monitor.
            Defaults to false. When setting this to true, <see cref="M:CK.Core.IActivityMonitorOutput.UnregisterClient(CK.Core.IActivityMonitorClient)"/>
            does not remove it.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorPathCatcher.DynamicPath">
            <summary>
            Gets the current (mutable) path. You should use <see cref="M:CK.Core.CKReadOnlyExtension.ToReadOnlyList``1(System.Collections.Generic.IList{``0})"/> or other ToArray 
            or ToList methods to take a snapshot of this list.
            Use the extension method <see cref="M:CK.Core.ActivityMonitorExtension.ToStringPath(System.Collections.Generic.IEnumerable{CK.Core.ActivityMonitorPathCatcher.PathElement},System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)"/> to easily format this path.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorPathCatcher.LastErrorPath">
            <summary>
            Gets the last <see cref="P:CK.Core.ActivityMonitorPathCatcher.DynamicPath"/> where an <see cref="F:CK.Core.LogLevel.Error"/> or a <see cref="F:CK.Core.LogLevel.Fatal"/> occurred.
            Null if no error nor fatal occurred.
            Use the extension method <see cref="M:CK.Core.ActivityMonitorExtension.ToStringPath(System.Collections.Generic.IEnumerable{CK.Core.ActivityMonitorPathCatcher.PathElement},System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)"/> to easily format this path.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorPathCatcher.LastWarnOrErrorPath">
            <summary>
            Gets the last path with a <see cref="F:CK.Core.LogLevel.Fatal"/>, <see cref="F:CK.Core.LogLevel.Error"/> or a <see cref="F:CK.Core.LogLevel.Warn"/>.
            Null if no error, fatal nor warn occurred.
            Use the extension method <see cref="M:CK.Core.ActivityMonitorExtension.ToStringPath(System.Collections.Generic.IEnumerable{CK.Core.ActivityMonitorPathCatcher.PathElement},System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)"/> to easily format this path.
            </summary>
        </member>
        <member name="T:CK.Core.ActivityMonitorPathCatcher.PathElement">
            <summary>
            Element of the <see cref="P:CK.Core.ActivityMonitorPathCatcher.DynamicPath">DynamicPath</see>, <see cref="P:CK.Core.ActivityMonitorPathCatcher.LastErrorPath">LastErrorPath</see>,
            or <see cref="P:CK.Core.ActivityMonitorPathCatcher.LastWarnOrErrorPath">LastWarnOrErrorPath</see>.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorPathCatcher.PathElement.ToString">
            <summary>
            Overridden to return the <see cref="P:CK.Core.ActivityMonitorPathCatcher.PathElement.Text"/> of this element.
            </summary>
            <returns>This <see cref="P:CK.Core.ActivityMonitorPathCatcher.PathElement.Text"/> property.</returns>
        </member>
        <member name="P:CK.Core.ActivityMonitorPathCatcher.PathElement.Tags">
            <summary>
            Gets the tags of the log entry.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorPathCatcher.PathElement.MaskedLevel">
            <summary>
            Gets the log level of the log entry.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorPathCatcher.PathElement.Text">
            <summary>
            Gets the text of the log entry.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorPathCatcher.PathElement.GroupConclusion">
            <summary>
            Gets the conclusions associated to a group. Null if this element does not correspond to a group.
            </summary>
        </member>
        <member name="T:CK.Core.ActivityMonitorSimpleCollector">
            <summary>
            Simple collector of log entries which level is greater or equal to <see cref="P:CK.Core.ActivityMonitorSimpleCollector.MinimalFilter"/>.
            Its <see cref="P:CK.Core.ActivityMonitorSimpleCollector.Capacity"/> defaults to 50 (no more than Capacity entries are kept).
            Used by the <see cref="M:CK.Core.ActivityMonitorExtension.Catch(CK.Core.IActivityMonitor,System.Action{System.Collections.Generic.IReadOnlyList{CK.Core.ActivityMonitorSimpleCollector.Entry}},CK.Core.LogLevelFilter)">Catch</see> extension method.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorSimpleCollector.#ctor">
            <summary>
            Initializes a new collector with an initial capacity of 50 errors (<see cref="P:CK.Core.ActivityMonitorSimpleCollector.MinimalFilter"/> is set to <see cref="F:CK.Core.LogLevelFilter.Error"/>).
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorSimpleCollector.Clear">
            <summary>
            Clears the current <see cref="P:CK.Core.ActivityMonitorSimpleCollector.Entries"/> list.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorSimpleCollector.CK#Core#IActivityMonitorClient#OnUnfilteredLog(CK.Core.ActivityMonitorLogData)">
            <summary>
            Appends any log with level equal or above <see cref="P:CK.Core.ActivityMonitorSimpleCollector.MinimalFilter"/> to <see cref="P:CK.Core.ActivityMonitorSimpleCollector.Entries"/>.
            </summary>
            <param name="data">Log data. Never null.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSimpleCollector.CK#Core#IActivityMonitorClient#OnOpenGroup(CK.Core.IActivityLogGroup)">
            <summary>
            Appends any group with level equal or above <see cref="P:CK.Core.ActivityMonitorSimpleCollector.MinimalFilter"/> to <see cref="P:CK.Core.ActivityMonitorSimpleCollector.Entries"/>.
            </summary>
            <param name="group">Log group description.</param>
        </member>
        <member name="P:CK.Core.ActivityMonitorSimpleCollector.Capacity">
            <summary>
            Gets or sets the maximum numbers of <see cref="T:CK.Core.ActivityMonitorSimpleCollector.Entry"/> that must be kept in <see cref="P:CK.Core.ActivityMonitorSimpleCollector.Entries"/>.
            Defaults to 50.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorSimpleCollector.MinimalFilter">
            <summary>
            Gets or sets the filter level.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorSimpleCollector.Entries">
            <summary>
            Gets a read only list of (at most) <see cref="P:CK.Core.ActivityMonitorSimpleCollector.Capacity"/> entries that occurred since last 
            call to <see cref="M:CK.Core.ActivityMonitorSimpleCollector.Clear"/>.
            </summary>
        </member>
        <member name="T:CK.Core.ActivityMonitorSimpleCollector.Entry">
            <summary>
            Element of the <see cref="P:CK.Core.ActivityMonitorSimpleCollector.Entries">Entries</see>.
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitorSimpleCollector.Entry.Tags">
            <summary>
            The tags of the log entry.
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitorSimpleCollector.Entry.MaskedLevel">
            <summary>
            The log level of the log entry.
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitorSimpleCollector.Entry.LogTime">
            <summary>
            Time of the log entry.
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitorSimpleCollector.Entry.Text">
            <summary>
            The text of the log entry.
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitorSimpleCollector.Entry.Exception">
            <summary>
            The exception of the log entry if any.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorSimpleCollector.Entry.ToString">
            <summary>
            Overridden to return the <see cref="F:CK.Core.ActivityMonitorSimpleCollector.Entry.Text"/> of this element.
            </summary>
            <returns>This <see cref="F:CK.Core.ActivityMonitorSimpleCollector.Entry.Text"/> property.</returns>
        </member>
        <member name="T:CK.Core.IActivityLogGroup">
            <summary>
            Exposes all the relevant information for a currently opened group.
            Groups are linked together from the current one to the very first one 
            thanks to the <see cref="P:CK.Core.IActivityLogGroup.Parent"/> property.
            </summary>
        </member>
        <member name="M:CK.Core.IActivityLogGroup.EnsureExceptionData">
            <summary>
            Gets or creates the <see cref="T:CK.Core.CKExceptionData"/> that captures exception information.
            If <see cref="P:Exception"/> is null, this method returns null.
            </summary>
            <returns></returns>
        </member>
        <member name="P:CK.Core.IActivityLogGroup.GroupTags">
            <summary>
            Gets the tags for the log group.
            </summary>
        </member>
        <member name="P:CK.Core.IActivityLogGroup.LogTime">
            <summary>
            Gets the log time for the log.
            </summary>
        </member>
        <member name="P:CK.Core.IActivityLogGroup.CloseLogTime">
            <summary>
            Gets the log time of the group closing.
            It is <see cref="F:CK.Core.DateTimeStamp.MinValue"/> when the group is not closed yet.
            </summary>
        </member>
        <member name="P:CK.Core.IActivityLogGroup.Parent">
            <summary>
            Get the previous group in its origin monitor. Null if this group is a top level group.
            </summary>
        </member>
        <member name="P:CK.Core.IActivityLogGroup.Depth">
            <summary>
            Gets the depth of this group in its origin monitor. (1 for top level groups).
            </summary>
        </member>
        <member name="P:CK.Core.IActivityLogGroup.SavedMonitorFilter">
            <summary>
            Gets the <see cref="P:CK.Core.IActivityMonitor.MinimalFilter"/> that will be restored when group will be closed.
            Initialized with the current value of IActivityMonitor.Filter when the group has been opened.
            </summary>
        </member>
        <member name="P:CK.Core.IActivityLogGroup.SavedMonitorTags">
            <summary>
            Gets the <see cref="P:CK.Core.IActivityMonitor.AutoTags"/> that will be restored when group will be closed.
            Initialized with the current value of IActivityMonitor.Tags when the group has been opened.
            </summary>
        </member>
        <member name="P:CK.Core.IActivityLogGroup.GroupLevel">
            <summary>
            Gets the level associated to this group.
            The <see cref="F:CK.Core.LogLevel.IsFiltered"/> can be set here: use <see cref="P:CK.Core.IActivityLogGroup.MaskedGroupLevel"/> to get 
            the actual level from <see cref="F:CK.Core.LogLevel.Trace"/> to <see cref="F:CK.Core.LogLevel.Fatal"/>.
            </summary>
        </member>
        <member name="P:CK.Core.IActivityLogGroup.MaskedGroupLevel">
            <summary>
            Gets the actual level (<see cref="F:CK.Core.LogLevel.Trace"/> to <see cref="F:CK.Core.LogLevel.Fatal"/>) associated to this group
            without <see cref="F:CK.Core.LogLevel.IsFiltered"/> bit.
            </summary>
        </member>
        <member name="P:CK.Core.IActivityLogGroup.GroupText">
            <summary>
            Gets the text associated to this group.
            </summary>
        </member>
        <member name="P:CK.Core.IActivityLogGroup.Exception">
            <summary>
            Gets the associated <see cref="P:CK.Core.IActivityLogGroup.Exception"/> if it exists.
            </summary>
        </member>
        <member name="P:CK.Core.IActivityLogGroup.ExceptionData">
            <summary>
            Gets the <see cref="T:CK.Core.CKExceptionData"/> that captures exception information 
            if it exists. Returns null if no <see cref="P:Exception"/> exists.
            </summary>
        </member>
        <member name="P:CK.Core.IActivityLogGroup.IsGroupTextTheExceptionMessage">
            <summary>
            Gets whether the <see cref="P:CK.Core.IActivityLogGroup.GroupText"/> is actually the <see cref="P:CK.Core.IActivityLogGroup.Exception"/> message.
            </summary>
        </member>
        <member name="P:CK.Core.IActivityLogGroup.FileName">
            <summary>
            Gets the file name of the source code that issued the log.
            </summary>
        </member>
        <member name="P:CK.Core.IActivityLogGroup.LineNumber">
            <summary>
            Gets the line number of the <see cref="P:CK.Core.IActivityLogGroup.FileName"/> that issued the log.
            </summary>
        </member>
        <member name="T:CK.Core.IActivityMonitor">
            <summary>
            Defines the core Activity Monitor interface. Small is beautiful. 
            </summary>
            <remarks>
            This is not the same as a classical logging framework: the "activity" captures by an activity monitor is structured. 
            It can be seen as a "Story Writer": its output can be displayed to an end user (even if some structured information 
            can easily be injected).
            Furthermore, activities can be tracked (with the help of the developer of course) across threads, tasks or application domain.
            </remarks>
        </member>
        <member name="M:CK.Core.IActivityMonitor.SetTopic(System.String,System.String,System.Int32)">
            <summary>
            Sets the current topic for this monitor. This can be any non null string (null topic is mapped to the empty string) that describes
            the current activity.
            </summary>
            <param name="fileName">The source code file name from which the topic is set.</param>
            <param name="lineNumber">The line number in the source from which the topic is set.</param>
            <param name="newTopic">The new topic string to associate to this monitor.</param>
        </member>
        <member name="M:CK.Core.IActivityMonitor.UnfilteredLog(CK.Core.ActivityMonitorLogData)">
            <summary>
            Logs a line regardless of <see cref="P:CK.Core.IActivityMonitor.ActualFilter"/> level (except for <see cref="F:CK.Core.LogLevelFilter.Off"/>). 
            </summary>
            <param name="data">Data that describes the log. Can not be null.</param>
        </member>
        <member name="M:CK.Core.IActivityMonitor.UnfilteredOpenGroup(CK.Core.ActivityMonitorGroupData)">
            <summary>
            Opens a group regardless of <see cref="P:CK.Core.IActivityMonitor.ActualFilter"/> level (except for <see cref="F:CK.Core.LogLevelFilter.Off"/>). 
            <see cref="M:CK.Core.IActivityMonitor.CloseGroup(CK.Core.DateTimeStamp,System.Object)"/> must be called in order to close the group, and/or the returned object must be disposed (both safely can be called: 
            the group is closed on the first action, the second one is ignored).
            </summary>
            <param name="data">Data that describes the log. Can not be null.</param>
            <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
            <remarks>
            <para>
            Opening a group does not change the current <see cref="P:CK.Core.IActivityMonitor.MinimalFilter"/>, except when opening a <see cref="F:CK.Core.LogLevel.Fatal"/> or <see cref="F:CK.Core.LogLevel.Error"/> group:
            in such case, the MinimalFilter is automatically sets to <see cref="F:CK.Core.LogFilter.Debug"/> to capture all potential information inside the error group.
            </para>
            <para>
            Changes to the monitor's current Filter or AutoTags that occur inside a group are automatically restored to their original values when the group is closed.
            This behavior guaranties that a local modification (deep inside unknown called code) does not impact caller code: groups are a way to easily isolate such 
            configuration changes.
            </para>
            <para>
            Note that this automatic configuration restoration works even if the group has been filtered.
            </para>
            </remarks>
        </member>
        <member name="M:CK.Core.IActivityMonitor.CloseGroup(CK.Core.DateTimeStamp,System.Object)">
            <summary>
            Closes the current Group. Optional parameter is polymorphic. It can be a string, a <see cref="T:CK.Core.ActivityLogGroupConclusion"/>, 
            a <see cref="T:System.Collections.Generic.List`1"/> or an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of ActivityLogGroupConclusion, or any object with an overridden <see cref="M:System.Object.ToString"/> method. 
            See remarks (especially for List&lt;ActivityLogGroupConclusion&gt;).
            </summary>
            <param name="userConclusion">Optional string, ActivityLogGroupConclusion object, enumerable of ActivityLogGroupConclusion or object to conclude the group. See remarks.</param>
            <param name="logTime">
            Log time of the closing of the group. 
            You can use <see cref="P:CK.Core.DateTimeStamp.UtcNow"/> or <see cref="M:CK.Core.ActivityMonitorExtension.NextLogTime(CK.Core.IActivityMonitor)">IActivityMonitor.NextLogTime()</see> extension method.</param>
            <remarks>
            An untyped object is used here to easily and efficiently accommodate both string and already existing ActivityLogGroupConclusion.
            When a List&lt;ActivityLogGroupConclusion&gt; is used, it will be directly used to collect conclusion objects (new conclusions will be added to it). This is an optimization.
            </remarks>
        </member>
        <member name="P:CK.Core.IActivityMonitor.AutoTags">
            <summary>
            Gets or sets the tags of this monitor: any subsequent logs will be tagged by these tags.
            The <see cref="T:CK.Core.CKTrait"/> must be registered in <see cref="T:CK.Core.ActivityMonitor.Tags"/>.
            Modifications to this property are scoped to the current Group since when a Group is closed, this
            property (and <see cref="P:CK.Core.IActivityMonitor.MinimalFilter"/>) is automatically restored to its original value (captured when the Group was opened).
            </summary>
        </member>
        <member name="P:CK.Core.IActivityMonitor.MinimalFilter">
            <summary>
            Gets or sets a filter for the log level.
            Modifications to this property are scoped to the current Group since when a Group is closed, this
            property (and <see cref="P:CK.Core.IActivityMonitor.AutoTags"/>) is automatically restored to its original value (captured when the Group was opened).
            Defaults to <see cref="F:CK.Core.LogFilter.Undefined"/>.
            </summary>
        </member>
        <member name="P:CK.Core.IActivityMonitor.ActualFilter">
            <summary>
            Gets the actual filter level for logs: this combines the configured <see cref="P:CK.Core.IActivityMonitor.MinimalFilter"/> and the minimal requirements
            of any <see cref="T:CK.Core.IActivityMonitorBoundClient"/> that specifies such a minimal filter level.
            </summary>
            <remarks>
            This does NOT take into account the static (application-domain) <see cref="P:CK.Core.ActivityMonitor.DefaultFilter"/>.
            This global default must be used if this ActualFilter is <see cref="F:CK.Core.LogLevelFilter.None"/> for <see cref="F:CK.Core.LogFilter.Line"/> or <see cref="F:CK.Core.LogFilter.Group"/>: 
            the <see cref="M:CK.Core.ActivityMonitorExtension.ShouldLogLine(CK.Core.IActivityMonitor,CK.Core.LogLevel,System.String,System.Int32)">ShouldLog</see> extension method takes it into account.
            </remarks>
        </member>
        <member name="P:CK.Core.IActivityMonitor.Topic">
            <summary>
            Gets the current topic for this monitor. This can be any non null string (null topic is mapped to the empty string) that describes
            the current activity. It must be set with <see cref="M:CK.Core.IActivityMonitor.SetTopic(System.String,System.String,System.Int32)"/> and unlike <see cref="P:CK.Core.IActivityMonitor.MinimalFilter"/> and <see cref="P:CK.Core.IActivityMonitor.AutoTags"/>, 
            the topic is not reseted when groups are closed.
            </summary>
            <remarks>
            Clients are warned of the change thanks to <see cref="M:CK.Core.IActivityMonitorClient.OnTopicChanged(System.String,System.String,System.Int32)"/> and an unfiltered <see cref="F:CK.Core.LogLevel.Info"/> log 
            with the new topic prefixed with "Topic:" and tagged with <see cref="F:CK.Core.ActivityMonitor.Tags.MonitorTopicChanged"/> is emitted.
            </remarks>
        </member>
        <member name="P:CK.Core.IActivityMonitor.Output">
            <summary>
            Gets the <see cref="T:CK.Core.IActivityMonitorOutput"/> for this monitor.
            </summary>
        </member>
        <member name="P:CK.Core.IActivityMonitor.LastLogTime">
            <summary>
            Gets the last <see cref="T:CK.Core.DateTimeStamp"/> for this monitor.
            </summary>
        </member>
        <member name="T:CK.Core.IActivityMonitorGroupSender">
            <summary>
            The interface that carries Send extension methods for groups.
            </summary>
        </member>
        <member name="P:CK.Core.IActivityMonitorGroupSender.IsRejected">
            <summary>
            Gets whether the log has been rejected.
            </summary>
        </member>
        <member name="T:CK.Core.IActivityMonitorLineSender">
            <summary>
            The interface that carries Send extension methods.
            </summary>
        </member>
        <member name="P:CK.Core.IActivityMonitorLineSender.IsRejected">
            <summary>
            Gets whether the log has been rejected.
            </summary>
        </member>
        <member name="T:CK.Core.IActivityMonitorOutput">
            <summary>
            Offers <see cref="T:CK.Core.IActivityMonitorClient"/> registration/unregistration and exposes a <see cref="P:CK.Core.IActivityMonitorOutput.BridgeTarget"/> 
            (an <see cref="T:CK.Core.ActivityMonitorBridgeTarget"/>) that can be used to accept logs from other monitors.
            </summary>
        </member>
        <member name="M:CK.Core.IActivityMonitorOutput.RegisterClient(CK.Core.IActivityMonitorClient,System.Boolean@)">
            <summary>
            Registers an <see cref="T:CK.Core.IActivityMonitorClient"/> to the <see cref="P:CK.Core.IActivityMonitorOutput.Clients"/> list.
            Duplicate IActivityMonitorClient instances are ignored.
            </summary>
            <param name="client">An <see cref="T:CK.Core.IActivityMonitorClient"/> implementation.</param>
            <param name="added">True if the client has been added, false if it was already registered.</param>
            <returns>The registered client.</returns>
        </member>
        <member name="M:CK.Core.IActivityMonitorOutput.RegisterClient``1(``0,System.Boolean@)">
            <summary>
            Registers a typed <see cref="T:CK.Core.IActivityMonitorClient"/>.
            </summary>
            <typeparam name="T">Any type that specializes <see cref="T:CK.Core.IActivityMonitorClient"/>.</typeparam>
            <param name="client">Client to register.</param>
            <param name="added">True if the client has been added, false if it was already registered.</param>
            <returns>The registered client.</returns>
        </member>
        <member name="M:CK.Core.IActivityMonitorOutput.UnregisterClient(CK.Core.IActivityMonitorClient)">
            <summary>
            Unregisters the given <see cref="T:CK.Core.IActivityMonitorClient"/> from the <see cref="P:CK.Core.IActivityMonitorOutput.Clients"/> list.
            Silently ignores an unregistered client.
            </summary>
            <param name="client">An <see cref="T:CK.Core.IActivityMonitorClient"/> implementation.</param>
            <returns>The unregistered client or null if it has not been found.</returns>
        </member>
        <member name="M:CK.Core.IActivityMonitorOutput.RegisterUniqueClient``1(System.Func{``0,System.Boolean},System.Func{``0})">
            <summary>
            Registers a <see cref="T:CK.Core.IActivityMonitorClient"/> that must be unique in a sense.
            </summary>
            <param name="tester">Predicate that must be satisfied for at least one registered client.</param>
            <param name="factory">Factory that will be called if no existing client satisfies <paramref name="tester"/>.</param>
            <returns>The found or newly created client.</returns>
            <remarks>
            The factory function MUST return a client that satisfies the tester function otherwise a <see cref="T:System.InvalidOperationException"/> is thrown.
            The factory is called only when the no client satisfies the tester function: this makes the 'added' out parameter useless.
            </remarks>
        </member>
        <member name="P:CK.Core.IActivityMonitorOutput.Clients">
            <summary>
            Gets the list of registered <see cref="T:CK.Core.IActivityMonitorClient"/>.
            </summary>
        </member>
        <member name="P:CK.Core.IActivityMonitorOutput.BridgeTarget">
            <summary>
            Gets an entry point for other monitors: by registering <see cref="T:CK.Core.ActivityMonitorBridge"/> in other <see cref="P:CK.Core.IActivityMonitor.Output"/>
            bound to this <see cref="T:CK.Core.ActivityMonitorBridgeTarget"/>, log streams can easily be merged.
            </summary>
        </member>
        <member name="T:CK.Core.IDisposableActivityMonitor">
            <summary>
            A diposable <see cref="T:CK.Core.IActivityMonitor"/>.
            </summary>
        </member>
        <member name="T:CK.Core.IDisposableGroup">
            <summary>
            Interface obtained once a Group has been opened.
            </summary>
        </member>
        <member name="M:CK.Core.IDisposableGroup.SetTopic(System.String)">
            <summary>
            Sets a temporary topic associated to this group.
            The current monitor's topic will be automatically restored when group will be closed.
            </summary>
            <param name="topicOtherThanGroupText">Explicit topic it it must differ from the group's text.</param>
            <returns>This object in order to call <see cref="M:CK.Core.IDisposableGroup.ConcludeWith(System.Func{System.String})"/> or to dispose it to close the group.</returns>
        </member>
        <member name="M:CK.Core.IDisposableGroup.ConcludeWith(System.Func{System.String})">
            <summary>
            Sets a function that will be called on group closing to generate a conclusion.
            </summary>
            <param name="getConclusionText">Function that generates a group conclusion.</param>
            <returns>A disposable object that can be used to close the group.</returns>
        </member>
        <member name="T:CK.Core.ActivityMonitor">
            <summary>
            Concrete implementation of <see cref="T:CK.Core.IActivityMonitor"/>.
            </summary>
            <summary>
            Concrete implementation of <see cref="T:CK.Core.IActivityMonitor"/>.
            </summary>
            <summary>
            Concrete implementation of <see cref="T:CK.Core.IActivityMonitor"/>.
            </summary>
        </member>
        <member name="T:CK.Core.Impl.IActivityMonitorImpl">
            <summary>
            Defines required aspects that an actual monitor implementation must support.
            </summary>
        </member>
        <member name="T:CK.Core.IUniqueId">
            <summary>
            Minimal interface that enables any type (specially reference type) to
            expose a <see cref="T:System.Guid"/>.
            </summary>
        </member>
        <member name="P:CK.Core.IUniqueId.UniqueId">
            <summary>
            Gets the unique identifier associated to this object.
            </summary>
        </member>
        <member name="M:CK.Core.Impl.IActivityMonitorImpl.ReentrancyAndConcurrencyLock">
            <summary>
            Gets a disposable object that checks for reentrant and concurrent calls.
            </summary>
            <returns>A disposable object (that must be disposed).</returns>
        </member>
        <member name="M:CK.Core.Impl.IActivityMonitorImpl.OnClientMinimalFilterChanged(CK.Core.LogFilter,CK.Core.LogFilter)">
            <summary>
            Enables a <see cref="T:CK.Core.IActivityMonitorBoundClient"/> to warn its Monitor
            whenever its <see cref="P:CK.Core.IActivityMonitorBoundClient.MinimalFilter"/> changed.
            This can be called from any <see cref="T:CK.Core.IActivityMonitorBoundClient"/> methods (when a <see cref="M:CK.Core.Impl.IActivityMonitorImpl.ReentrancyAndConcurrencyLock"/> has 
            been acquired) or not, but NOT concurrently: <see cref="M:CK.Core.Impl.IActivityMonitorImpl.SetClientMinimalFilterDirty"/> must be used to signal
            a change on any thread at any time.
            </summary>
            <param name="oldLevel">The previous minimal level that the client expected.</param>
            <param name="newLevel">The new minimal level that the client expects.</param>
        </member>
        <member name="M:CK.Core.Impl.IActivityMonitorImpl.SetClientMinimalFilterDirty">
            <summary>
            Signals the monitor that one of the <see cref="P:CK.Core.IActivityMonitorBoundClient.MinimalFilter"/> has changed:
            the <see cref="P:CK.Core.IActivityMonitor.ActualFilter"/> is marked as needing a re computation in a thread-safe manner.
            This can be called by bound clients on any thread at any time as opposed to <see cref="M:CK.Core.Impl.IActivityMonitorImpl.OnClientMinimalFilterChanged(CK.Core.LogFilter,CK.Core.LogFilter)"/>
            that can only be called non-concurrently (typically from inside client methods).
            </summary>
        </member>
        <member name="M:CK.Core.Impl.IActivityMonitorImpl.InitializeTopicAndAutoTags(System.String,CK.Core.CKTrait,System.String,System.Int32)">
            <summary>
            Enables <see cref="T:CK.Core.IActivityMonitorBoundClient"/> clients to initialize Topic and AutoTag typically from 
            inside their <see cref="M:CK.Core.IActivityMonitorBoundClient.SetMonitor(CK.Core.Impl.IActivityMonitorImpl,System.Boolean)"/> method or any other methods provided 
            that a reentrant and concurrent lock has been obtained (otherwise an <see cref="T:System.InvalidOperationException"/> is thrown).
            </summary>
            <param name="newTopic">New topic to set. When null, it is ignored.</param>
            <param name="newTags">new tags to set. When null, it is ignored.</param>
            <param name="fileName">Source file name of the caller. Do not set it: the attribute will do the job.</param>
            <param name="lineNumber">Line number in the source file. Do not set it: the attribute will do the job.</param>
        </member>
        <member name="P:CK.Core.Impl.IActivityMonitorImpl.CurrentGroup">
            <summary>
            Gets the currently opened group.
            Null when no group is currently opened.
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitor.SetTopicPrefix">
            <summary>
            Prefix used by <see cref="M:CK.Core.IActivityMonitor.SetTopic(System.String,System.String,System.Int32)"/> is "Topic: ".
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitor.ParkLevel">
            <summary>
            String to use to break the current <see cref="T:CK.Core.LogLevel"/> (as if a different <see cref="T:CK.Core.LogLevel"/> was used).
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitor.CriticalErrorCollector">
            <summary>
            The monitoring error collector. 
            Any error that occurs while dispatching logs to <see cref="T:CK.Core.IActivityMonitorClient"/>
            are collected and the culprit is removed from <see cref="P:CK.Core.ActivityMonitor.Output"/>.
            See <see cref="T:CriticalErrorCollector"/>.
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitor.AutoConfiguration">
            <summary>
            The automatic configuration actions.
            Registers actions via += (or <see cref="G:Delegate.Combine"/> if you like pain), unregister with -= operator (or <see cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)"/>).
            Simply sets it to null to clear all currently registered actions (this, of course, only from tests and not in real code).
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitor.#ctor">
            <summary>
            Initializes a new <see cref="T:CK.Core.ActivityMonitor"/> that applies all <see cref="F:CK.Core.ActivityMonitor.AutoConfiguration"/> and has no <see cref="P:CK.Core.ActivityMonitor.Topic"/> initially set.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitor.#ctor(System.String)">
            <summary>
            Initializes a new <see cref="T:CK.Core.ActivityMonitor"/> that applies all <see cref="F:CK.Core.ActivityMonitor.AutoConfiguration"/> and has an initial <see cref="P:CK.Core.ActivityMonitor.Topic"/> set.
            </summary>
            <param name="topic">Initial topic (can be null).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitor.#ctor(System.Boolean,System.String)">
            <summary>
            Initializes a new <see cref="T:CK.Core.ActivityMonitor"/> that optionally applies <see cref="F:CK.Core.ActivityMonitor.AutoConfiguration"/> and with an initial topic.
            </summary>
            <param name="applyAutoConfigurations">Whether <see cref="F:CK.Core.ActivityMonitor.AutoConfiguration"/> should be applied.</param>
            <param name="topic">Optional initial topic (can be null).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitor.#ctor(CK.Core.Impl.ActivityMonitorOutput,CK.Core.CKTrait,System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.ActivityMonitor"/> with a specific <see cref="P:CK.Core.ActivityMonitor.Output"/> or null
            to postpone the setting of Output by using <see cref="M:CK.Core.ActivityMonitor.SetOutput(CK.Core.Impl.ActivityMonitorOutput)"/>.
            </summary>
            <param name="output">The output to use. Can be null.</param>
            <param name="tags">Initial tags.</param>
            <param name="applyAutoConfigurations">Whether <see cref="F:CK.Core.ActivityMonitor.AutoConfiguration"/> should be applied.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitor.SetUniqueId(System.Guid)">
            <summary>
            Sets the unique identifier of this activity monitor.
            This must be used only during monitor construction or initialization, before the 
            monitor is actually used.
            </summary>
            <param name="uniqueId">New unique identifier.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitor.SetOutput(CK.Core.Impl.ActivityMonitorOutput)">
            <summary>
            Sets the <see cref="P:CK.Core.ActivityMonitor.Output"/>.
            </summary>
            <param name="output">Can not be null.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitor.SetTopic(System.String,System.String,System.Int32)">
            <summary>
            Sets the current topic for this monitor. This can be any non null string (null topic is mapped to the empty string) that describes
            the current activity.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitor.CK#Core#Impl#IActivityMonitorImpl#InitializeTopicAndAutoTags(System.String,CK.Core.CKTrait,System.String,System.Int32)">
            <summary>
            Called by IActivityMonitorBoundClient clients to initialize Topic and AutoTag from 
            inside their SetMonitor or any other methods provided that a reentrant and concurrent lock 
            has been obtained (otherwise an InvalidOperationException is thrown).
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitor.UnfilteredLog(CK.Core.ActivityMonitorLogData)">
            <summary>
            Logs a text regardless of <see cref="P:CK.Core.ActivityMonitor.MinimalFilter"/> level (except for <see cref="F:CK.Core.LogLevelFilter.Off"/>). 
            Each call to log is considered as a unit of text: depending on the rendering engine, a line or a 
            paragraph separator (or any appropriate separator) should be appended between each text if 
            the level is the same as the previous one.
            See remarks.
            </summary>
            <param name="data">Data that describes the log. Can not be null.</param>
            <remarks>
            A null or empty <see cref="P:CK.Core.ActivityMonitorLogData.Text"/> is not logged.
            If needed, the special text <see cref="F:CK.Core.ActivityMonitor.ParkLevel"/> ("PARK-LEVEL") breaks the current <see cref="T:CK.Core.LogLevel"/>
            and resets it: the next log, even with the same LogLevel, will be treated as if
            a different LogLevel is used.
            </remarks>
        </member>
        <member name="M:CK.Core.ActivityMonitor.UnfilteredOpenGroup(CK.Core.ActivityMonitorGroupData)">
            <summary>
            Opens a group regardless of <see cref="P:CK.Core.ActivityMonitor.ActualFilter"/> level (except for <see cref="F:CK.Core.LogLevelFilter.Off"/>). 
            <see cref="M:CK.Core.ActivityMonitor.CloseGroup(CK.Core.DateTimeStamp,System.Object)"/> must be called in order to close the group, and/or the returned object must be disposed (both safely can be called: 
            the group is closed on the first action, the second one is ignored).
            </summary>
            <param name="data">Data that describes the log. Can not be null.</param>
            <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
            <remarks>
            <para>
            Opening a group does not change the current <see cref="P:CK.Core.ActivityMonitor.MinimalFilter"/>, except when opening a <see cref="F:CK.Core.LogLevel.Fatal"/> or <see cref="F:CK.Core.LogLevel.Error"/> group:
            in such case, the MinimalFilter is automatically sets to <see cref="F:CK.Core.LogFilter.Debug"/> to capture all potential information inside the error group.
            </para>
            <para>
            Changes to the monitor's current Filter or AutoTags that occur inside a group are automatically restored to their original values when the group is closed.
            This behavior guaranties that a local modification (deep inside unknown called code) does not impact caller code: groups are a way to easily isolate such 
            configuration changes.
            </para>
            <para>
            Note that this automatic configuration restoration works even if the group has been filtered.
            </para>
            </remarks>
        </member>
        <member name="M:CK.Core.ActivityMonitor.CloseGroup(CK.Core.DateTimeStamp,System.Object)">
            <summary>
            Closes the current <see cref="T:CK.Core.ActivityMonitor.Group"/>. Optional parameter is polymorphic. It can be a string, a <see cref="T:CK.Core.ActivityLogGroupConclusion"/>, 
            a <see cref="T:System.Collections.Generic.List`1"/> or an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of ActivityLogGroupConclusion, or any object with an overridden <see cref="M:System.Object.ToString"/> method. 
            See remarks (especially for List&lt;ActivityLogGroupConclusion&gt;).
            </summary>
            <param name="userConclusion">Optional string, enumerable of <see cref="T:CK.Core.ActivityLogGroupConclusion"/>) or object to conclude the group. See remarks.</param>
            <param name="logTime">Times-tamp of the group closing.</param>
            <remarks>
            An untyped object is used here to easily and efficiently accommodate both string and already existing ActivityLogGroupConclusion.
            When a List&lt;ActivityLogGroupConclusion&gt; is used, it will be directly used to collect conclusion objects (new conclusions will be added to it). This is an optimization.
            </remarks>
        </member>
        <member name="M:CK.Core.ActivityMonitor.MonoParameterSafeCall``1(System.Action{CK.Core.IActivityMonitorClient,``0},``0)">
            <summary>
            Generalizes calls to IActivityMonitorClient methods that have only one parameter.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitor.ReentrancyAndConcurrencyLock">
            <summary>
            Gets a disposable object that checks for reentrant and concurrent calls.
            </summary>
            <returns>A disposable object (that must be disposed).</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitor.ConcurrentOnlyCheck">
            <summary>
            Checks only for concurrency issues. 
            False if a call already exists (reentrant call): when true is returned, ReentrantAndConcurrentRelease must be called.
            </summary>
            <returns>False for a reentrant call, true otherwise.</returns>
        </member>
        <member name="E:CK.Core.ActivityMonitor.DefaultFilterLevelChanged">
            <summary>
            Internal event used by ActivityMonitorBridgeTarget that have at least one ActivityMonitorBridge in another application domain.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.DefaultFilter">
            <summary>
            Gets or sets the default filter that should be used when the <see cref="P:CK.Core.IActivityMonitor.ActualFilter"/> is <see cref="F:CK.Core.LogFilter.Undefined"/>.
            This configuration is per application domain (the backing field is static).
            It defaults to <see cref="F:CK.Core.LogFilter.Undefined"/>: it has the same effect as setting it to <see cref="F:CK.Core.LogFilter.Debug"/> (i.e. sending everything) when
            no other configuration exists.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.UniqueId">
            <summary>
            Gets the unique identifier for this monitor.
            It is a <see cref="M:System.Guid.NewGuid"/> by default but specialized implementations can set it
            via the protected <see cref="M:CK.Core.ActivityMonitor.SetUniqueId(System.Guid)"/> if a unique identifier exists in the context 
            that can more easily identify this activity.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.Output">
            <summary>
            Gets the <see cref="T:CK.Core.IActivityMonitorOutput"/> for this monitor.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.LastLogTime">
            <summary>
            Gets the last <see cref="T:CK.Core.DateTimeStamp"/> for this monitor.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.Topic">
            <summary>
            Gets the current topic for this monitor. This can be any non null string (null topic is mapped to the empty string) that describes
            the current activity. It must be set with <see cref="M:CK.Core.ActivityMonitor.SetTopic(System.String,System.String,System.Int32)"/> and unlike <see cref="P:CK.Core.ActivityMonitor.MinimalFilter"/> and <see cref="P:CK.Core.ActivityMonitor.AutoTags"/>, 
            the topic is not reseted when groups are closed.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.AutoTags">
            <summary>
            Gets or sets the tags of this monitor: any subsequent logs will be tagged by these tags.
            The <see cref="T:CK.Core.CKTrait"/> must be registered in <see cref="T:CK.Core.ActivityMonitor.Tags"/>.
            Modifications to this property are scoped to the current Group since when a Group is closed, this
            property (like <see cref="P:CK.Core.ActivityMonitor.MinimalFilter"/>) is automatically restored to its original value (captured when the Group was opened).
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.MinimalFilter">
            <summary>
            Gets or sets a filter based for the log level.
            Modifications to this property are scoped to the current Group since when a Group is closed, this
            property (like <see cref="P:CK.Core.ActivityMonitor.AutoTags"/>) is automatically restored to its original value (captured when the Group was opened).
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.ActualFilter">
            <summary>
            Gets the actual filter level for logs: this combines the configured <see cref="P:CK.Core.ActivityMonitor.MinimalFilter"/> and the minimal requirements
            of any <see cref="T:CK.Core.IActivityMonitorBoundClient"/> that specifies such a minimal filter level.
            </summary>
            <remarks>
            This does NOT take into account the static (application-domain) <see cref="P:CK.Core.ActivityMonitor.DefaultFilter"/>.
            This global default must be used if this ActualFilter is <see cref="F:CK.Core.LogLevelFilter.None"/> for <see cref="F:CK.Core.LogFilter.Line"/> or <see cref="F:CK.Core.LogFilter.Group"/>: 
            the <see cref="M:CK.Core.ActivityMonitorExtension.ShouldLogLine(CK.Core.IActivityMonitor,CK.Core.LogLevel,System.String,System.Int32)">ShouldLog</see> extension method takes it into account.
            </remarks>
        </member>
        <member name="P:CK.Core.ActivityMonitor.CurrentGroup">
            <summary>
            Gets the currently opened group.
            Null when no group is currently opened.
            </summary>
        </member>
        <member name="T:CK.Core.ActivityMonitor.Tags">
            <summary>
            Thread-safe context for tags used to categorize log entries (and group conclusions).
            All tags used in monitoring must be <see cref="M:CK.Core.ActivityMonitor.Tags.Register(System.String)"/>ed here.
            </summary>
            <remarks>
            Tags used for conclusions should start with "c:".
            </remarks>
        </member>
        <member name="F:CK.Core.ActivityMonitor.Tags.Context">
            <summary>
            The central, unique, context of all monitoring related tags used in the application domain.
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitor.Tags.Empty">
            <summary>
            Shortcut to <see cref="P:CK.Core.CKTraitContext.EmptyTrait">Context.EmptyTrait</see>.
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitor.Tags.CreateDependentActivity">
            <summary>
            Creation of dependent activities are marked with "dep:CreateActivity".
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitor.Tags.StartDependentActivity">
            <summary>
            Start of dependent activities are marked with "dep:StartActivity".
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitor.Tags.UserConclusion">
            <summary>
            Conclusions provided to IActivityMonitor.Close(string) are marked with "c:User".
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitor.Tags.GetTextConclusion">
            <summary>
            Conclusions returned by the optional function when a group is opened (see <see cref="M:CK.Core.IActivityMonitor.UnfilteredOpenGroup(CK.Core.ActivityMonitorGroupData)"/>) are marked with "c:GetText".
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitor.Tags.MonitorTopicChanged">
            <summary>
            Whenever <see cref="P:CK.Core.ActivityMonitor.Topic"/> changed, a <see cref="F:CK.Core.LogLevel.Info"/> is emitted marked with "MonitorTopicChanged".
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitor.Tags.Register(System.String)">
            <summary>
            Simple shortcut to <see cref="M:CK.Core.CKTraitContext.FindOrCreate(System.String)"/>.
            </summary>
            <param name="tags">Atomic tag or multiple tags separated by pipes (|).</param>
            <returns>Registered tags.</returns>
        </member>
        <member name="T:CK.Core.ActivityMonitor.DependentToken">
            <summary>
            Describes the origin of a dependent activity: it is created by <see cref="M:CK.Core.ActivityMonitorExtension.DependentActivity(CK.Core.IActivityMonitor,System.String,System.Int32)">IActivityMonitor.DependentActivity</see> 
            (extension methods).
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitor.DependentToken.ToString">
            <summary>
            Overridden to give a readable description (without Topic: this is the same as what appears in the start message info). 
            It can be parsed with <see cref="M:CK.Core.ActivityMonitor.DependentToken.TryParseStartMessage(System.String,System.Guid@,CK.Core.DateTimeStamp@)"/>.
            </summary>
            <returns>A readable string (the start message).</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitor.DependentToken.CreateDependentMonitor(System.Action{CK.Core.IActivityMonitor},System.String,System.Int32)">
            <summary>
            Creates a monitor and executes <see cref="M:CK.Core.ActivityMonitorExtension.DependentSender.StartDependentActivity(CK.Core.ActivityMonitor.DependentToken)">StartDependentActivity</see> on it
            that opens a root info group with the token information.
            </summary>
            <param name="configurator">Optionally applies any configuration on the created monitor before opening the root activity group.</param>
            <param name="fileName">Source file name of the emitter (automatically injected by C# compiler but can be explicitly set).</param>
            <param name="lineNumber">Line number in the source file (automatically injected by C# compiler but can be explicitly set).</param>
            <returns>An activity monitor that must be disposed when the activity ends (to close any opened groups).</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitor.DependentToken.TryParseLaunchOrCreateMessage(System.String,System.Boolean@,System.Boolean@,System.String@)">
            <summary>
            Tries to parse a launch message. 
            </summary>
            <param name="message">The message to parse.</param>
            <param name="launched">True if the activity has been launched or the token has only be created.</param>
            <param name="withTopic">True if an explicit topic has been associated to the dependent activity.</param>
            <param name="dependentTopic">When <paramref name="withTopic"/> is true, this contains the explicitly set topic.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitor.DependentToken.TryParseStartMessage(System.String,System.Guid@,CK.Core.DateTimeStamp@)">
            <summary>
            Attempts to parse the start message of a dependent activity (tagged with <see cref="F:CK.Core.ActivityMonitor.Tags.StartDependentActivity"/>).
            </summary>
            <param name="startMessage">The start message to parse.</param>
            <param name="id">The originator monitor identifier.</param>
            <param name="time">The creation time of the dependent activity.</param>
            <returns>True on success.</returns>
        </member>
        <member name="P:CK.Core.ActivityMonitor.DependentToken.OriginatorId">
            <summary>
            Unique identifier of the activity that created this dependent token.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.DependentToken.CreationDate">
            <summary>
            Gets the creation date. This is the log time of the unfiltered Info log that has 
            been emitted in the originator monitor.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.DependentToken.Topic">
            <summary>
            Gets the topic that must be set on the dependent activity.
            When null, the current <see cref="P:CK.Core.IActivityMonitor.Topic"/> of the dependent monitor is not changed.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.DependentToken.DelayedLaunchMessage">
            <summary>
            Captures the log message when created with a delayed launch so that DependentSender.Launch( token ) can log it.
            </summary>
        </member>
        <member name="T:CK.Core.ActivityMonitor.Group">
            <summary>
            Groups are bound to an <see cref="T:CK.Core.ActivityMonitor"/> and are linked together from 
            the current one to the very first one (a kind of stack).
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitor.Group.Monitor">
            <summary>
            The monitor that owns this group.
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitor.Group.Index">
            <summary>
            The raw index of the group. 
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitor.Group.#ctor(CK.Core.ActivityMonitor,System.Int32)">
            <summary>
            Initialized a new Group at a given index.
            </summary>
            <param name="monitor">Monitor.</param>
            <param name="index">Index of the group.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitor.Group.Initialize(CK.Core.ActivityMonitorGroupData)">
            <summary>
            Initializes or reinitializes this group (if it has been disposed). 
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitor.Group.InitializeRejectedGroup(CK.Core.ActivityMonitorGroupData)">
            <summary>
            Initializes or reinitializes this group (if it has been disposed) as a filtered group. 
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitor.Group.EnsureExceptionData">
            <summary>
            Gets or creates the <see cref="T:CK.Core.CKExceptionData"/> that captures exception information.
            If <see cref="P:Exception"/> is null, this returns null.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CK.Core.ActivityMonitor.Group.System#IDisposable#Dispose">
            <summary>
            Ensures that any groups opened after this one are closed before closing this one.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.Group.IsRejectedGroup">
            <summary>
            Gets whether the group is rejected: Depth is 0 when ActualFilter is Off or the GroupLevel 
            is None (the OpenGroup has been filtered).
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.Group.GroupTags">
            <summary>
            Gets the tags for the log group.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.Group.LogTime">
            <summary>
            Gets the log time for the log.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.Group.CloseLogTime">
            <summary>
            Gets the log time of the group closing.
            It is <see cref="F:CK.Core.DateTimeStamp.MinValue"/> when the group is not closed yet.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.Group.ExceptionData">
            <summary>
            Gets the <see cref="T:CK.Core.CKExceptionData"/> that captures exception information 
            if it exists. Returns null if no <see cref="P:Exception"/> exists.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.Group.Parent">
            <summary>
            Get the previous group in its origin monitor. Null if this group is a top level group.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.Group.Depth">
            <summary>
            Gets the depth of this group in its origin monitor (1 for top level groups).
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.Group.GroupLevel">
            <summary>
            Gets the level associated to this group.
            The <see cref="F:CK.Core.LogLevel.IsFiltered"/> can be set here: use <see cref="P:CK.Core.ActivityMonitor.Group.MaskedGroupLevel"/> to get 
            the actual level from <see cref="F:CK.Core.LogLevel.Trace"/> to <see cref="F:CK.Core.LogLevel.Fatal"/>.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.Group.MaskedGroupLevel">
            <summary>
            Gets the actual level (from <see cref="F:CK.Core.LogLevel.Trace"/> to <see cref="F:CK.Core.LogLevel.Fatal"/>) associated to this group
            without <see cref="F:CK.Core.LogLevel.IsFiltered"/> bit.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.Group.GroupText">
            <summary>
            Gets the text with which this group has been opened. Null if and only if the group is closed.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.Group.Exception">
            <summary>
            Gets the associated <see cref="P:CK.Core.ActivityMonitor.Group.Exception"/> if it exists.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.Group.SavedMonitorFilter">
            <summary>
            Gets or sets the <see cref="P:CK.Core.IActivityMonitor.MinimalFilter"/> that will be restored when group will be closed.
            Initialized with the current value of IActivityMonitor.Filter when the group has been opened.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.Group.SavedMonitorTags">
            <summary>
            Gets or sets the <see cref="P:CK.Core.IActivityMonitor.AutoTags"/> that will be restored when group will be closed.
            Initialized with the current value of IActivityMonitor.Tags when the group has been opened.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.Group.IsGroupTextTheExceptionMessage">
            <summary>
            Gets whether the <see cref="P:CK.Core.ActivityMonitor.Group.GroupText"/> is actually the <see cref="P:CK.Core.ActivityMonitor.Group.Exception"/> message.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.Group.PreviousTopic">
            <summary>
            Gets the previous topic it it must be restored. Null otherwise.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.Group.FileName">
            <summary>
            Gets the file name of the source code that issued the log.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitor.Group.LineNumber">
            <summary>
            Gets the line number of the <see cref="P:CK.Core.ActivityMonitor.Group.FileName"/> that issued the log.
            </summary>
        </member>
        <member name="T:CK.Core.ActivityMonitor.SourceFilter">
            <summary>
            Manages source filtering.
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitor.SourceFilter.FilterSource">
            <summary>
            Holds a <see cref="T:CK.Core.ActivityMonitor.SourceFilter.FilterSourceDelegate"/> that can override filter configuration and/or alter 
            source file name.
            It can be changed at any time and application is immediate. 
            It is set by default to <see cref="M:CK.Core.ActivityMonitor.SourceFilter.DefaultFilter(System.String@,System.Int32@)"/>.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitor.SourceFilter.ClearAll">
            <summary>
            Clears all existing filters.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitor.SourceFilter.ClearOverrides">
            <summary>
            Clears all existing Override filters.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitor.SourceFilter.ClearMinimals">
            <summary>
            Clears all existing Minimal filters.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitor.SourceFilter.Update(System.Func{System.String,CK.Core.SourceLogFilter,CK.Core.SourceLogFilter})">
            <summary>
            Updates (or simply scans) all existing filters.
            </summary>
            <param name="mapper">
            Function that takes the file name, the existing filter and maps it to a new filter.
            </param>
            <remarks>
            When the mapper returns <see cref="F:CK.Core.SourceLogFilter.Undefined"/>, the file configuration is removed.
            </remarks>
        </member>
        <member name="M:CK.Core.ActivityMonitor.SourceFilter.DefaultFilter(System.String@,System.Int32@)">
            <summary>
            Default filter, challenging file names added by <see cref="M:CK.Core.ActivityMonitor.SourceFilter.SetFilter(CK.Core.SourceLogFilter,System.String)"/> method.
            </summary>
            <param name="fileName">The file name.</param>
            <param name="lineNumber">The line number.</param>
            <returns>Defaults to <see cref="F:CK.Core.LogFilter.Undefined"/>.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitor.SourceFilter.SetFilter(CK.Core.SourceLogFilter,System.String)">
            <summary>
            Sets a <see cref="T:CK.Core.SourceLogFilter"/> for a given file. 
            Use <see cref="F:CK.Core.SourceLogFilter.Undefined"/> to clear any existing configuration for the file.
            </summary>
            <param name="filter">The filter to set for the file.</param>
            <param name="fileName">The file name: do not specify it to inject the path of your source file.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitor.SourceFilter.SetOverrideFilter(CK.Core.LogFilter,System.String)">
            <summary>
            Sets an override <see cref="T:CK.Core.LogFilter"/> for a given file: when not <see cref="F:CK.Core.LogFilter.Undefined"/> this 
            takes precedence over <see cref="P:CK.Core.IActivityMonitor.ActualFilter"/>.
            Use <see cref="F:CK.Core.LogFilter.Undefined"/> to clear it.
            </summary>
            <param name="overrideFilter">The override filter to set for the file.</param>
            <param name="fileName">The file name: do not specify it to inject the path of your source file.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitor.SourceFilter.SetMinimalFilter(CK.Core.LogFilter,System.String)">
            <summary>
            Sets a minimal <see cref="T:CK.Core.LogFilter"/> for a given file.
            Use <see cref="F:CK.Core.LogFilter.Undefined"/> to clear it.
            </summary>
            <param name="minimalFilter">The minimal filter to set for the file.</param>
            <param name="fileName">The file name: do not specify it to inject the path of your source file.</param>
        </member>
        <member name="T:CK.Core.ActivityMonitor.SourceFilter.FilterSourceDelegate">
            <summary>
            Delegate type that can be assigned to <see cref="F:CK.Core.ActivityMonitor.SourceFilter.FilterSource"/> static property to 
            enable filter override based on the caller source location. 
            </summary>
            <param name="fileName">FileName of the source file (that can be changed, typically by removing a common path prefix).</param>
            <param name="lineNumber">The line number in the source file.</param>
            <returns>The <see cref="T:CK.Core.SourceLogFilter"/> to apply. Must default to <see cref="F:CK.Core.LogFilter.Undefined"/>.</returns>
        </member>
        <member name="T:CK.Core.ActivityMonitorBridge">
            <summary>
            A <see cref="T:CK.Core.IActivityMonitorClient"/> that relays what happens in a monitor to another monitor.
            Automatically supports logs crossing Application Domains. See <see cref="T:CK.Core.ActivityMonitorBridgeTarget"/>.
            </summary>
        </member>
        <member name="T:CK.Core.IActivityMonitorBridgeCallback">
            <summary>
            Internal interface that allows ActivityMonitorBridgeTarget to call back
            the ActivityMonitorBridges that are bound to it.
            </summary>
        </member>
        <member name="M:CK.Core.IActivityMonitorBridgeCallback.OnTargetActualFilterChanged">
            <summary>
            Called when the target filter changed or is dirty. This can be called on any thread.
            </summary>
        </member>
        <member name="M:CK.Core.IActivityMonitorBridgeCallback.OnTargetAutoTagsChanged(System.String)">
            <summary>
            Called when the target AutoTags changed when IsCrossAppDomain is true.
            </summary>
        </member>
        <member name="M:CK.Core.IActivityMonitorBridgeCallback.OnTargetAutoTagsChanged(CK.Core.CKTrait)">
            <summary>
            Called when the target AutoTags changed when IsCrossAppDomain is false.
            </summary>
        </member>
        <member name="M:CK.Core.IActivityMonitorBridgeCallback.OnTargetTopicChanged(System.String,System.String,System.Int32)">
            <summary>
            Called when the target Topic changed.
            </summary>
        </member>
        <member name="P:CK.Core.IActivityMonitorBridgeCallback.IsCrossAppDomain">
            <summary>
            Gets whether the bridge is in another Application Domain.
            </summary>
        </member>
        <member name="P:CK.Core.IActivityMonitorBridgeCallback.PullTopicAndAutoTagsFromTarget">
            <summary>
            Gets whether this bridge updates the Topic and AutoTags of its monitor whenever they change on the target monitor.
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitorBridge.TagBridgePrematureClose">
            <summary>
            Tags group conclusions emitted because of premature (unbalanced) removing of a bridge from a source monitor.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorBridge.#ctor(CK.Core.ActivityMonitorBridgeTarget,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Initialize a new <see cref="T:CK.Core.ActivityMonitorBridge"/> bound to an existing <see cref="T:CK.Core.ActivityMonitorBridgeTarget"/>
            that can live in another AppDomain.
            This Client should be registered in the <see cref="P:CK.Core.IActivityMonitor.Output"/> of a local monitor.
            </summary>
            <param name="bridge">The bridge to another AppDomain.</param>
            <param name="pullTargetTopicAndAutoTagsFromTarget">
            When true, the <see cref="P:CK.Core.IActivityMonitor.Topic"/> and <see cref="P:CK.Core.IActivityMonitor.AutoTags"/> are automaticaly updated whenever they change on the target monitor.
            </param>
            <param name="pushTopicAndAutoTagsToTarget">
            When true, any change to <see cref="P:CK.Core.IActivityMonitor.Topic"/> or <see cref="P:CK.Core.IActivityMonitor.AutoTags"/> are applied to the target monitor.
            </param>
            <param name="applyTargetFilterToUnfilteredLogs">
            True to avoid sending logs with level below the target <see cref="P:CK.Core.IActivityMonitor.MinimalFilter"/> (when <see cref="P:CK.Core.ActivityMonitorBridgeTarget.HonorMonitorFilter"/> is true
            and it is an unfiltered line or group log).
            This is an optimization that can be used to send less data to the target monitor but breaks the UnfilteredLog/UnfilteredOpenGroup contract.
            </param>
        </member>
        <member name="M:CK.Core.ActivityMonitorBridge.CK#Core#IActivityMonitorBoundClient#SetMonitor(CK.Core.Impl.IActivityMonitorImpl,System.Boolean)">
            <summary>
            forceBuggyRemove is not used here since this client is not lockable.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorBridge.GetActualTargetFilter">
            <summary>
            This is necessarily called in the context of the activity: we can call the bridge that can call 
            the Monitor's ActualFilter that will be resynchronized if needed.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorBridge.TargetMonitor">
            <summary>
            Gets the target monitor if it is in the same Application Domain. 
            Null otherwise: use <see cref="P:CK.Core.ActivityMonitorBridge.BridgeTarget"/> to always have a reference to the target.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorBridge.IsCrossAppDomain">
            <summary>
            Gets whether the target monitor is in the same application domain or not.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorBridge.BridgeTarget">
            <summary>
            Gets the target bridge. This is never null, even when this bridge is not in the same application domain as the <see cref="P:CK.Core.ActivityMonitorBridge.TargetMonitor"/>.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorBridge.PullTopicAndAutoTagsFromTarget">
            <summary>
            Gets whether this bridge updates the Topic and AutoTags of its monitor whenever they change on the target monitor.
            </summary>
        </member>
        <member name="T:CK.Core.ActivityMonitorBridgeTarget">
            <summary>
            This class (a <see cref="T:System.MarshalByRefObject"/>), used with <see cref="T:CK.Core.ActivityMonitorBridge"/>, enables <see cref="T:CK.Core.IActivityMonitor"/> to be used across Application Domains.
            It can also be used to relay logs inside the same application domain.
            Each activity monitor exposes such a bridge target on its output thanks to <see cref="P:CK.Core.IActivityMonitorOutput.BridgeTarget"/>.
            </summary>
            <remarks>
            <para>
            This ActivityMonitorBridgeTarget is created in the original <see cref="T:System.AppDomain"/> and bound to the final activity monitor (the target) - this is the job of any IActivityMonitorOutput
            implementation to offer a BridgeTarget property.
            </para>
            <para>
            The ActivityMonitorBridge (that is a <see cref="T:CK.Core.IActivityMonitorClient"/>) can be created in remote AppDomain (and registered 
            in the <see cref="P:CK.Core.IActivityMonitor.Output"/> of a monitor in the remote AppDomain) bound to the ActivityMonitorBridgeTarget (one can use <see cref="M:System.AppDomain.SetData(System.String,System.Object)"/> to 
            transfer the ActivityMonitorBridgeTarget to the other AppDomain for instance).
            </para>
            </remarks>
        </member>
        <member name="M:CK.Core.ActivityMonitorBridgeTarget.#ctor(CK.Core.Impl.IActivityMonitorImpl,System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.ActivityMonitorBridgeTarget"/> bound to a <see cref="T:CK.Core.IActivityMonitor"/>.
            This object should be transfered to another AppDomain and a <see cref="T:CK.Core.ActivityMonitorBridge"/> 
            should be bound to it.
            </summary>
            <param name="targetMonitor">Monitor that will receive the logs.</param>
            <param name="honorMonitorFilter">
            False to ignore the actual filter <see cref="P:CK.Core.IActivityMonitor.ActualFilter"/> value: logs coming from the bridge (ie. the remote Application Domain)
            will always be added to this target monitor.
            </param>
        </member>
        <member name="M:CK.Core.ActivityMonitorBridgeTarget.AddCallback(CK.Core.IActivityMonitorBridgeCallback)">
            <summary>
            Called by ActivityMonitorBridge.SetMonitor (the reentrant check is acquired).
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorBridgeTarget.RemoveCallback(CK.Core.IActivityMonitorBridgeCallback)">
            <summary>
            Called by ActivityMonitorBridge.SetMonitor (the reentrant check is acquired).
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorBridgeTarget.TargetActualFilterChanged">
            <summary>
            This is called when HonorMonitorFilter changes or by ActivityMonitor.UpdateActualFilter 
            whenever the monitors's ActualFilter changed (in such cases, we are bound to the activity: the Reentrancy and concurrency 
            lock has been obtained), or by our monitor's SetClientMinimalFilterDirty() method (in this case, we are called on 
            any thread).
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorBridgeTarget.InitializeLifetimeService">
            <summary>
            Gets the lease for this object.
            </summary>
            <returns>The lease.</returns>
        </member>
        <member name="P:CK.Core.ActivityMonitorBridgeTarget.HonorMonitorFilter">
            <summary>
            Gets or sets whether the <see cref="P:CK.Core.IActivityMonitor.ActualFilter"/> of the target monitor should be honored or not.
            Defaults to true.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorBridgeTarget.TargetMonitor">
            <summary>
            Gets the target monitor directly when used in the same AppDomain.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorBridgeTarget.TargetFinalFilterCrossAppDomain">
            <summary>
            Gets the target final filter that must be used: this property takes into account the monitor's filter and the ActivityMonitor.DefaultFilter application domain 
            value if HonorMonitorFilter is true (otherwise it is <see cref="F:CK.Core.LogFilter.Undefined"/>).
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorBridgeTarget.TargetFinalFilter">
            <summary>
            Gets the target final filter that must be used without taking into account the ActivityMonitor.DefaultFilter application domain value.
            </summary>
        </member>
        <member name="T:CK.Core.ActivityMonitorExtension">
            <summary>
            Provides OpenXXX and XXX (Trace, Info,...Fatal) extension methods for <see cref="T:CK.Core.IActivityMonitor"/>.
            </summary>
            <summary>
            Provides extension methods for <see cref="T:CK.Core.IActivityMonitor"/> and other types from the Activity monitor framework.
            </summary>
            <summary>
            Provides extension methods for <see cref="T:CK.Core.IActivityMonitor"/> and other types from the Activity monitor framework.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.Trace(CK.Core.IActivityMonitor,System.Int32,System.String)">
            <summary>
            Filters <see cref="F:CK.Core.LogLevel.Trace"/> logs. FileName end LineNumber may be also used to determine whether
            the log should eventually be emitted.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/>.</param>
            <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
            <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
            <returns>A <see cref="T:CK.Core.ActivityMonitorLineSender"/> or null if the log must not be emitted.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.OpenTrace(CK.Core.IActivityMonitor,System.Int32,System.String)">
            <summary>
            Filtered <see cref="F:CK.Core.LogLevel.Trace"/> group opening. FileName end LineNumber may be also used to determine whether
            the log should eventually be emitted.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/>.</param>
            <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
            <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
            <returns>A <see cref="T:CK.Core.ActivityMonitorGroupSender"/> or null if the group must not be emitted.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.Info(CK.Core.IActivityMonitor,System.Int32,System.String)">
            <summary>
            Filters <see cref="F:CK.Core.LogLevel.Info"/> logs. FileName end LineNumber may be also used to determine whether
            the log should eventually be emitted.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/>.</param>
            <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
            <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
            <returns>A <see cref="T:CK.Core.ActivityMonitorLineSender"/> or null if the log must not be emitted.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.OpenInfo(CK.Core.IActivityMonitor,System.Int32,System.String)">
            <summary>
            Filtered <see cref="F:CK.Core.LogLevel.Info"/> group opening. FileName end LineNumber may be also used to determine whether
            the log should eventually be emitted.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/>.</param>
            <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
            <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
            <returns>A <see cref="T:CK.Core.ActivityMonitorGroupSender"/> or null if the group must not be emitted.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.Warn(CK.Core.IActivityMonitor,System.Int32,System.String)">
            <summary>
            Filters <see cref="F:CK.Core.LogLevel.Warn"/> logs. FileName end LineNumber may be also used to determine whether
            the log should eventually be emitted.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/>.</param>
            <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
            <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
            <returns>A <see cref="T:CK.Core.ActivityMonitorLineSender"/> or null if the log must not be emitted.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.OpenWarn(CK.Core.IActivityMonitor,System.Int32,System.String)">
            <summary>
            Filtered <see cref="F:CK.Core.LogLevel.Warn"/> group opening. FileName end LineNumber may be also used to determine whether
            the log should eventually be emitted.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/>.</param>
            <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
            <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
            <returns>A <see cref="T:CK.Core.ActivityMonitorGroupSender"/> or null if the group must not be emitted.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.Error(CK.Core.IActivityMonitor,System.Int32,System.String)">
            <summary>
            Filters <see cref="F:CK.Core.LogLevel.Error"/> logs. FileName end LineNumber may be also used to determine whether
            the log should eventually be emitted.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/>.</param>
            <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
            <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
            <returns>A <see cref="T:CK.Core.ActivityMonitorLineSender"/> or null if the log must not be emitted.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.OpenError(CK.Core.IActivityMonitor,System.Int32,System.String)">
            <summary>
            Filtered <see cref="F:CK.Core.LogLevel.Error"/> group opening. FileName end LineNumber may be also used to determine whether
            the log should eventually be emitted.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/>.</param>
            <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
            <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
            <returns>A <see cref="T:CK.Core.ActivityMonitorGroupSender"/> or null if the group must not be emitted.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.Fatal(CK.Core.IActivityMonitor,System.Int32,System.String)">
            <summary>
            Filters <see cref="F:CK.Core.LogLevel.Fatal"/> logs. FileName end LineNumber may be also used to determine whether
            the log should eventually be emitted.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/>.</param>
            <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
            <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
            <returns>A <see cref="T:CK.Core.ActivityMonitorLineSender"/> or null if the log must not be emitted.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.OpenFatal(CK.Core.IActivityMonitor,System.Int32,System.String)">
            <summary>
            Filtered <see cref="F:CK.Core.LogLevel.Fatal"/> group opening. FileName end LineNumber may be also used to determine whether
            the log should eventually be emitted.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/>.</param>
            <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
            <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
            <returns>A <see cref="T:CK.Core.ActivityMonitorGroupSender"/> or null if the group must not be emitted.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.NextLogTime(CK.Core.IActivityMonitor)">
            <summary>
            Returns a valid <see cref="T:CK.Core.DateTimeStamp"/> that will be used for a log: it is based on <see cref="P:System.DateTime.UtcNow"/> and has 
            a <see cref="F:CK.Core.DateTimeStamp.Uniquifier"/> that will not be changed when emitting the next log.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/>.</param>
            <returns>The next log time for the monitor.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.ShouldLogLine(CK.Core.IActivityMonitor,CK.Core.LogLevel,System.String,System.Int32)">
            <summary>
            Challenges source filters based on FileName/LineNumber, <see cref="P:CK.Core.IActivityMonitor.ActualFilter">this monitors' actual filter</see> and application 
            domain's <see cref="P:CK.Core.ActivityMonitor.DefaultFilter"/> filters to test whether a log line should actually be emitted.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/>.</param>
            <param name="level">Log level.</param>
            <param name="fileName">Source file name of the emitter (automatically injected by C# compiler but can be explicitly set).</param>
            <param name="lineNumber">Line number in the source file (automatically injected by C# compiler but can be explicitly set).</param>
            <returns>True if the log should be emitted.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.ShouldLogGroup(CK.Core.IActivityMonitor,CK.Core.LogLevel,System.String,System.Int32)">
            <summary>
            Challenges source filters based on FileName/LineNumber, <see cref="P:CK.Core.IActivityMonitor.ActualFilter">this monitor's actual filter</see> and application 
            domain's <see cref="P:CK.Core.ActivityMonitor.DefaultFilter"/> filters to test whether a log group should actually be emitted.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/>.</param>
            <param name="level">Log level.</param>
            <param name="fileName">Source file name of the emitter (automatically injected by C# compiler but can be explicitly set).</param>
            <param name="lineNumber">Line number in the source file (automatically injected by C# compiler but can be explicitly set).</param>
            <returns>True if the log should be emitted.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.FilterLogLine(CK.Core.IActivityMonitor,CK.Core.LogLevel,System.String,System.Int32)">
            <summary>
            Private method used by XXX (Trace, Info,..., Fatal) extension methods.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.FilteredGroup(CK.Core.IActivityMonitor,CK.Core.LogLevel,System.String,System.Int32)">
            <summary>
            Private method used by OpenXXX (Trace, Info,..., Fatal) extension methods.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.UnfilteredLog(CK.Core.IActivityMonitor,CK.Core.CKTrait,CK.Core.LogLevel,System.String,CK.Core.DateTimeStamp,System.Exception,System.String,System.Int32)">
            <summary>
            Logs a text regardless of <see cref="P:CK.Core.IActivityMonitor.ActualFilter">ActualFilter</see> level. 
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/>.</param>
            <param name="tags">
            Tags (from <see cref="T:CK.Core.ActivityMonitor.Tags"/>) to associate to the log. 
            These tags will be union-ed with the current <see cref="P:CK.Core.IActivityMonitor.AutoTags">AutoTags</see>.
            </param>
            <param name="level">Log level. Must not be <see cref="F:CK.Core.LogLevel.None"/>.</param>
            <param name="text">Text to log. Must not be null or empty.</param>
            <param name="logTime">
            Time-stamp of the log entry.
            You can use <see cref="P:CK.Core.DateTimeStamp.UtcNow"/> or <see cref="M:CK.Core.ActivityMonitorExtension.NextLogTime(CK.Core.IActivityMonitor)">IActivityMonitor.NextLogTime()</see> extension method.
            </param>
            <param name="ex">Optional exception associated to the log. When not null, a Group is automatically created.</param>
            <param name="fileName">The source code file name from which the log is emitted.</param>
            <param name="lineNumber">The line number in the source from which the log is emitted.</param>
            <remarks>
            The <paramref name="text"/> can not be null or empty.
            <para>
            Each call to log is considered as a unit of text: depending on the rendering engine, a line or a 
            paragraph separator (or any appropriate separator) should be appended between each text if 
            the <paramref name="level"/> is the same as the previous one.
            </para>
            <para>If needed, the special text <see cref="F:CK.Core.ActivityMonitor.ParkLevel"/> ("PARK-LEVEL") can be used as a convention 
            to break the current <see cref="T:CK.Core.LogLevel"/> and resets it: the next log, even with the same LogLevel, should be 
            treated as if a different LogLevel is used.
            </para>
            </remarks>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.UnfilteredOpenGroup(CK.Core.IActivityMonitor,CK.Core.CKTrait,CK.Core.LogLevel,System.Func{System.String},System.String,CK.Core.DateTimeStamp,System.Exception,System.String,System.Int32)">
            <summary>
            Opens a group regardless of <see cref="P:CK.Core.IActivityMonitor.ActualFilter">ActualFilter</see> level. 
            <see cref="M:CK.Core.ActivityMonitorExtension.CloseGroup(CK.Core.IActivityMonitor,System.Object)"/> must be called in order to close the group, and/or the returned object must be disposed (both safely can be called: 
            the group is closed on the first action, the second one is ignored).
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/>.</param>
            <param name="tags">Tags (from <see cref="T:CK.Core.ActivityMonitor.Tags"/>) to associate to the log. It will be union-ed with current <see cref="P:CK.Core.IActivityMonitor.AutoTags">AutoTags</see>.</param>
            <param name="level">Log level. The <see cref="F:CK.Core.LogLevel.None"/> level is used to open a filtered group. See remarks.</param>
            <param name="getConclusionText">Optional function that will be called on group closing.</param>
            <param name="text">Text to log (the title of the group). Null text is valid and considered as <see cref="F:System.String.Empty"/> or assigned to the <see cref="P:System.Exception.Message"/> if it exists.</param>
            <param name="logTime">
            Time of the log entry.
            You can use <see cref="P:CK.Core.DateTimeStamp.UtcNow"/> or <see cref="M:CK.Core.ActivityMonitorExtension.NextLogTime(CK.Core.IActivityMonitor)">IActivityMonitor.NextLogTime()</see> extension method.
            </param>
            <param name="ex">Optional exception associated to the group.</param>
            <param name="fileName">The source code file name from which the group is opened.</param>
            <param name="lineNumber">The line number in the source from which the group is opened.</param>
            <returns>A disposable object that can be used to close the group.</returns>
            <remarks>
            <para>
            Opening a group does not change the current <see cref="P:CK.Core.IActivityMonitor.MinimalFilter">MinimalFilter</see>, except when 
            opening a <see cref="F:CK.Core.LogLevel.Fatal"/> or <see cref="F:CK.Core.LogLevel.Error"/> group: in such case, the Filter is automatically 
            sets to <see cref="F:CK.Core.LogFilter.Debug"/> to capture all potential information inside the error group.
            </para>
            <para>
            Changes to the monitor's current Filter or AutoTags that occur inside a group are automatically restored to their original values when the group is closed.
            This behavior guaranties that a local modification (deep inside unknown called code) does not impact caller code: groups are a way to easily isolate such 
            configuration changes.
            </para>
            <para>
            Note that this automatic configuration restoration works even if the group is filtered (when the <paramref name="level"/> is None).
            </para>
            </remarks>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.CloseGroup(CK.Core.IActivityMonitor,System.Object)">
            <summary>
            Closes the current Group. Optional parameter is polymorphic. It can be a string, a <see cref="T:CK.Core.ActivityLogGroupConclusion"/>, 
            a <see cref="T:System.Collections.Generic.List`1"/> or an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of ActivityLogGroupConclusion, or any object with an overridden <see cref="M:System.Object.ToString"/> method. 
            See remarks (especially for List&lt;ActivityLogGroupConclusion&gt;).
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/>.</param>
            <param name="userConclusion">Optional string, ActivityLogGroupConclusion object, enumerable of ActivityLogGroupConclusion or object to conclude the group. See remarks.</param>
            <remarks>
            An untyped object is used here to easily and efficiently accommodate both string and already existing ActivityLogGroupConclusion.
            When a List&lt;ActivityLogGroupConclusion&gt; is used, it will be directly used to collect conclusion objects (new conclusions will be added to it). This is an optimization.
            </remarks>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.FindBridgeTo(CK.Core.IActivityMonitorOutput,CK.Core.ActivityMonitorBridgeTarget)">
            <summary>
            Finds an existing bridge to another monitor.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorOutput"/>.</param>
            <param name="targetBridge">The target bridge that receives our logs.</param>
            <returns>The existing <see cref="T:CK.Core.ActivityMonitorBridge"/> or null if no such bridge exists.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.CreateBridgeTo(CK.Core.IActivityMonitorOutput,CK.Core.ActivityMonitorBridgeTarget)">
            <summary>
            Creates a bridge to another monitor's <see cref="T:CK.Core.ActivityMonitorBridgeTarget"/>. Only one bridge to the same monitor can exist at a time: if <see cref="M:CK.Core.ActivityMonitorExtension.FindBridgeTo(CK.Core.IActivityMonitorOutput,CK.Core.ActivityMonitorBridgeTarget)"/> is not null, 
            this throws a <see cref="T:System.InvalidOperationException"/>.
            This bridge does not synchronize <see cref="P:CK.Core.IActivityMonitor.AutoTags"/> and <see cref="P:CK.Core.IActivityMonitor.Topic"/> (see <see cref="M:CK.Core.ActivityMonitorExtension.CreateStrongBridgeTo(CK.Core.IActivityMonitorOutput,CK.Core.ActivityMonitorBridgeTarget)"/>). 
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorOutput"/>.</param>
            <param name="targetBridge">The target bridge that will receive our logs.</param>
            <returns>A <see cref="T:System.IDisposable"/> object that can be disposed to automatically call <see cref="M:CK.Core.ActivityMonitorExtension.UnbridgeTo(CK.Core.IActivityMonitorOutput,CK.Core.ActivityMonitorBridgeTarget)"/>.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.CreateStrongBridgeTo(CK.Core.IActivityMonitorOutput,CK.Core.ActivityMonitorBridgeTarget)">
            <summary>
            Creates a strong bridge to another monitor's <see cref="T:CK.Core.ActivityMonitorBridgeTarget"/>. 
            Only one bridge to the same monitor can exist at a time: if <see cref="M:CK.Core.ActivityMonitorExtension.FindBridgeTo(CK.Core.IActivityMonitorOutput,CK.Core.ActivityMonitorBridgeTarget)"/> is not null, 
            this throws a <see cref="T:System.InvalidOperationException"/>.
            A strong bridge synchronizes <see cref="P:CK.Core.IActivityMonitor.AutoTags"/> and <see cref="P:CK.Core.IActivityMonitor.Topic"/> between the two monitors. When created, the 2 properties
            of the local monitor are set to the ones of the target monitor. 
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorOutput"/>.</param>
            <param name="targetBridge">The target bridge that will receive our logs.</param>
            <returns>A <see cref="T:System.IDisposable"/> object that can be disposed to automatically call <see cref="M:CK.Core.ActivityMonitorExtension.UnbridgeTo(CK.Core.IActivityMonitorOutput,CK.Core.ActivityMonitorBridgeTarget)"/>.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.UnbridgeTo(CK.Core.IActivityMonitorOutput,CK.Core.ActivityMonitorBridgeTarget)">
            <summary>
            Removes an existing <see cref="T:CK.Core.ActivityMonitorBridge"/> to another monitor if it exists (silently ignores it if not found).
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorOutput"/>.</param>
            <param name="targetBridge">The target bridge that will no more receive our logs.</param>
            <returns>The unregistered <see cref="T:CK.Core.ActivityMonitorBridge"/> if found, null otherwise.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.Catch(CK.Core.IActivityMonitor,System.Action{System.Collections.Generic.IReadOnlyList{CK.Core.ActivityMonitorSimpleCollector.Entry}},CK.Core.LogLevelFilter)">
            <summary>
            Enables simple "using" syntax to easily catch any <see cref="T:CK.Core.LogLevel"/> (or above) entries (defaults to <see cref="F:CK.Core.LogLevel.Error"/>).
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/>.</param>
            <param name="errorHandler">An action that accepts a list of fatal or error <see cref="T:CK.Core.ActivityMonitorSimpleCollector.Entry">entries</see>.</param>
            <param name="level">Defines the level of the entries caught (by default fatal or error entries).</param>
            <returns>A <see cref="T:System.IDisposable"/> object used to manage the scope of this handler.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.CatchCounter(CK.Core.IActivityMonitor,System.Action{System.Int32,System.Int32,System.Int32})">
            <summary>
            Enables simple "using" syntax to easily detect <see cref="F:CK.Core.LogLevel.Fatal"/>, <see cref="F:CK.Core.LogLevel.Error"/> or <see cref="F:CK.Core.LogLevel.Warn"/>.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/>.</param>
            <param name="fatalErrorWarnCount">An action that accepts three counts for fatals, errors and warnings.</param>
            <returns>A <see cref="T:System.IDisposable"/> object used to manage the scope of this handler.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.CatchCounter(CK.Core.IActivityMonitor,System.Action{System.Int32,System.Int32})">
            <summary>
            Enables simple "using" syntax to easily detect <see cref="F:CK.Core.LogLevel.Fatal"/> and <see cref="F:CK.Core.LogLevel.Error"/>.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/>.</param>
            <param name="fatalErrorCount">An action that accepts two counts for fatals and errors.</param>
            <returns>A <see cref="T:System.IDisposable"/> object used to manage the scope of this handler.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.CatchCounter(CK.Core.IActivityMonitor,System.Action{System.Int32})">
            <summary>
            Enables simple "using" syntax to easily detect <see cref="F:CK.Core.LogLevel.Fatal"/> or <see cref="F:CK.Core.LogLevel.Error"/>.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/>.</param>
            <param name="fatalOrErrorCount">An action that accepts one count that sums fatals and errors.</param>
            <returns>A <see cref="T:System.IDisposable"/> object used to manage the scope of this handler.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.SetMinimalFilter(CK.Core.IActivityMonitor,CK.Core.LogLevelFilter,CK.Core.LogLevelFilter)">
            <summary>
            Sets filter levels on this <see cref="T:CK.Core.IActivityMonitor"/>. The current <see cref="P:CK.Core.IActivityMonitor.MinimalFilter"/> will be automatically 
            restored when the returned <see cref="T:System.IDisposable"/> will be disposed.
            Even if when a Group is closed, the IActivityMonitor.Filter is automatically restored to its original value 
            (captured when the Group was opened), this may be useful to locally change the filter level without bothering to restore the 
            initial value (this is what OpenGroup/CloseGroup do with both the Filter and the AutoTags).
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/> object.</param>
            <param name="group">The new filter level for group.</param>
            <param name="line">The new filter level for log line.</param>
            <returns>A <see cref="T:System.IDisposable"/> object that will restore the current level.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.SetMinimalFilter(CK.Core.IActivityMonitor,CK.Core.LogFilter)">
            <summary>
            Sets a filter level on this <see cref="T:CK.Core.IActivityMonitor"/>. The current <see cref="P:CK.Core.IActivityMonitor.MinimalFilter"/> will be automatically 
            restored when the returned <see cref="T:System.IDisposable"/> will be disposed.
            Even if when a Group is closed, the IActivityMonitor.Filter is automatically restored to its original value 
            (captured when the Group was opened), this may be useful to locally change the filter level without bothering to restore the 
            initial value (this is what OpenGroup/CloseGroup do with both the Filter and the AutoTags).
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/> object.</param>
            <param name="f">The new filter.</param>
            <returns>A <see cref="T:System.IDisposable"/> object that will restore the current level.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.SetAutoTags(CK.Core.IActivityMonitor,CK.Core.CKTrait,CK.Core.SetOperation)">
            <summary>
            Alter tags of this <see cref="T:CK.Core.IActivityMonitor"/>. Current <see cref="P:CK.Core.IActivityMonitor.AutoTags"/> will be automatically 
            restored when the returned <see cref="T:System.IDisposable"/> will be disposed.
            Even if when a Group is closed, the IActivityMonitor.AutoTags is automatically restored to its original value 
            (captured when the Group was opened), this may be useful to locally change the tags level without bothering to restore the 
            initial value (this is close to what OpenGroup/CloseGroup do with both the Filter and the AutoTags).
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/> object.</param>
            <param name="tags">Tags to combine with the current one.</param>
            <param name="operation">Defines the way the new <paramref name="tags"/> must be combined with current ones.</param>
            <returns>A <see cref="T:System.IDisposable"/> object that will restore the current tag when disposed.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.RegisterClient(CK.Core.IActivityMonitorOutput,CK.Core.IActivityMonitorClient)">
            <summary>
            Registers an <see cref="T:CK.Core.IActivityMonitorClient"/> to the <see cref="P:CK.Core.IActivityMonitorOutput.Clients">Clients</see> list.
            Duplicates IActivityMonitorClient are silently ignored.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorOutput"/> object.</param>
            <param name="client">An <see cref="T:CK.Core.IActivityMonitorClient"/> implementation.</param>
            <returns>The registered client.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.RegisterClient``1(CK.Core.IActivityMonitorOutput,``0)">
            <summary>
            Registers a typed <see cref="T:CK.Core.IActivityMonitorClient"/>.
            </summary>
            <typeparam name="T">Any type that specializes <see cref="T:CK.Core.IActivityMonitorClient"/>.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorOutput"/> object.</param>
            <param name="client">Client to register.</param>
            <returns>The registered client.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.RegisterClients(CK.Core.IActivityMonitorOutput,System.Collections.Generic.IEnumerable{CK.Core.IActivityMonitorClient})">
            <summary>
            Registers multiple <see cref="T:CK.Core.IActivityMonitorClient"/>.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorOutput"/> object.</param>
            <param name="clients">Multiple clients to register.</param>
            <returns>This registrar to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.RegisterClients(CK.Core.IActivityMonitorOutput,CK.Core.IActivityMonitorClient[])">
            <summary>
            Registers multiple <see cref="T:CK.Core.IActivityMonitorClient"/>.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorOutput"/> object.</param>
            <param name="clients">Multiple clients to register.</param>
            <returns>This registrar to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.RegisterUniqueClient``1(CK.Core.IActivityMonitorOutput)">
            <summary>
            Registers a unique client for a type that must have a public default constructor. 
            <see cref="M:System.Activator.CreateInstance``1"/> is called if necessary.
            </summary>
            <returns>The found or newly created client.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.UnregisterClient``1(CK.Core.IActivityMonitorOutput,System.Func{``0,System.Boolean})">
            <summary>
            Unregisters the first <see cref="T:CK.Core.IActivityMonitorClient"/> from the <see cref="P:CK.Core.IActivityMonitorOutput.Clients"/> list
            that satisfies the predicate.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorOutput"/>.</param>
            <param name="predicate">A predicate that will be used to determine the first client to unregister.</param>
            <returns>The unregistered client, or null if no client has been found.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.ToStringGroupConclusion(System.Collections.Generic.IEnumerable{CK.Core.ActivityLogGroupConclusion},System.String)">
            <summary>
            Gets this Group conclusions as a readable string.
            </summary>
            <param name="this">This group conclusion. Can be null.</param>
            <param name="conclusionSeparator">Conclusion separator.</param>
            <returns>A lovely concatenated string of conclusions.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.ToStringPath(System.Collections.Generic.IEnumerable{CK.Core.ActivityMonitorPathCatcher.PathElement},System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Gets the path as a readable string.
            </summary>
            <param name="this">This path. Can be null.</param>
            <param name="elementSeparator">Between elements.</param>
            <param name="withoutConclusionFormat">There must be 3 placeholders {0} for the level, {1} for the text and {2} for the conclusion.</param>
            <param name="withConclusionFormat">There must be 2 placeholders {0} for the level and {1} for the text.</param>
            <param name="conclusionSeparator">Conclusion separator.</param>
            <param name="fatal">For Fatal errors.</param>
            <param name="error">For Errors.</param>
            <param name="warn">For Warnings.</param>
            <param name="info">For Infos.</param>
            <param name="trace">For Traces.</param>
            <returns>A lovely path.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.DependentActivity(CK.Core.IActivityMonitor,System.String,System.Int32)">
            <summary>
            Enables dependent activities token creation and activities launch.
            Use <see cref="M:CK.Core.ActivityMonitorExtension.StartDependentActivity(CK.Core.IActivityMonitor,CK.Core.ActivityMonitor.DependentToken,System.String,System.Int32)">IActivityMonitor.StartDependentActivity</see> to declare the start of a 
            dependent activity on the target monitor.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/>.</param>
            <param name="fileName">Source file name of the emitter (automatically injected by C# compiler but can be explicitly set).</param>
            <param name="lineNumber">Line number in the source file (automatically injected by C# compiler but can be explicitly set).</param>
            <returns>Sender object.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.StartDependentActivity(CK.Core.IActivityMonitor,CK.Core.ActivityMonitor.DependentToken,System.String,System.Int32)">
            <summary>
            Starts a dependent activity. This sets the <see cref="P:CK.Core.ActivityMonitor.DependentToken.Topic"/> if it is not null and opens a group
            tagged with <see cref="F:CK.Core.ActivityMonitor.Tags.StartDependentActivity"/> with a message that can be parsed back thanks to <see cref="M:CK.Core.ActivityMonitor.DependentToken.TryParseStartMessage(System.String,System.Guid@,CK.Core.DateTimeStamp@)"/>.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitor"/>.</param>
            <param name="token">Token that describes the origin of the activity.</param>
            <param name="fileName">Source file name of the emitter (automatically injected by C# compiler but can be explicitly set).</param>
            <param name="lineNumber">Line number in the source file (automatically injected by C# compiler but can be explicitly set).</param>
            <returns>A disposable object. It must be disposed at the end of the activity.</returns>
        </member>
        <member name="T:CK.Core.ActivityMonitorExtension.DependentSender">
            <summary>
            Offers dependent token creation and launching.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.DependentSender.CreateToken(System.Boolean)">
            <summary>
            Creates a token for a dependent activity that will use the current monitor's topic.
            By default, a line with <see cref="F:CK.Core.ActivityMonitor.Tags.CreateDependentActivity"/> is logged that describes the 
            creation of the token.
            If <paramref name="delayedLaunch"/> is true, the actual launch of the dependent activity must be signaled thanks to <see cref="M:CK.Core.ActivityMonitorExtension.DependentSender.Launch(CK.Core.ActivityMonitor.DependentToken)"/>
            (otherwise there will be no way to bind the two activities). 
            </summary>
            <param name="delayedLaunch">True to use <see cref="M:CK.Core.ActivityMonitorExtension.DependentSender.Launch(CK.Core.ActivityMonitor.DependentToken)"/> later to indicate the actual launch of the dependent activity.</param>
            <returns>A dependent token.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.DependentSender.CreateTokenWithTopic(System.String,System.Boolean)">
            <summary>
            Creates a token for a dependent activity that will be bound to a specified topic (or that will not change the dependent monitor's topic
            if null is specified).
            </summary>
            <param name="dependentTopic">Topic for the dependent activity. Use null to not change the dependent monitor's topic.</param>
            <param name="delayedLaunch">True to use <see cref="M:CK.Core.ActivityMonitorExtension.DependentSender.Launch(CK.Core.ActivityMonitor.DependentToken)"/> later to indicate the actual launch of the dependent activity.</param>
            <returns>A dependent token.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.DependentSender.Launch(CK.Core.ActivityMonitor.DependentToken)">
            <summary>
            Signals the launch of one or more dependent activities by emitting a log line that describes the token.
            The token must have been created by <see cref="M:CK.Core.ActivityMonitorExtension.DependentSender.CreateToken(System.Boolean)"/> or <see cref="M:CK.Core.ActivityMonitorExtension.DependentSender.CreateTokenWithTopic(System.String,System.Boolean)"/> with a true delayedLaunch parameter
            otherwise an <see cref="T:System.InvalidOperationException"/> is thrown.
            </summary>
            <param name="token">Dependent token.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.DependentSender.Launch(System.Action{CK.Core.ActivityMonitor.DependentToken})">
            <summary>
            Launches one or more dependent activities (thanks to a delegate) that will use the current monitor's topic.
            This creates a new <see cref="T:CK.Core.ActivityMonitor.DependentToken"/> and opens a group that wraps the execution of the <paramref name="dependentLauncher"/>.
            </summary>
            <param name="dependentLauncher">Must create and launch dependent activities that should use the created token.</param>
            <returns>A dependent token.</returns>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.DependentSender.LaunchWithTopic(System.Action{CK.Core.ActivityMonitor.DependentToken},System.String)">
            <summary>
            Launches one or more dependent activities (thanks to a delegate) that will be bound to a specified topic (or that will not change 
            the dependent monitor's topic if null is specified).
            This creates a new <see cref="T:CK.Core.ActivityMonitor.DependentToken"/> and opens a group that wraps the execution of the <paramref name="dependentLauncher"/>.
            </summary>
            <param name="dependentLauncher">Must create and launch dependent activities that should use the created token.</param>
            <param name="dependentTopic">Topic for the dependent activity. When null, the dependent monitor's topic is not changed.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorExtension.DependentSender.StartDependentActivity(CK.Core.ActivityMonitor.DependentToken)">
            <summary>
            
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="T:CK.Core.ActivityMonitorSendExtension">
            <summary>
            Provides Send extension methods for <see cref="T:CK.Core.IActivityMonitorGroupSender"/>.
            </summary>
            <summary>
            Provides Send extension methods for <see cref="T:CK.Core.IActivityMonitorLineSender"/> and <see cref="T:CK.Core.ActivityMonitorGroupSender"/>.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.String)">
            <summary>
            Sends a text.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="text">The text of the log.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.String,System.Object)">
            <summary>
            Sends a formatted text.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="format">The text format of the log with 1 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.String,System.Object,System.Object)">
            <summary>
            Sends a formatted text.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="format">The text format of the log with 2 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <param name="arg1">Parameter to format (placeholder {1}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Sends a formatted text.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="format">The text format of the log with 3 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <param name="arg1">Parameter to format (placeholder {1}).</param>
            <param name="arg2">Parameter to format (placeholder {2}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Sends a formatted text.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="format">The text format of the log with 4 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <param name="arg1">Parameter to format (placeholder {1}).</param>
            <param name="arg2">Parameter to format (placeholder {2}).</param>
            <param name="arg3">Parameter to format (placeholder {3}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.String,System.Object[])">
            <summary>
            Sends a formatted text.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="format">The text format of the log with 5 placeholders.</param>
            <param name="arguments">Multiple parameters to format.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.Func{System.String})">
            <summary>
            Sends a text obtained through a delegate.
            The delegate will be called only if the log is not filtered.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``1(CK.Core.IActivityMonitorGroupSender,System.Func{``0,System.String},``0)">
            <summary>
            Sends a text obtained through a parameterized delegate.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T">Type of the parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param">Parameter of the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``2(CK.Core.IActivityMonitorGroupSender,System.Func{``0,``1,System.String},``0,``1)">
            <summary>
            Sends a text obtained through a parameterized delegate.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``3(CK.Core.IActivityMonitorGroupSender,System.Func{``0,``1,``2,System.String},``0,``1,``2)">
            <summary>
            Sends a log with a text obtained through a parameterized delegate.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T3">Type of the third parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
            <param name="param3">Third parameter for the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,CK.Core.CKTrait,System.String)">
            <summary>
            Sends a text with associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="tags">Tags for the log.</param>
            <param name="text">The text of the log.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,CK.Core.CKTrait,System.String,System.Object)">
            <summary>
            Sends a formatted text with associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="tags">Tags for the log.</param>
            <param name="format">The text format of the log with 1 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,CK.Core.CKTrait,System.String,System.Object,System.Object)">
            <summary>
            Sends a formatted text with associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="tags">Tags for the log.</param>
            <param name="format">The text format of the log with 2 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <param name="arg1">Parameter to format (placeholder {1}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,CK.Core.CKTrait,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Sends a formatted text with associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="tags">Tags for the log.</param>
            <param name="format">The text format of the log with 3 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <param name="arg1">Parameter to format (placeholder {1}).</param>
            <param name="arg2">Parameter to format (placeholder {2}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,CK.Core.CKTrait,System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Sends a formatted text with associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="tags">Tags for the log.</param>
            <param name="format">The text format of the log with 4 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <param name="arg1">Parameter to format (placeholder {1}).</param>
            <param name="arg2">Parameter to format (placeholder {2}).</param>
            <param name="arg3">Parameter to format (placeholder {3}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,CK.Core.CKTrait,System.String,System.Object[])">
            <summary>
            Sends a formatted text with associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="tags">Tags for the log.</param>
            <param name="format">The text format of the log with 5 placeholders.</param>
            <param name="arguments">Multiple parameters to format.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,CK.Core.CKTrait,System.Func{System.String})">
            <summary>
            Sends a text obtained through a delegate with associated tags.
            The delegate will be called only if the log is not filtered.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="tags">Tags for the log.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``1(CK.Core.IActivityMonitorGroupSender,CK.Core.CKTrait,System.Func{``0,System.String},``0)">
            <summary>
            Sends a text obtained through a parameterized delegate with associated tags.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T">Type of the parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="tags">Tags for the log.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param">Parameter of the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``2(CK.Core.IActivityMonitorGroupSender,CK.Core.CKTrait,System.Func{``0,``1,System.String},``0,``1)">
            <summary>
            Sends a text obtained through a parameterized delegate with associated tags.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="tags">Tags for the log.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``3(CK.Core.IActivityMonitorGroupSender,CK.Core.CKTrait,System.Func{``0,``1,``2,System.String},``0,``1,``2)">
            <summary>
            Sends a log with a text obtained through a parameterized delegate with associated tags.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T3">Type of the third parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="tags">Tags for the log.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
            <param name="param3">Third parameter for the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.Exception)">
            <summary>
            Sends a log  with an exception.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.Exception,System.String)">
            <summary>
            Sends a text with an exception.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="text">The text of the log.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.Exception,System.String,System.Object)">
            <summary>
            Sends a formatted text with an exception.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="format">The text format of the log with 1 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.Exception,System.String,System.Object,System.Object)">
            <summary>
            Sends a formatted text with an exception.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="format">The text format of the log with 2 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <param name="arg1">Parameter to format (placeholder {1}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.Exception,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Sends a formatted text with an exception.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="format">The text format of the log with 3 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <param name="arg1">Parameter to format (placeholder {1}).</param>
            <param name="arg2">Parameter to format (placeholder {2}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.Exception,System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Sends a formatted text with an exception.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="format">The text format of the log with 4 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <param name="arg1">Parameter to format (placeholder {1}).</param>
            <param name="arg2">Parameter to format (placeholder {2}).</param>
            <param name="arg3">Parameter to format (placeholder {3}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.Exception,System.String,System.Object[])">
            <summary>
            Sends a formatted text with an exception.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="format">The text format of the log with 5 placeholders.</param>
            <param name="arguments">Multiple parameters to format.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.Exception,System.Func{System.String})">
            <summary>
            Sends a text obtained through a delegate with an exception.
            The delegate will be called only if the log is not filtered.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``1(CK.Core.IActivityMonitorGroupSender,System.Exception,System.Func{``0,System.String},``0)">
            <summary>
            Sends a text obtained through a parameterized delegate with an exception.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T">Type of the parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param">Parameter of the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``2(CK.Core.IActivityMonitorGroupSender,System.Exception,System.Func{``0,``1,System.String},``0,``1)">
            <summary>
            Sends a text obtained through a parameterized delegate with an exception.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``3(CK.Core.IActivityMonitorGroupSender,System.Exception,System.Func{``0,``1,``2,System.String},``0,``1,``2)">
            <summary>
            Sends a log with a text obtained through a parameterized delegate with an exception.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T3">Type of the third parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
            <param name="param3">Third parameter for the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.Exception,CK.Core.CKTrait)">
            <summary>
            Sends a log  with an exception and associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="tags">Tags for the log.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.Exception,CK.Core.CKTrait,System.String)">
            <summary>
            Sends a text with an exception and associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="tags">Tags for the log.</param>
            <param name="text">The text of the log.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.Exception,CK.Core.CKTrait,System.String,System.Object)">
            <summary>
            Sends a formatted text with an exception and associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="tags">Tags for the log.</param>
            <param name="format">The text format of the log with 1 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.Exception,CK.Core.CKTrait,System.String,System.Object,System.Object)">
            <summary>
            Sends a formatted text with an exception and associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="tags">Tags for the log.</param>
            <param name="format">The text format of the log with 2 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <param name="arg1">Parameter to format (placeholder {1}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.Exception,CK.Core.CKTrait,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Sends a formatted text with an exception and associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="tags">Tags for the log.</param>
            <param name="format">The text format of the log with 3 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <param name="arg1">Parameter to format (placeholder {1}).</param>
            <param name="arg2">Parameter to format (placeholder {2}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.Exception,CK.Core.CKTrait,System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Sends a formatted text with an exception and associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="tags">Tags for the log.</param>
            <param name="format">The text format of the log with 4 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <param name="arg1">Parameter to format (placeholder {1}).</param>
            <param name="arg2">Parameter to format (placeholder {2}).</param>
            <param name="arg3">Parameter to format (placeholder {3}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.Exception,CK.Core.CKTrait,System.String,System.Object[])">
            <summary>
            Sends a formatted text with an exception and associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="tags">Tags for the log.</param>
            <param name="format">The text format of the log with 5 placeholders.</param>
            <param name="arguments">Multiple parameters to format.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorGroupSender,System.Exception,CK.Core.CKTrait,System.Func{System.String})">
            <summary>
            Sends a text obtained through a delegate with an exception and associated tags.
            The delegate will be called only if the log is not filtered.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="tags">Tags for the log.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``1(CK.Core.IActivityMonitorGroupSender,System.Exception,CK.Core.CKTrait,System.Func{``0,System.String},``0)">
            <summary>
            Sends a text obtained through a parameterized delegate with an exception and associated tags.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T">Type of the parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="tags">Tags for the log.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param">Parameter of the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``2(CK.Core.IActivityMonitorGroupSender,System.Exception,CK.Core.CKTrait,System.Func{``0,``1,System.String},``0,``1)">
            <summary>
            Sends a text obtained through a parameterized delegate with an exception and associated tags.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="tags">Tags for the log.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``3(CK.Core.IActivityMonitorGroupSender,System.Exception,CK.Core.CKTrait,System.Func{``0,``1,``2,System.String},``0,``1,``2)">
            <summary>
            Sends a log with a text obtained through a parameterized delegate with an exception and associated tags.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T3">Type of the third parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorGroupSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="tags">Tags for the log.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
            <param name="param3">Third parameter for the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,System.String)">
            <summary>
            Sends a text.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="text">The text of the log.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,System.String,System.Object)">
            <summary>
            Sends a formatted text.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="format">The text format of the log with 1 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,System.String,System.Object,System.Object)">
            <summary>
            Sends a formatted text.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="format">The text format of the log with 2 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <param name="arg1">Parameter to format (placeholder {1}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Sends a formatted text.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="format">The text format of the log with 3 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <param name="arg1">Parameter to format (placeholder {1}).</param>
            <param name="arg2">Parameter to format (placeholder {2}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,System.String,System.Object[])">
            <summary>
            Sends a formatted text.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="format">The text format of the log with 4 placeholders.</param>
            <param name="arguments">Multiple parameters to format.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,System.Func{System.String})">
            <summary>
            Sends a text obtained through a delegate.
            The delegate will be called only if the log is not filtered.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``1(CK.Core.IActivityMonitorLineSender,System.Func{``0,System.String},``0)">
            <summary>
            Sends a text obtained through a parameterized delegate.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T">Type of the parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param">Parameter of the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``2(CK.Core.IActivityMonitorLineSender,System.Func{``0,``1,System.String},``0,``1)">
            <summary>
            Sends a text obtained through a parameterized delegate.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``3(CK.Core.IActivityMonitorLineSender,System.Func{``0,``1,``2,System.String},``0,``1,``2)">
            <summary>
            Sends a log with a text obtained through a parameterized delegate.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T3">Type of the third parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
            <param name="param3">Third parameter for the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,CK.Core.CKTrait,System.String)">
            <summary>
            Sends a text with associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="tags">Tags for the log.</param>
            <param name="text">The text of the log.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,CK.Core.CKTrait,System.String,System.Object)">
            <summary>
            Sends a formatted text with associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="tags">Tags for the log.</param>
            <param name="format">The text format of the log with 1 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,CK.Core.CKTrait,System.String,System.Object,System.Object)">
            <summary>
            Sends a formatted text with associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="tags">Tags for the log.</param>
            <param name="format">The text format of the log with 2 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <param name="arg1">Parameter to format (placeholder {1}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,CK.Core.CKTrait,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Sends a formatted text with associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="tags">Tags for the log.</param>
            <param name="format">The text format of the log with 3 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <param name="arg1">Parameter to format (placeholder {1}).</param>
            <param name="arg2">Parameter to format (placeholder {2}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,CK.Core.CKTrait,System.String,System.Object[])">
            <summary>
            Sends a formatted text with associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="tags">Tags for the log.</param>
            <param name="format">The text format of the log with 4 placeholders.</param>
            <param name="arguments">Multiple parameters to format.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,CK.Core.CKTrait,System.Func{System.String})">
            <summary>
            Sends a text obtained through a delegate with associated tags.
            The delegate will be called only if the log is not filtered.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="tags">Tags for the log.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``1(CK.Core.IActivityMonitorLineSender,CK.Core.CKTrait,System.Func{``0,System.String},``0)">
            <summary>
            Sends a text obtained through a parameterized delegate with associated tags.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T">Type of the parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="tags">Tags for the log.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param">Parameter of the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``2(CK.Core.IActivityMonitorLineSender,CK.Core.CKTrait,System.Func{``0,``1,System.String},``0,``1)">
            <summary>
            Sends a text obtained through a parameterized delegate with associated tags.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="tags">Tags for the log.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``3(CK.Core.IActivityMonitorLineSender,CK.Core.CKTrait,System.Func{``0,``1,``2,System.String},``0,``1,``2)">
            <summary>
            Sends a log with a text obtained through a parameterized delegate with associated tags.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T3">Type of the third parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="tags">Tags for the log.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
            <param name="param3">Third parameter for the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,System.Exception)">
            <summary>
            Sends a log with an exception.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,System.Exception,System.String)">
            <summary>
            Sends a text with an exception.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="text">The text of the log.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,System.Exception,System.String,System.Object)">
            <summary>
            Sends a formatted text with an exception.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="format">The text format of the log with 1 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,System.Exception,System.String,System.Object,System.Object)">
            <summary>
            Sends a formatted text with an exception.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="format">The text format of the log with 2 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <param name="arg1">Parameter to format (placeholder {1}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,System.Exception,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Sends a formatted text with an exception.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="format">The text format of the log with 3 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <param name="arg1">Parameter to format (placeholder {1}).</param>
            <param name="arg2">Parameter to format (placeholder {2}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,System.Exception,System.String,System.Object[])">
            <summary>
            Sends a formatted text with an exception.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="format">The text format of the log with 4 placeholders.</param>
            <param name="arguments">Multiple parameters to format.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,System.Exception,System.Func{System.String})">
            <summary>
            Sends a text obtained through a delegate with an exception.
            The delegate will be called only if the log is not filtered.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``1(CK.Core.IActivityMonitorLineSender,System.Exception,System.Func{``0,System.String},``0)">
            <summary>
            Sends a text obtained through a parameterized delegate with an exception.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T">Type of the parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param">Parameter of the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``2(CK.Core.IActivityMonitorLineSender,System.Exception,System.Func{``0,``1,System.String},``0,``1)">
            <summary>
            Sends a text obtained through a parameterized delegate with an exception.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``3(CK.Core.IActivityMonitorLineSender,System.Exception,System.Func{``0,``1,``2,System.String},``0,``1,``2)">
            <summary>
            Sends a log with a text obtained through a parameterized delegate with an exception.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T3">Type of the third parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
            <param name="param3">Third parameter for the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,System.Exception,CK.Core.CKTrait)">
            <summary>
            Sends a log with an exception and associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="tags">Tags for the log.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,System.Exception,CK.Core.CKTrait,System.String)">
            <summary>
            Sends a text with an exception and associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="tags">Tags for the log.</param>
            <param name="text">The text of the log.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,System.Exception,CK.Core.CKTrait,System.String,System.Object)">
            <summary>
            Sends a formatted text with an exception and associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="tags">Tags for the log.</param>
            <param name="format">The text format of the log with 1 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,System.Exception,CK.Core.CKTrait,System.String,System.Object,System.Object)">
            <summary>
            Sends a formatted text with an exception and associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="tags">Tags for the log.</param>
            <param name="format">The text format of the log with 2 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <param name="arg1">Parameter to format (placeholder {1}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,System.Exception,CK.Core.CKTrait,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Sends a formatted text with an exception and associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="tags">Tags for the log.</param>
            <param name="format">The text format of the log with 3 placeholders.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <param name="arg1">Parameter to format (placeholder {1}).</param>
            <param name="arg2">Parameter to format (placeholder {2}).</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,System.Exception,CK.Core.CKTrait,System.String,System.Object[])">
            <summary>
            Sends a formatted text with an exception and associated tags.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="tags">Tags for the log.</param>
            <param name="format">The text format of the log with 4 placeholders.</param>
            <param name="arguments">Multiple parameters to format.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send(CK.Core.IActivityMonitorLineSender,System.Exception,CK.Core.CKTrait,System.Func{System.String})">
            <summary>
            Sends a text obtained through a delegate with an exception and associated tags.
            The delegate will be called only if the log is not filtered.
            </summary>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="tags">Tags for the log.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``1(CK.Core.IActivityMonitorLineSender,System.Exception,CK.Core.CKTrait,System.Func{``0,System.String},``0)">
            <summary>
            Sends a text obtained through a parameterized delegate with an exception and associated tags.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T">Type of the parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="tags">Tags for the log.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param">Parameter of the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``2(CK.Core.IActivityMonitorLineSender,System.Exception,CK.Core.CKTrait,System.Func{``0,``1,System.String},``0,``1)">
            <summary>
            Sends a text obtained through a parameterized delegate with an exception and associated tags.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="tags">Tags for the log.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorSendExtension.Send``3(CK.Core.IActivityMonitorLineSender,System.Exception,CK.Core.CKTrait,System.Func{``0,``1,``2,System.String},``0,``1,``2)">
            <summary>
            Sends a log with a text obtained through a parameterized delegate with an exception and associated tags.
            The delegate will be called only if the log is not filtered.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T3">Type of the third parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="this">This <see cref="T:CK.Core.IActivityMonitorLineSender"/> object.</param>
            <param name="ex">The exception. Must not be null.</param>
            <param name="tags">Tags for the log.</param> 
            <param name="text">Function that returns a string. Must not be null.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
            <param name="param3">Third parameter for the <paramref name="text"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActivityMonitorGroupSender.#ctor(CK.Core.IActivityMonitor,CK.Core.LogLevel,System.String,System.Int32)">
            <summary>
            Used only by filtering extension methods (level is always filtered).
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorGroupSender.#ctor(CK.Core.IActivityMonitor)">
            <summary>
            Used only to initialize a ActivityMonitorGroupSender for rejected opened group.
            </summary>
        </member>
        <member name="P:CK.Core.ActivityMonitorGroupSender.IsRejected">
            <summary>
            Gets whether the log has been rejected.
            </summary>
        </member>
        <member name="F:CK.Core.ActivityMonitorLineSender.FakeLineSender">
            <summary>
            We can use a singleton with a null monitor since to NOT send a line, we do not need the monitor.
            This is not the same for groups: to reject a group opening we need to open a "rejected group" in order to track
            closing, hence we do need to have a monitor: for groups, we must build a GroupSender that references it.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityMonitorLineSender.#ctor(CK.Core.IActivityMonitor,CK.Core.LogLevel,System.String,System.Int32)">
            <summary>
            Used only by filtering extension methods (level is filtered and not None) or by static FakeLineSender (level is None).
            </summary>
        </member>
        <member name="T:CK.Core.Impl.ActivityMonitorOutput">
            <summary>
            Implementation of <see cref="T:CK.Core.IActivityMonitorOutput"/> for <see cref="P:CK.Core.IActivityMonitor.Output"/>.
            </summary>
        </member>
        <member name="M:CK.Core.Impl.ActivityMonitorOutput.#ctor(CK.Core.Impl.IActivityMonitorImpl)">
            <summary>
            Initializes a new <see cref="T:CK.Core.Impl.ActivityMonitorOutput"/> bound to a <see cref="T:CK.Core.IActivityMonitor"/>.
            </summary>
            <param name="monitor"></param>
        </member>
        <member name="M:CK.Core.Impl.ActivityMonitorOutput.RegisterClient(CK.Core.IActivityMonitorClient,System.Boolean@)">
            <summary>
            Registers an <see cref="T:CK.Core.IActivityMonitorClient"/> to the <see cref="P:CK.Core.Impl.ActivityMonitorOutput.Clients"/> list.
            Duplicate IActivityMonitorClient are silently ignored.
            </summary>
            <param name="client">An <see cref="T:CK.Core.IActivityMonitorClient"/> implementation.</param>
            <param name="added">True if the client has been added, false if it was already registered.</param>
            <returns>The registered client.</returns>
        </member>
        <member name="M:CK.Core.Impl.ActivityMonitorOutput.RegisterClient``1(``0,System.Boolean@)">
            <summary>
            Registers a typed <see cref="T:CK.Core.IActivityMonitorClient"/>.
            </summary>
            <typeparam name="T">Any type that specializes <see cref="T:CK.Core.IActivityMonitorClient"/>.</typeparam>
            <param name="client">Clients to register.</param>
            <param name="added">True if the client has been added, false if it was already registered.</param>
            <returns>The registered client.</returns>
        </member>
        <member name="M:CK.Core.Impl.ActivityMonitorOutput.RegisterUniqueClient``1(System.Func{``0,System.Boolean},System.Func{``0})">
            <summary>
            Registers a <see cref="T:CK.Core.IActivityMonitorClient"/> that must be unique in a sense.
            </summary>
            <param name="tester">Predicate that must be satisfied for at least one registered client.</param>
            <param name="factory">Factory that will be called if no existing client satisfies <paramref name="tester"/>.</param>
            <returns>The existing or newly created client.</returns>
            <remarks>
            The factory function MUST return a client that satisfies the tester function otherwise a <see cref="T:System.InvalidOperationException"/> is thrown.
            The factory is called only when the no client satisfies the tester function: this makes the 'added' out parameter useless.
            </remarks>
        </member>
        <member name="M:CK.Core.Impl.ActivityMonitorOutput.UnregisterClient(CK.Core.IActivityMonitorClient)">
            <summary>
            Unregisters the given <see cref="T:CK.Core.IActivityMonitorClient"/> from the <see cref="P:CK.Core.Impl.ActivityMonitorOutput.Clients"/> list.
            Silently ignores unregistered client.
            </summary>
            <param name="client">An <see cref="T:CK.Core.IActivityMonitorClient"/> implementation.</param>
            <returns>The unregistered client or null if it has not been found.</returns>
        </member>
        <member name="P:CK.Core.Impl.ActivityMonitorOutput.BridgeTarget">
            <summary>
            Gets an entry point for other monitors: by registering <see cref="T:CK.Core.ActivityMonitorBridge"/> in other <see cref="P:CK.Core.IActivityMonitor.Output"/>
            bound to this <see cref="T:CK.Core.ActivityMonitorBridgeTarget"/>, log streams can easily be merged.
            </summary>
        </member>
        <member name="P:CK.Core.Impl.ActivityMonitorOutput.Monitor">
            <summary>
            Gets the associated <see cref="T:CK.Core.IActivityMonitor"/>.
            </summary>
        </member>
        <member name="P:CK.Core.Impl.ActivityMonitorOutput.Clients">
            <summary>
            Gets the list of registered <see cref="T:CK.Core.IActivityMonitorClient"/>.
            </summary>
        </member>
        <member name="T:CK.Core.Impl.DisposableActivityMonitor">
            <summary>
            Trivial implementation of <see cref="T:CK.Core.IDisposableActivityMonitor"/>.
            <see cref="M:CK.Core.Impl.DisposableActivityMonitor.Dispose"/> simply closes all opened groups.
            </summary>
        </member>
        <member name="M:CK.Core.Impl.DisposableActivityMonitor.Finalize">
            <summary>
            Ensures that potential unmanaged resources are correctly released by calling <see cref="M:CK.Core.Impl.DisposableActivityMonitor.Dispose(System.Boolean)"/> with false.
            </summary>
        </member>
        <member name="M:CK.Core.Impl.DisposableActivityMonitor.Dispose">
            <summary>
            Automatically close any opened groups.
            Can be called multiple times.
            </summary>
        </member>
        <member name="M:CK.Core.Impl.DisposableActivityMonitor.Dispose(System.Boolean)">
            <summary>
            Automatically close any opened groups.
            Can be called multiple times.
            </summary>
            <param name="disposing">Whether <see cref="M:CK.Core.Impl.DisposableActivityMonitor.Dispose"/> is called.</param>
        </member>
        <member name="T:CK.Core.LogFilter">
            <summary>
            Immutable capture of a double <see cref="T:CK.Core.LogLevelFilter"/>. One for <see cref="F:CK.Core.LogFilter.Line"/> and one for <see cref="F:CK.Core.LogFilter.Group"/>.
            This value type exposes predefined configured couples: <see cref="F:CK.Core.LogFilter.Debug"/> (full trace), <see cref="F:CK.Core.LogFilter.Verbose"/>, <see cref="F:CK.Core.LogFilter.Monitor"/>, 
            <see cref="F:CK.Core.LogFilter.Terse"/>, <see cref="F:CK.Core.LogFilter.Release"/> and <see cref="F:CK.Core.LogFilter.Off"/> (no log at all).
            </summary>
        </member>
        <member name="F:CK.Core.LogFilter.Undefined">
            <summary>
            Undefined filter is <see cref="F:CK.Core.LogLevelFilter.None"/> for both <see cref="F:CK.Core.LogFilter.Line"/> and <see cref="F:CK.Core.LogFilter.Group"/>.
            This is the same as using the default constructor for this structure (it is exposed here for clarity).
            </summary>
        </member>
        <member name="F:CK.Core.LogFilter.Debug">
            <summary>
            Debug filter enables full <see cref="F:CK.Core.LogLevelFilter.Trace"/> for both <see cref="F:CK.Core.LogFilter.Line"/> and <see cref="F:CK.Core.LogFilter.Group"/>.
            </summary>
        </member>
        <member name="F:CK.Core.LogFilter.Verbose">
            <summary>
            Verbose <see cref="F:CK.Core.LogLevelFilter.Trace"/> all <see cref="F:CK.Core.LogFilter.Group"/>s but limits <see cref="F:CK.Core.LogFilter.Line"/> to <see cref="F:CK.Core.LogLevelFilter.Info"/> level.
            </summary>
        </member>
        <member name="F:CK.Core.LogFilter.Monitor">
            <summary>
            While monitoring, only errors and warnings are captured, whereas all <see cref="F:CK.Core.LogFilter.Group"/>s appear to get the detailed structure of the activity.
            </summary>
        </member>
        <member name="F:CK.Core.LogFilter.Terse">
            <summary>
            Terse filter captures only errors for <see cref="F:CK.Core.LogFilter.Line"/> and limits <see cref="F:CK.Core.LogFilter.Group"/>s to <see cref="F:CK.Core.LogLevelFilter.Info"/> level.
            </summary>
        </member>
        <member name="F:CK.Core.LogFilter.Release">
            <summary>
            Release filter captures only <see cref="F:CK.Core.LogLevelFilter.Error"/>s for both <see cref="F:CK.Core.LogFilter.Line"/> and <see cref="F:CK.Core.LogFilter.Group"/>.
            </summary>
        </member>
        <member name="F:CK.Core.LogFilter.Off">
            <summary>
            Off filter does not capture anything.
            </summary>
        </member>
        <member name="F:CK.Core.LogFilter.Invalid">
            <summary>
            Invalid must be used as a special value. It is <see cref="F:CK.Core.LogLevelFilter.Invalid"/> for both <see cref="F:CK.Core.LogFilter.Line"/> and <see cref="F:CK.Core.LogFilter.Group"/>.
            </summary>
        </member>
        <member name="F:CK.Core.LogFilter.Group">
            <summary>
            The filter that applies to groups. 
            </summary>
        </member>
        <member name="F:CK.Core.LogFilter.Line">
            <summary>
            The filter that applies to log lines (Trace, Info, Warn, Error and Fatal). 
            </summary>
        </member>
        <member name="M:CK.Core.LogFilter.#ctor(CK.Core.LogLevelFilter,CK.Core.LogLevelFilter)">
            <summary>
            Initializes a new <see cref="T:CK.Core.LogFilter"/> with a level for <see cref="F:CK.Core.LogFilter.Group"/>s and <see cref="F:CK.Core.LogFilter.Line"/> logs.
            </summary>
            <param name="group">Filter for groups.</param>
            <param name="line">Filter for lines.</param>
        </member>
        <member name="M:CK.Core.LogFilter.Combine(CK.Core.LogFilter)">
            <summary>
            Combines this filter with another one. <see cref="F:CK.Core.LogFilter.Line"/> and <see cref="F:CK.Core.LogFilter.Group"/> level filters
            are combined with <see cref="M:CK.Core.LogFilter.Combine(CK.Core.LogLevelFilter,CK.Core.LogLevelFilter)"/>.
            </summary>
            <param name="other">The other filter to combine with this one.</param>
            <returns>The resulting filter.</returns>
        </member>
        <member name="M:CK.Core.LogFilter.CombineNoneOnly(CK.Core.LogFilter)">
            <summary>
            Combines this filter with another one only if <see cref="F:CK.Core.LogFilter.Line"/> or <see cref="F:CK.Core.LogFilter.Group"/> is <see cref="F:CK.Core.LogLevelFilter.None"/>.
            </summary>
            <param name="other">The other filter to combine with this one.</param>
            <returns>The resulting filter.</returns>
        </member>
        <member name="M:CK.Core.LogFilter.SetLine(CK.Core.LogLevelFilter)">
            <summary>
            Returns a <see cref="T:CK.Core.LogFilter"/> with a given <see cref="T:CK.Core.LogLevelFilter"/> for the <see cref="F:CK.Core.LogFilter.Line"/>.
            </summary>
            <param name="line">Filter for the line.</param>
            <returns>The filter with the line level.</returns>
        </member>
        <member name="M:CK.Core.LogFilter.SetGroup(CK.Core.LogLevelFilter)">
            <summary>
            Returns a <see cref="T:CK.Core.LogFilter"/> with a given <see cref="T:CK.Core.LogLevelFilter"/> for the <see cref="F:CK.Core.LogFilter.Group"/>.
            </summary>
            <param name="group">Filter for the group.</param>
            <returns>The filter with the group level.</returns>
        </member>
        <member name="M:CK.Core.LogFilter.HasImpactOn(CK.Core.LogFilter)">
            <summary>
            Tests if <see cref="M:CK.Core.LogFilter.Combine(CK.Core.LogFilter)">combining</see> this and <paramref name="x"/> will result in a different filter than x.
            </summary>
            <param name="x">The other filter.</param>
            <returns>True if combining this filter and <paramref name="x"/> will change x.</returns>
        </member>
        <member name="M:CK.Core.LogFilter.Combine(CK.Core.LogLevelFilter,CK.Core.LogLevelFilter)">
            <summary>
            Combines two enums <see cref="T:CK.Core.LogLevelFilter"/> into one.
            The resulting filter is the more verbose one (the smallest level). <see cref="F:CK.Core.LogLevelFilter.Invalid"/> is considered as <see cref="F:CK.Core.LogLevelFilter.None"/> (it has no impact).
            This operation is commutative and associative: different order of combination always give the same result.
            </summary>
            <param name="x">First filter level.</param>
            <param name="y">Second filter level.</param>
            <returns>The resulting level.</returns>
        </member>
        <member name="M:CK.Core.LogFilter.Equals(System.Object)">
            <summary>
            Overridden to compare <see cref="F:CK.Core.LogFilter.Line"/> and <see cref="F:CK.Core.LogFilter.Group"/>.
            </summary>
            <param name="obj">Other object.</param>
            <returns>True if Line and Group are equal.</returns>
        </member>
        <member name="M:CK.Core.LogFilter.GetHashCode">
            <summary>
            Overridden to compute hash based on <see cref="F:CK.Core.LogFilter.Line"/> and <see cref="F:CK.Core.LogFilter.Group"/> values.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:CK.Core.LogFilter.ToString">
            <summary>
            Overridden to show the group and the line level.
            </summary>
            <returns>A {group,line} string.</returns>
        </member>
        <member name="M:CK.Core.LogFilter.op_Equality(CK.Core.LogFilter,CK.Core.LogFilter)">
            <summary>
            Equality operator.
            </summary>
            <param name="x">First filter.</param>
            <param name="y">Second filter.</param>
            <returns>True if <see cref="F:CK.Core.LogFilter.Line"/> and <see cref="F:CK.Core.LogFilter.Group"/> are the same for the two filters.</returns>
        </member>
        <member name="M:CK.Core.LogFilter.op_Inequality(CK.Core.LogFilter,CK.Core.LogFilter)">
            <summary>
            Inequality operator.
            </summary>
            <param name="x">First filter.</param>
            <param name="y">Second filter.</param>
            <returns>True if <see cref="F:CK.Core.LogFilter.Line"/> and <see cref="F:CK.Core.LogFilter.Group"/> are the same for the two filters.</returns>
        </member>
        <member name="M:CK.Core.LogFilter.Parse(System.String)">
            <summary>
            Parses the filter: it can be a predefined filter as ("Undefined", "Debug", "Verbose", etc.) 
            or as {GroupLogLevelFilter,LineLogLevelFilter} pairs like "{None,None}", "{Error,Trace}".
            </summary>
            <param name="filter">Predefined filter as (Undefined, Debug, Verbose, etc.) or as {LineLogLevelFilter,GroupLogLevelFilter} like {None,None}, {Error,Trace}.</param>
            <returns>The filter.</returns>
        </member>
        <member name="M:CK.Core.LogFilter.TryParse(System.String,CK.Core.LogFilter@)">
            <summary>
            Tries to parse a <see cref="T:CK.Core.LogFilter"/>: it can be a predefined filter as ("Undefined", "Debug", "Verbose", etc.)  
            or as {GroupLogLevelFilter,LineLogLevelFilter} pairs like "{None,None}", "{Error,Trace}".
            </summary>
            <param name="s">Filter to parse.</param>
            <param name="f">Resulting filter.</param>
            <returns>True on success, false on error.</returns>
        </member>
        <member name="M:CK.Core.LogFilter.Match(System.String,System.Int32@,System.Int32,CK.Core.LogFilter@)">
            <summary>
            Tries to parse a <see cref="T:CK.Core.LogFilter"/>: it can be a predefined filter as ("Undefined", "Debug", "Verbose", etc.)  
            or as {GroupLogLevelFilter,LineLogLevelFilter} pairs like "{None,None}", "{Error,Trace}".
            </summary>
            <param name="s">Filter to parse.</param>
            <param name="startAt">
            Index where the match must start (can be equal to or greater than the length of the string: the match fails).
            On success, index of the end of the match.
            </param>
            <param name="maxLength">
            Maximum index to consider in the string (it shortens the default <see cref="P:System.String.Length"/>), it can be zero or negative.
            If maxLength is greater than String.Length an <see cref="T:System.ArgumentException"/> is thrown.
            </param>
            <param name="f">Resulting filter.</param>
            <returns>True on success, false on error.</returns>
        </member>
        <member name="M:CK.Core.LogFilter.Match(System.String,System.Int32@,System.Int32,CK.Core.LogLevelFilter@)">
            <summary>
            Tries to parse a <see cref="T:CK.Core.LogLevelFilter"/>.
            </summary>
            <param name="s">Filter level to parse.</param>
            <param name="startAt">
            Index where the match must start (can be equal to or greater than the length of the string: the match fails).
            On success, index of the end of the match.
            </param>
            <param name="maxLength">
            Maximum index to consider in the string (it shortens the default <see cref="P:System.String.Length"/>), it can be zero or negative.
            If maxLength is greater than String.Length an <see cref="T:System.ArgumentException"/> is thrown.
            </param>
            <param name="level">Resulting level.</param>
            <returns>True on success, false on error.</returns>
        </member>
        <member name="T:CK.Core.LogLevel">
            <summary>
            Five standard log levels in increasing order used by <see cref="T:CK.Core.IActivityMonitor"/>.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevel.None">
            <summary>
            No logging level.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevel.Trace">
            <summary>
            A trace logging level (the most verbose level).
            </summary>
        </member>
        <member name="F:CK.Core.LogLevel.Info">
            <summary>
            An info logging level.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevel.Warn">
            <summary>
            A warn logging level.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevel.Error">
            <summary>
            An error logging level: denotes an error for the current activity. 
            This error does not necessarily abort the activity.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevel.Fatal">
            <summary>
            A fatal error logging level: denotes an error that breaks (aborts)
            the current activity. This kind of error may have important side effects
            on the system.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevel.Mask">
            <summary>
            Mask that covers actual levels to easily ignore <see cref="F:CK.Core.LogLevel.IsFiltered"/> bit.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevel.IsFiltered">
            <summary>
            Flag that denotes a log level that has been filtered.
            When this flag is not set, the <see cref="M:CK.Core.IActivityMonitor.UnfilteredOpenGroup(CK.Core.ActivityMonitorGroupData)"/> or <see cref="M:CK.Core.IActivityMonitor.UnfilteredLog(CK.Core.ActivityMonitorLogData)"/> has been 
            called directly. When set, the log has typically been emitted through the extension methods that challenge the 
            monitor's <see cref="P:CK.Core.IActivityMonitor.ActualFilter">actual filter</see> and <see cref="P:CK.Core.ActivityMonitor.DefaultFilter"/> static configuration.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevel.NumberOfBits">
            <summary>
            Number of bits actually covered by this bit flag.
            </summary>
        </member>
        <member name="T:CK.Core.LogLevelFilter">
            <summary>
            Defines filters for <see cref="T:CK.Core.LogLevel"/>.
            </summary>
            <remarks>
            <see cref="T:CK.Core.LogFilter"/> capture two levels: one for lines and one for groups.
            </remarks>
        </member>
        <member name="F:CK.Core.LogLevelFilter.None">
            <summary>
            No filter: can have the same effect as Trace but SHOULD indicate
            an unknown or undefined filter that, when combined with other level filters to 
            compute the final (minimal) filter level to take into account, must be ignored.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevelFilter.Trace">
            <summary>
            Everything is logged (<see cref="F:CK.Core.LogLevel.Trace"/>).
            </summary>
        </member>
        <member name="F:CK.Core.LogLevelFilter.Info">
            <summary>
            Only <see cref="F:CK.Core.LogLevel.Info"/> and above is logged.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevelFilter.Warn">
            <summary>
            Only <see cref="F:CK.Core.LogLevel.Warn"/> and above is logged.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevelFilter.Error">
            <summary>
            Only <see cref="F:CK.Core.LogLevel.Error"/> and above is logged.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevelFilter.Fatal">
            <summary>
            Only <see cref="F:CK.Core.LogLevel.Fatal"/> is logged.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevelFilter.Off">
            <summary>
            Do not log anything.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevelFilter.Invalid">
            <summary>
            Invalid filter can be use to designate an unknown filter. 
            Since its value is -1, in the worst case it will not filter anything.
            </summary>
        </member>
        <member name="T:CK.Core.SourceLogFilter">
            <summary>
            Immutable encapsulation of the two source filters: this enables overriding or per source file filtering.
            </summary>
        </member>
        <member name="F:CK.Core.SourceLogFilter.Undefined">
            <summary>
            Undefined filter is <see cref="F:CK.Core.LogFilter.Undefined"/> for both <see cref="F:CK.Core.SourceLogFilter.Override"/> and <see cref="F:CK.Core.SourceLogFilter.Minimal"/>.
            This is the same as using the default constructor for this structure (it is exposed here for clarity).
            </summary>
        </member>
        <member name="F:CK.Core.SourceLogFilter.Override">
            <summary>
            The filter to be applied before challenging the <see cref="P:CK.Core.IActivityMonitor.ActualFilter"/>.
            When not <see cref="F:CK.Core.LogFilter.Undefined"/>, the ActualFilter is ignored  (as well as this <see cref="F:CK.Core.SourceLogFilter.Minimal"/>).
            </summary>
        </member>
        <member name="F:CK.Core.SourceLogFilter.Minimal">
            <summary>
            The filter that when defined is combined with the  <see cref="P:CK.Core.IActivityMonitor.ActualFilter"/>.
            </summary>
        </member>
        <member name="M:CK.Core.SourceLogFilter.#ctor(CK.Core.LogFilter,CK.Core.LogFilter)">
            <summary>
            Initializes a new <see cref="T:CK.Core.SourceLogFilter"/> with a given filter for <see cref="F:CK.Core.SourceLogFilter.Override"/>s and <see cref="F:CK.Core.SourceLogFilter.Minimal"/>.
            </summary>
            <param name="overrideFilter">Overridden filter.</param>
            <param name="minimalFilter">Minimal filter.</param>
        </member>
        <member name="M:CK.Core.SourceLogFilter.Combine(CK.Core.SourceLogFilter)">
            <summary>
            Combines this filter with another one. <see cref="F:CK.Core.SourceLogFilter.Override"/> and <see cref="F:CK.Core.SourceLogFilter.Minimal"/> level filters
            are combined with <see cref="M:CK.Core.LogFilter.Combine(CK.Core.LogFilter)"/>.
            </summary>
            <param name="other">The other filter to combine with this one.</param>
            <returns>The resulting filter.</returns>
        </member>
        <member name="P:CK.Core.SourceLogFilter.IsUndefined">
            <summary>
            Gets whether this is equal to <see cref="F:CK.Core.SourceLogFilter.Undefined"/>.
            </summary>
        </member>
        <member name="P:CK.Core.SourceLogFilter.LineFilter">
            <summary>
            Gets a combined integer: high word contains Override and low word contains Minimal filter for lines.
            </summary>
        </member>
        <member name="P:CK.Core.SourceLogFilter.GroupFilter">
            <summary>
            Gets a combined integer: high word contains Override and low word contains Minimal filter for groups.
            </summary>
        </member>
        <member name="T:CK.Core.SystemActivityMonitor">
            <summary>
            This <see cref="T:CK.Core.ActivityMonitor"/> logs errors in a directory (if the static <see cref="P:CK.Core.SystemActivityMonitor.RootLogPath"/> property is not null) and 
            raises <see cref="E:CK.Core.SystemActivityMonitor.OnError"/> events.
            Its main goal is to be internally used by the Monitor framework but can be used as a "normal" monitor (if you believe it is a good idea).
            The easiest way to configure it is to set an application settings with the key "CK.Core.SystemActivityMonitor.RootLogPath" and the root path 
            for logs as the value.
            </summary>
            <remarks>
            The RootLogPath uses the Application configuration (if it exists):
            <code>
                &lt;appSettings&gt;
                     &lt;add key="CK.Core.SystemActivityMonitor.RootLogPath" value="..." /&gt;
                 &lt;/appSettings&gt;
            </code>
            If the setting is not there, the Critical errors will NOT be logged
            except if it is explicitly set:
            <code>
                SystemActivityMonitor.RootLogPath = "...";
            </code>
            </remarks>
        </member>
        <member name="M:CK.Core.SystemActivityMonitor.EnsureStaticInitialization">
            <summary>
            Touches this type to ensure that its static information is initialized.
            This does nothing except that, since the Type is solicited, the type constructor is called if needed.
            </summary>
            <returns>Always true.</returns>
        </member>
        <member name="F:CK.Core.SystemActivityMonitor.AppSettingsKey">
            <summary>
            The key in the application settings used to initialize the <see cref="P:CK.Core.SystemActivityMonitor.RootLogPath"/> if it exists in <see cref="F:CK.Core.AppSettings.Default"/>.
            </summary>
        </member>
        <member name="F:CK.Core.SystemActivityMonitor.SubDirectoryName">
            <summary>
            The directory in <see cref="P:CK.Core.SystemActivityMonitor.RootLogPath"/> into which errors file will be created is "CriticalErrors/".
            </summary>
        </member>
        <member name="M:CK.Core.SystemActivityMonitor.AssertRootLogPathIsSet">
            <summary>
            Checks that <see cref="P:CK.Core.SystemActivityMonitor.RootLogPath"/> is correctly configured by throwing a detailed exception if not. 
            </summary>
        </member>
        <member name="M:CK.Core.SystemActivityMonitor.EnsureSystemClient(CK.Core.IActivityMonitor)">
            <summary>
            Registers the internal system client that routes errors and fatals as ActivityMonitor errors.
            </summary>
            <param name="monitor">The monitor that can be temporary works as a <see cref="T:CK.Core.SystemActivityMonitor"/>.</param>
            <returns>A disposable object that will unregister the system client (if it has been actually added).</returns>
        </member>
        <member name="M:CK.Core.SystemActivityMonitor.#ctor(System.Boolean,System.String)">
            <summary>
            Initializes a new <see cref="T:CK.Core.SystemActivityMonitor"/> that can behave as a standard monitor (when
            automatic configurations applies).
            </summary>
            <param name="applyAutoConfigurations">True to apply automatic configurations and, hence, behave like any other <see cref="T:CK.Core.ActivityMonitor"/>.</param>
            <param name="topic">Optional initial topic (can be null).</param>
        </member>
        <member name="E:CK.Core.SystemActivityMonitor.OnError">
            <summary>
            Event that enables subsequent handling of errors.
            Raising this event is protected: a registered handler that raises an exception will be automatically removed and the
            exception will be added to the <see cref="F:CK.Core.ActivityMonitor.CriticalErrorCollector"/> collector to give other participants a chance 
            to handle it and track the culprit.
            </summary>
        </member>
        <member name="P:CK.Core.SystemActivityMonitor.TrackActivityMonitorLoggingError">
            <summary>
            Gets or sets whether <see cref="F:CK.Core.ActivityMonitor.CriticalErrorCollector"/> are tracked (this is thread safe).
            When true, LoggingError events are tracked, written to a file (if <see cref="P:CK.Core.SystemActivityMonitor.RootLogPath"/> is available) and ultimately 
            published again as a <see cref="E:CK.Core.SystemActivityMonitor.OnError"/> events.
            Defaults to true.
            </summary>
        </member>
        <member name="P:CK.Core.SystemActivityMonitor.AppSettingsRootLogPath">
            <summary>
            Gets the <see cref="P:CK.Core.SystemActivityMonitor.RootLogPath"/> that is configured in application settings (null otherwise).
            Getting this property ensures that this type's static information is initialized.
            </summary>
        </member>
        <member name="P:CK.Core.SystemActivityMonitor.RootLogPath">
            <summary>
            Gets or sets (it can be set only once) the log folder to use (setting multiple time the same path is accepted). 
            Once set, the path is <see cref="M:CK.Core.FileUtil.NormalizePathSeparator(System.String,System.Boolean)">normalized and ends with a path separator</see>.
            See remarks.
            </summary>
            <remarks>
            <para>
            When setting it, the path must be valid (when it is not an absolute path, it is combined 
            with the <see cref="P:System.AppDomain.BaseDirectory">AppDomain.CurrentDomain.BaseDirectory</see>).
            </para>
            <para>
            The subordinate directory "CriticalErrors" is created (if not already here) and a test file is created (and deleted) inside it 
            to ensure that (at least at configuration time), no security configuration prevents us to create log files: all errors files will be created in this sub directory.
            </para>
            <para>
            It is recommended to use this directory to store all other logs and/or files related to activity tracking.
            </para>
            <para>
            When not null, it necessarily ends with a <see cref="F:System.IO.Path.DirectorySeparatorChar"/>.
            </para>
            <para>
            When not sets, the first get initializes it with the value of <see cref="F:CK.Core.SystemActivityMonitor.AppSettingsKey"/> in <see cref="F:CK.Core.AppSettings.Default"/> if it exists.
            </para>
            </remarks>
        </member>
        <member name="T:CK.Core.SystemActivityMonitor.SysClient">
            <summary>
            A client that can be added and removed and is available as a singleton.
            Its MinimalFilter is set to Release ensuring that errors are always monitored. Fatals and Errors are stored in RootLogPath/CriticalErrors.
            </summary>
        </member>
        <member name="T:CK.Core.SystemActivityMonitor.SysLockedClient">
            <summary>
            A SysClient that can not be removed and is available as a singleton registered in every new SystemActivityMonitor.
            </summary>
        </member>
        <member name="T:CK.Core.SystemActivityMonitor.LowLevelErrorEventArgs">
            <summary>
            Defines the event argument of <see cref="E:CK.Core.SystemActivityMonitor.OnError"/>.
            </summary>
        </member>
        <member name="F:CK.Core.SystemActivityMonitor.LowLevelErrorEventArgs.ErrorMessage">
            <summary>
            The error message. Never null nor empty.
            </summary>
        </member>
        <member name="F:CK.Core.SystemActivityMonitor.LowLevelErrorEventArgs.FullLogFilePath">
            <summary>
            Not null if the <see cref="F:CK.Core.SystemActivityMonitor.LowLevelErrorEventArgs.ErrorMessage"/> has been successfully written (if <see cref="P:CK.Core.SystemActivityMonitor.RootLogPath"/> is set).
            Contains the full path of the log file.
            </summary>
        </member>
        <member name="F:CK.Core.SystemActivityMonitor.LowLevelErrorEventArgs.ErrorWhileWritingLogFile">
            <summary>
            Exception raised while attempting to create the error file.
            This could be used to handle configuration error: an exception here means that something is going really wrong.
            </summary>
        </member>
        <member name="T:CK.Core.AppSettings">
            <summary>
            Very simple facade for simple application settings.
            This does not handle multiple configurations per key (like ConfigurationManager.AppSettings can do since it is a NameValueCollection) but
            can expose potentially complex configuration objects instead of only strings.
            It can be initialized only once, before any other access, and when not initialized tries to automatically use the standard ConfigurationManager.AppSettings 
            through late binding. However, it supports multiple overriding and reverting to the original configuration. 
            (Override support and restoration is mainly designed for tests but the override functionality alone can be a useful feature in real life application.)
            </summary>
        </member>
        <member name="F:CK.Core.AppSettings.Default">
            <summary>
            Gets the default, singleton, AppSettings object.
            </summary>
        </member>
        <member name="M:CK.Core.AppSettings.Initialize(System.Func{System.String,System.Object})">
            <summary>
            Initializes this <see cref="T:CK.Core.AppSettings"/> object. This can be called only once
            prior to any use of this object.
            When not called before the first access, the .Net ConfigurationManager.AppSettings is used if possible (late binding).
            </summary>
            <param name="getConfigurationObject">The function that ultimately </param>
        </member>
        <member name="M:CK.Core.AppSettings.Override(System.Func{System.Func{System.String,System.Object},System.String,System.Object})">
            <summary>
            Overrides this <see cref="T:CK.Core.AppSettings"/> object configuration function. This can be called after <see cref="M:CK.Core.AppSettings.Initialize(System.Func{System.String,System.Object})"/> or <see cref="M:CK.Core.AppSettings.DefaultInitialize"/>
            or directly: any access to the configuration since any access triggers a call to DefaultInitialize.
            The function that overrides the current configuration is called with the previously active function to enable chaining (filtering, alteration of the keys and or the values).
            </summary>
            <param name="filterConfigurationObject">The function that ultimately </param>
        </member>
        <member name="M:CK.Core.AppSettings.RevertOverrides">
            <summary>
            Reverts all calls to <see cref="M:CK.Core.AppSettings.Override(System.Func{System.Func{System.String,System.Object},System.String,System.Object})"/>: the initial configuration is restored.
            </summary>
        </member>
        <member name="M:CK.Core.AppSettings.DefaultInitialize">
            <summary>
            Automatically bind to standard ConfigurationManager.AppSettings to obtain configuration strings.
            This method is automatically called when this object is not yet initialized on any access other than <see cref="M:CK.Core.AppSettings.Initialize(System.Func{System.String,System.Object})"/>.
            </summary>
        </member>
        <member name="M:CK.Core.AppSettings.Get(System.String)">
            <summary>
            Gets the settings as an object.
            </summary>
            <param name="key">The configuration key.</param>
            <returns>The configured available object or null if no such configuration exists.</returns>
        </member>
        <member name="M:CK.Core.AppSettings.Get``1(System.String,``0)">
            <summary>
            Gets the settings as a typed object: if the object is not available or is not of the given type, the default value is returned;
            </summary>
            <param name="key">The configuration key.</param>
            <param name="defaultValue">The default value to return if no object exists.</param>
            <returns>The configured available object or the <paramref name="defaultValue"/> if no such configuration exists.</returns>
        </member>
        <member name="M:CK.Core.AppSettings.GetRequired(System.String)">
            <summary>
            Gets the settings as an object: if the object is not available, an exception is thrown.
            </summary>
            <param name="key">The configuration key.</param>
            <returns>The configured available object.</returns>
        </member>
        <member name="M:CK.Core.AppSettings.GetRequired``1(System.String)">
            <summary>
            Gets the settings as a typed object: if the object is not available or is not of the given type, an exception is thrown.
            </summary>
            <param name="key">The configuration key.</param>
            <returns>The configured available object.</returns>
        </member>
        <member name="P:CK.Core.AppSettings.Item(System.String)">
            <summary>
            Gets the settings as a string: <see cref="M:System.Object.ToString"/> is called on object.
            Null if the key is not found.
            </summary>
            <param name="key">The configuration key.</param>
            <returns>The string (object expressed as a string) or null if no such configuration exists.</returns>
        </member>
        <member name="T:CK.Core.CKException">
            <summary>
            Basic <see cref="T:System.Exception"/> that eases message formatting thanks to its contructors
            and provides an Exception wrapper around <see cref="T:CK.Core.CKExceptionData"/>.
            </summary>
        </member>
        <member name="M:CK.Core.CKException.#ctor(System.String)">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKException"/>.
            </summary>
            <param name="message">Simple message.</param>
        </member>
        <member name="M:CK.Core.CKException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKException"/>.
            </summary>
            <param name="message">Simple message.</param>
            <param name="innerException">Exception that caused this one.</param>
        </member>
        <member name="M:CK.Core.CKException.#ctor(System.String,System.Object[])">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKException"/>.
            </summary>
            <param name="messageFormat">Format string with optional placeholders.</param>
            <param name="args">Varying number of arguments to format.</param>
        </member>
        <member name="M:CK.Core.CKException.#ctor(System.Exception,System.String,System.Object[])">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKException"/> with an <see cref="P:System.Exception.InnerException"/>.
            </summary>
            <param name="innerException">Exception that caused this one.</param>
            <param name="messageFormat">Format string with optional placeholders.</param>
            <param name="args">Varying number of arguments to format.</param>
        </member>
        <member name="M:CK.Core.CKException.#ctor(CK.Core.CKExceptionData)">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKException"/> with an <see cref="P:CK.Core.CKException.ExceptionData"/>.
            The message of this exception is the <see cref="P:CK.Core.CKExceptionData.Message"/>.
            Use the static <see cref="M:CK.Core.CKException.CreateFrom(CK.Core.CKExceptionData)"/> to handle null data (a null CKException will be returned).
            </summary>
            <param name="data">The exception data. Must not be null.</param>
        </member>
        <member name="M:CK.Core.CKException.CreateFrom(CK.Core.CKExceptionData)">
            <summary>
            Creates a <see cref="T:CK.Core.CKException"/> from a <see cref="T:CK.Core.CKExceptionData"/>. This method returns null when data is null.
            This is the symmetric of <see cref="M:CK.Core.CKExceptionData.CreateFrom(System.Exception)"/>.
            </summary>
            <param name="data">Data of an exception for which a <see cref="T:CK.Core.CKException"/> wrapper must be created. Can be null: null is returned.</param>
            <returns>The exception that wraps the data.</returns>
        </member>
        <member name="M:CK.Core.CKException.EnsureExceptionData">
            <summary>
            If <see cref="P:CK.Core.CKException.ExceptionData"/> is null, this method creates the <see cref="T:CK.Core.CKExceptionData"/> with the details
            from this exception.
            </summary>
            <returns>The <see cref="T:CK.Core.CKExceptionData"/> that describes this exception.</returns>
        </member>
        <member name="P:CK.Core.CKException.ExceptionData">
            <summary>
            Gets the <see cref="T:CK.Core.CKExceptionData"/> if it exists: use <see cref="M:CK.Core.CKException.EnsureExceptionData"/> to 
            create if this is null, a data that describes this exception.
            </summary>
        </member>
        <member name="T:CK.Core.CKException.SerialData">
            <summary>
            Implements the ISafeSerializationData interface: this is the recommended way starting with .Net 4 
            to be able to use this in partially trusted environment (the GetObjectData method is now marked with the SecurityCriticalAttribute).
            </summary>
        </member>
        <member name="F:CK.Core.CKException.SerialData.ExData">
            <summary>
            The exception data from <see cref="T:CK.Core.CKException"/> that must be serialized.
            </summary>
        </member>
        <member name="T:CK.Core.CKExceptionData">
            <summary>
            Immutable and serializable representation of an exception.
            It contains specific data for some exceptions that, based on our experience, are actually interesting.
            </summary>
        </member>
        <member name="M:CK.Core.CKExceptionData.#ctor(System.String,System.String,System.String,System.String,CK.Core.CKExceptionData,System.String,System.String,CK.Core.CKExceptionData[],CK.Core.CKExceptionData[])">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKExceptionData"/> with all its fields.
            Use the factory method <see cref="M:CK.Core.CKExceptionData.CreateFrom(System.Exception)"/> to create a data from any exception.
            </summary>
            <param name="message">Message of the exception. Must not be null.</param>
            <param name="exceptionTypeName">Type name of the exception (no namespace nor assembly). Must not be null nor empty..</param>
            <param name="exceptionTypeAssemblyQualifiedName">Full type name of the exception. Must not be null nor empty.</param>
            <param name="stackTrace">Stack trace. Can be null.</param>
            <param name="innerException">Inner exception. If <paramref name="aggregatedExceptions"/> is not null, it must be the same as the first aggregated exceptions.</param>
            <param name="fileName">File name related to the exception (if it makes sense). Can be null.</param>
            <param name="fusionLog">Fusion log. <see cref="P:CK.Core.CKExceptionData.FusionLog"/>.</param>
            <param name="loaderExceptions">Loader exceptions. <see cref="P:CK.Core.CKExceptionData.LoaderExceptions"/>.</param>
            <param name="aggregatedExceptions">Aggregated exceptions can be null. Otherwise, it must contain at least one exception.</param>
        </member>
        <member name="M:CK.Core.CKExceptionData.#ctor(System.IO.BinaryReader)">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKExceptionData"/> from a <see cref="T:System.IO.BinaryReader"/>. 
            See <see cref="M:CK.Core.CKExceptionData.Write(System.IO.BinaryWriter)"/>.
            </summary>
            <param name="r">The reader to read from.</param>
        </member>
        <member name="M:CK.Core.CKExceptionData.CreateFrom(System.Exception)">
            <summary>
            Creates a <see cref="T:CK.Core.CKExceptionData"/> from any <see cref="T:System.Exception"/>.
            </summary>
            <param name="ex">Exception for which data must be created. Can be null: null is returned.</param>
            <returns>The data that describes the exception.</returns>
        </member>
        <member name="M:CK.Core.CKExceptionData.Write(System.IO.BinaryWriter)">
            <summary>
            Writes this exception data into a <see cref="T:System.IO.BinaryWriter"/>.
            </summary>
            <param name="w">The writer to use. Can not be null.</param>
        </member>
        <member name="M:CK.Core.CKExceptionData.ToTextWriter(System.IO.TextWriter,System.String,System.String)">
            <summary>
            Writes the exception data as a readable block of text into a <see cref="T:System.IO.TextWriter"/>.
            </summary>
            <param name="w">The TextWriter to write to.</param>
            <param name="prefix">Prefix that will appear at the start of each line.</param>
            <param name="newLine">Defaults to <see cref="P:System.Environment.NewLine"/>.</param>
        </member>
        <member name="M:CK.Core.CKExceptionData.ToStringBuilder(System.Text.StringBuilder,System.String,System.String)">
            <summary>
            Writes the exception data as a readable block of text into a <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="b">The StringBuilder to write to.</param>
            <param name="prefix">Prefix that will appear at the start of each line.</param>
            <param name="newLine">Defaults to <see cref="P:System.Environment.NewLine"/>.</param>
        </member>
        <member name="M:CK.Core.CKExceptionData.WriteText(System.Action{System.String},System.String,System.String)">
            <summary>
            Core function that writes the exception data as a readable block of text.
            </summary>
            <param name="appender">The function that collects the text fragments.</param>
            <param name="prefix">Prefix that will appear at the start of each line.</param>
            <param name="newLine">Defaults to <see cref="P:System.Environment.NewLine"/>.</param>
        </member>
        <member name="M:CK.Core.CKExceptionData.ToString">
            <summary>
            Overridden to return the result of <see cref="M:CK.Core.CKExceptionData.WriteText(System.Action{System.String},System.String,System.String)"/> without prefix and a standard <see cref="P:System.Environment.NewLine"/>.
            This is cached once built.
            </summary>
            <returns>This exception data as a block of readable text.</returns>
        </member>
        <member name="P:CK.Core.CKExceptionData.Message">
            <summary>
            Gets the message of the exception. Never null but can be empty.
            </summary>
        </member>
        <member name="P:CK.Core.CKExceptionData.ExceptionTypeAssemblyQualifiedName">
            <summary>
            Gets the assembly qualified exception type name. Never null nor empty.
            </summary>
        </member>
        <member name="P:CK.Core.CKExceptionData.ExceptionTypeName">
            <summary>
            Gets the exception type name. Never null nor empty.
            </summary>
        </member>
        <member name="P:CK.Core.CKExceptionData.StackTrace">
            <summary>
            Gets the stack trace. Can be null.
            </summary>
        </member>
        <member name="P:CK.Core.CKExceptionData.InnerException">
            <summary>
            Gets the inner exception if it exists.
            If <see cref="P:CK.Core.CKExceptionData.AggregatedExceptions"/> is not null, it is the same as the first aggreated exceptions.
            </summary>
        </member>
        <member name="P:CK.Core.CKExceptionData.FileName">
            <summary>
            Gets the file name if the exception is referring to a file. 
            Null otherwise.
            </summary>
        </member>
        <member name="P:CK.Core.CKExceptionData.FusionLog">
            <summary>
            Gets the fusion log if the exception is a <see cref="T:System.IO.FileNotFoundException"/> or a <see cref="T:System.IO.FileLoadException"/> that was raised
            while dynamically loading a type or an assembly. 
            Null otherwise.
            </summary>
        </member>
        <member name="P:CK.Core.CKExceptionData.LoaderExceptions">
            <summary>
            Gets all the the exceptions that occurred while dynamically loading a type or an assembly if the exception is a <see cref="T:System.Reflection.ReflectionTypeLoadException"/>.
            Null otherwise.
            </summary>
        </member>
        <member name="P:CK.Core.CKExceptionData.AggregatedExceptions">
            <summary>
            Gets all the the aggregated exceptions if the exception is a <see cref="T:System.AggregateException"/>.
            This corresponds to the <see cref="P:System.AggregateException.InnerExceptions"/> property.
            Null if this exception is not a an AggregatedException.
            </summary>
        </member>
        <member name="T:CK.Core.CKComponentModelExtension">
            <summary>
            Provides extension methods for system/component model interfaces.
            </summary>
        </member>
        <member name="M:CK.Core.CKComponentModelExtension.GetService``1(System.IServiceProvider,System.Boolean)">
            <summary>
            Strongly typed version of <see cref="M:System.IServiceProvider.GetService(System.Type)"/>.
            </summary>
            <param name="this">This service provider.</param>
            <param name="throwOnNull">True to throw an exception if the service can not be provided (otherwise null is returned).</param>
            <returns>A service object of the required type or null if not found and <paramref name="throwOnNull"/> is false.</returns>
        </member>
        <member name="M:CK.Core.CKComponentModelExtension.GetService``1(System.IServiceProvider)">
            <summary>
            Strongly typed version of <see cref="M:System.IServiceProvider.GetService(System.Type)"/> that returns null if service is not found.
            (Same behavior as <see cref="M:System.IServiceProvider.GetService(System.Type)"/>.)
            </summary>
            <param name="this">This service provider.</param>
            <returns>A service object of the required type or null if not found.</returns>
        </member>
        <member name="M:CK.Core.CKComponentModelExtension.Add``1(CK.Core.ISimpleServiceContainer,``0)">
            <summary>
            Type safe version to register a service implementation (type of the service is the type of the implementation).
            </summary>
            <param name="this">This <see cref="T:CK.Core.ISimpleServiceContainer"/> object.</param>
            <param name="serviceInstance">Implementation of the service. Can not be null.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.CKComponentModelExtension.Add``1(CK.Core.ISimpleServiceContainer,``0,System.Action{``0})">
            <summary>
            Type safe version to register a service implementation (type of the service is the type of the implementation), 
            and an optional callback that will be called when the service will be removed.
            </summary>
            <param name="this">This <see cref="T:CK.Core.ISimpleServiceContainer"/> object.</param>
            <param name="serviceInstance">Implementation of the service. Can not be null.</param>
            <param name="onRemove">Optional action that will be called whenever <see cref="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.ISimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.CKComponentModelExtension.Add``1(CK.Core.ISimpleServiceContainer,System.Func{``0})">
            <summary>
            Type safe version to register a service associated to a callback.
            The <paramref name="serviceInstance"/> is called as long as no service has been obtained (serviceInstance returns null). 
            Once the actual service has been obtained, it is kept and serviceInstance is not called anymore.
            </summary>
            <param name="this">This <see cref="T:CK.Core.ISimpleServiceContainer"/> object.</param>
            <param name="serviceInstance">Delegate to call when needed. Can not be null.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.CKComponentModelExtension.Add``1(CK.Core.ISimpleServiceContainer,System.Func{``0},System.Action{``0})">
            <summary>
            Type safe version to register a service associated to a callback (and an optional callback that will be called when the service will be removed).
            The <paramref name="serviceInstance"/> is called as long as no service has been obtained (serviceInstance returns null). 
            Once the actual service has been obtained, it is kept and serviceInstance is not called anymore.
            </summary>
            <param name="this">This <see cref="T:CK.Core.ISimpleServiceContainer"/> object.</param>
            <param name="serviceInstance">Delegate to call when needed. Can not be null.</param>
            <param name="onRemove">Optional action that will be called whenever <see cref="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.ISimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>
            is called and a service as been successfuly obtained.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="T:CK.Core.CKEnumerableConverter`2">
            <summary>
            Wraps a <see cref="T:System.Collections.IEnumerable"/> of a <typeparamref name="TOuter"/> type around a <see cref="T:System.Collections.IEnumerable"/>
            of <typeparamref name="TOuter"/> thanks to a conversion function.
            </summary>
            <typeparam name="TOuter">Type of the object that must be exposed.</typeparam>
            <typeparam name="TInner">Actual type of enumerated objects.</typeparam>
        </member>
        <member name="M:CK.Core.CKEnumerableConverter`2.#ctor(System.Collections.Generic.IEnumerable{`1},System.Converter{`1,`0})">
            <summary>
            Initializes a new adapter.
            </summary>
            <param name="c">Enumerable to wrap.</param>
            <param name="converter">Conversion function to apply.</param>
        </member>
        <member name="M:CK.Core.CKEnumerableConverter`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through this enumerable.
            </summary>
            <returns>A IEnumerator that can be used to iterate through this enumerable.</returns>
        </member>
        <member name="P:CK.Core.CKEnumerableConverter`2.Inner">
            <summary>
            Gets the wrapped enumerable.
            </summary>
        </member>
        <member name="P:CK.Core.CKEnumerableConverter`2.Converter">
            <summary>
            Gets the converter associated to this <see cref="T:CK.Core.CKEnumerableConverter`2"/>.
            </summary>
        </member>
        <member name="T:CK.Core.CKEnumerableConverter`2.EnumeratorAdapter">
            <summary>
            Internal implementation of the enumerator.
            </summary>
        </member>
        <member name="T:CK.Core.CKEnumeratorEmpty`1">
            <summary>
            Defines a unique empty enumerator.
            Use <see cref="F:CK.Core.CKReadOnlyListEmpty`1.Empty"/> singleton for an empty <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="F:CK.Core.CKEnumeratorEmpty`1.Empty">
            <summary>
            Gets the default <see cref="T:CK.Core.CKEnumeratorEmpty`1"/>.
            This field is static readonly and is thread safe by design.
            </summary>
        </member>
        <member name="M:CK.Core.CKEnumeratorEmpty`1.Dispose">
            <summary>
            Dispose the enumerator.
            </summary>
        </member>
        <member name="M:CK.Core.CKEnumeratorEmpty`1.MoveNext">
            <summary>
            Move to the next element of the enumerator.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CK.Core.CKEnumeratorEmpty`1.Reset">
            <summary>
            Reset the enumerator.
            </summary>
        </member>
        <member name="P:CK.Core.CKEnumeratorEmpty`1.Current">
            <summary>
            Gets the current element (the default value for the type of elements).
            </summary>
        </member>
        <member name="T:CK.Core.CKEnumeratorMono`1">
            <summary>
            Defines an optimized <see cref="T:System.Collections.Generic.IEnumerator`1"/> that contains
            only one element.
            </summary>
        </member>
        <member name="M:CK.Core.CKEnumeratorMono`1.#ctor(`0)">
            <summary>
            Constructor
            </summary>
            <param name="val">Unique object that will be contained into the <see cref="T:CK.Core.CKEnumeratorMono`1"/></param>
        </member>
        <member name="M:CK.Core.CKEnumeratorMono`1.Dispose">
            <summary>
            Dispose the <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
        </member>
        <member name="M:CK.Core.CKEnumeratorMono`1.MoveNext">
            <summary>
            Move to the next element.
            </summary>
            <returns>True if position is equal to 0, false otherwise</returns>
        </member>
        <member name="M:CK.Core.CKEnumeratorMono`1.Reset">
            <summary>
            Reset the enumerator.
            </summary>
        </member>
        <member name="P:CK.Core.CKEnumeratorMono`1.Current">
            <summary>
            Gets the strongly typed element in the collection at the current position of the enumerator.
            </summary>
        </member>
        <member name="T:CK.Core.CKObservableSortedArrayKeyList`2">
            <summary>
            A <see cref="T:CK.Core.CKSortedArrayKeyList`2"/> that implements <see cref="E:CK.Core.CKObservableSortedArrayKeyList`2.CollectionChanged"/> and <see cref="E:CK.Core.CKObservableSortedArrayKeyList`2.PropertyChanged"/> events
            in order to be an observable list.
            </summary>
        </member>
        <member name="T:CK.Core.CKSortedArrayKeyList`2">
            <summary>
            Sorted list of items where the sort order relies on an external key, not the item itself.
            </summary>.
        </member>
        <member name="T:CK.Core.CKSortedArrayList`1">
            <summary>
            Simple sorted array list implementation that supports covariance through <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> and contra-variance 
            with <see cref="T:CK.Core.ICKWritableCollection`1"/>. This is a "dangerous" class since to keep the correct ordering, <see cref="M:CK.Core.CKSortedArrayList`1.CheckPosition(System.Int32)"/> 
            must be explicitly called whenever something changes on any item that impacts the <see cref="F:CK.Core.CKSortedArrayList`1.Comparator"/> result.
            See the remarks for other caveats.
            </summary>
            <remarks>
            <para>
            This class implements <see cref="T:System.Collections.Generic.IList`1"/> both for performance (unfortunately Linq relies -too much- on it) and for interoperability reasons: this
            interface should NOT be used. Accessors of the <see cref="T:System.Collections.Generic.IList`1"/> that defeats the invariant of this class (the fact that elements are sorted, such 
            as <see cref="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)"/>) are explicitly implemented to hide them as much as possible.
            </para>
            <para>
            This is the base class for <see cref="T:CK.Core.CKSortedArrayKeyList`2"/> but also for their observable versions: <see cref="T:CK.Core.CKObservableSortedArrayList`1"/> 
            and <see cref="T:CK.Core.CKObservableSortedArrayKeyList`2"/>.
            </para>
            <para>
            Specialized classes may use protected <see cref="P:CK.Core.CKSortedArrayList`1.Store"/>, <see cref="P:CK.Core.CKSortedArrayList`1.StoreCount"/> and <see cref="P:CK.Core.CKSortedArrayList`1.StoreVersion"/> to have a direct, uncontrolled, access
            to the whole state of this object.
            </para>
            </remarks>
        </member>
        <member name="T:CK.Core.ICKReadOnlyList`1">
            <summary>
            Represents a read only collection of objects that can be individually accessed by index.
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="T:CK.Core.ICKReadOnlyCollection`1">
            <summary>
            Represents a generic read only collections of objects with a contravariant <see cref="M:CK.Core.ICKReadOnlyCollection`1.Contains(System.Object)"/> method.
            This enables collection implementing this interface to support better lookup complexity than O(n) if possible. 
            </summary>
            <typeparam name="T">The type of the elements in the collection.</typeparam>
        </member>
        <member name="T:System.Collections.Generic.IReadOnlyCollection`1">
            <summary>
            Represents a generic read only collections of objects.
            This interface is only defined for framework 3.5 or 4.0. The same System.Collections.Generic.IReadOnlyCollection
            has been defined in the .Net framework 4.5.
            Previous versions exposed a "contravariant" Contains( object ) method now transfered to ICKReadOnlyCollection.
            It has been removed in order to fit the 4.5 definition.
            </summary>
            <typeparam name="T">The type of the elements in the collection.</typeparam>
        </member>
        <member name="P:System.Collections.Generic.IReadOnlyCollection`1.Count">
            <summary>
            Gets the number of elements contained in the collection.
            </summary>
        </member>
        <member name="M:CK.Core.ICKReadOnlyCollection`1.Contains(System.Object)">
            <summary>
            Determines whether collection contains a specific value.
            </summary>
            <param name="item">The object to find in the collecion.</param>
            <returns>True if item is found in the collection; otherwise, false.</returns>
        </member>
        <member name="T:System.Collections.Generic.IReadOnlyList`1">
            <summary>
            Represents a read only collection of objects that can be individually accessed by index.
            This interface is only defined for framework 3.5 or 4.0. The same System.Collections.Generic.IReadOnlyList
            has been defined in the .Net framework 4.5.
            Previous versions exposed a "contravariant" IndexOf( object ) method now transfered to ICKReadOnlyList.
            It has been removed in order to fit the 4.5 definition.
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="P:System.Collections.Generic.IReadOnlyList`1.Item(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="index"/> is not a valid index in the list.</exception>
        </member>
        <member name="M:CK.Core.ICKReadOnlyList`1.IndexOf(System.Object)">
            <summary>
            Determines the index of a specific item in the list.
            </summary>
            <param name="item">The object to locate in the list.</param>
            <returns>
            A positive index of the item in this list, if found, a negative index otherwise.
            If this list is sorted, this must work exactly like <see cref="M:System.Array.BinarySearch(System.Array,System.Object)"/>: if the item is not found and could be added, the result 
            is a negative number which is the bitwise complement of the index at which the new item should be inserted.
            To handle the case where the item can NOT be inserted and to be consistent with the positive/negative index semantics, the <see cref="F:System.Int32.MinValue"/>
            must be returned. See remarks.
            </returns>
            <remarks>
            <para>
            The fact that <see cref="F:System.Int32.MinValue"/> is used to indicate an "impossible index" enables this covariant list to gracefully handle 
            the case where the item's type is more general that the actual type list.
            </para>
            <para>
            Similarly, if the implementation is associated to any kind of filters, returning <see cref="F:System.Int32.MinValue"/> instead of any other negative value
            indicates to the caller that the item does not appear in the list, but more than that, that it CAN NOT appear.
            </para>
            <para>
            Note that an implementation can perfectly ignore these guidelines and returns -1 (typically) for any unexisting items: it is not an obligation
            to challenge any possible filters or constraints inside this IndexOf method.
            </para>
            <para>
            On the other hand, if this method returns <see cref="F:System.Int32.MinValue"/> then it MUST mean that the item can NOT appear in this list.
            </para>
            </remarks>
        </member>
        <member name="T:CK.Core.ICKWritableCollection`1">
            <summary>
            Contravariant interface for a collection that allows to <see cref="M:CK.Core.ICKWritableCollection`1.Clear"/> and <see cref="M:CK.Core.ICKWritableCollection`1.Remove(`0)"/>
            element.
            </summary>
            <typeparam name="T">Base type for the elements of the collection.</typeparam>
        </member>
        <member name="T:CK.Core.ICKWritableCollector`1">
            <summary>
            Contravariant interface for a collector: one can only add elements to a collector and know how muwh elements
            there are (Note that if you do not need the <see cref="P:CK.Core.ICKWritableCollector`1.Count"/>, you should use a simple Fun&lt;T,bool&gt;).
            </summary>
            <typeparam name="T">Base type for the elements of the collector.</typeparam>
        </member>
        <member name="M:CK.Core.ICKWritableCollector`1.Add(`0)">
            <summary>
            Adds an element to the collection. The exact behavior of this operation
            depends on the concrete implementation (duplicates, filters, etc.).
            </summary>
            <param name="e">Element to add.</param>
            <returns>True if the element has been added, false otherwise.</returns>
        </member>
        <member name="P:CK.Core.ICKWritableCollector`1.Count">
            <summary>
            Gets the count of elements in the collection.
            </summary>
        </member>
        <member name="M:CK.Core.ICKWritableCollection`1.Clear">
            <summary>
            Clears the collection.
            </summary>
        </member>
        <member name="M:CK.Core.ICKWritableCollection`1.Remove(`0)">
            <summary>
            Removes the element if it exists.
            </summary>
            <param name="e">Element to remove.</param>
            <returns>True if the element has been removed, false otherwise.</returns>
        </member>
        <member name="F:CK.Core.CKSortedArrayList`1.Comparator">
            <summary>
            Specialized implementation can use this comparison function if needed.
            </summary>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.#ctor">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKSortedArrayList`1"/> that rejects duplicates 
            and uses the <see cref="P:System.Collections.Generic.Comparer`1.Default"/> comparer.
            </summary>
            <remarks>
            A default constructor is a parameterless constructor, it is not the same as a constructor with default parameter values.
            This is why it is explicitly defined.
            </remarks>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.#ctor(System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKSortedArrayList`1"/> that rejects or allows duplicates 
            and uses the <see cref="P:System.Collections.Generic.Comparer`1.Default"/> comparer.
            </summary>
            <param name="allowDuplicates">True to allow duplicate elements.</param>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.#ctor(System.Collections.Generic.IComparer{`0},System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKSortedArrayList`1"/> that rejects or allows duplicates 
            and uses the given comparer.
            </summary>
            <param name="comparer">Comparer to use.</param>
            <param name="allowDuplicates">True to allow duplicate elements.</param>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.#ctor(System.Comparison{`0},System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKSortedArrayList`1"/> that rejects or allows duplicates 
            and uses the given comparison function.
            </summary>
            <param name="comparison">Comparison function to use.</param>
            <param name="allowDuplicates">True to allow duplicate elements.</param>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Explicitly implemented since our <see cref="M:CK.Core.CKSortedArrayList`1.Add(`0)"/> method
            returns a boolean.
            </summary>
            <param name="item">Item to add.</param>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.IndexOf(`0)">
            <summary>
            Locates an element (one of the occurrences when duplicates are allowed) in this list (logarithmic). 
            </summary>
            <param name="value">The element.</param>
            <returns>The result of the <see cref="G:Util.BinarySearch{T}"/> in the internal array.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.IndexOf``1(``0,System.Func{`0,``0,System.Int32})">
            <summary>
            Binary search implementation that relies on an extended comparer: a function that knows how to 
            compare the elements of the array to its key. This function must work exactly like this <see cref="F:CK.Core.CKSortedArrayList`1.Comparator"/>
            but accepts a <typeparamref name="T"/> and the <typeparamref name="TKey"/> that is used to sort the items otherwise
            the result is undefined.
            </summary>
            <typeparam name="TKey">Type of the key.</typeparam>
            <param name="key">The value of the key.</param>
            <param name="comparison">The comparison function.</param>
            <returns>Same as <see cref="M:System.Array.BinarySearch(System.Array,System.Object)"/>: negative index if not found which is the bitwise complement of (the index of the next element plus 1).</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.Contains(`0)">
            <summary>
            Determines whether this <see cref="T:CK.Core.CKSortedArrayList`1"/> contains a specific value (logarithmic).
            </summary>
            <param name="value">The value.</param>
            <returns>True if the object is found; otherwise, false.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.IndexOf(System.Object)">
            <summary>
            Covariant compatible overload of <see cref="M:CK.Core.CKSortedArrayList`1.IndexOf(`0)"/>  (logarithmic).
            If the item is not <typeparamref name="T"/> compatible, the 
            value <see cref="F:System.Int32.MinValue"/> is returned. See <see cref="M:CK.Core.ICKReadOnlyList`1.IndexOf(System.Object)"/>.
            </summary>
            <param name="item">The item to locate.</param>
            <returns>
            Positive index when found, negative one when not found and <see cref="F:System.Int32.MinValue"/> 
            if the item can structurally NOT appear in this list.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.Contains(System.Object)">
            <summary>
            Covariant compatible overload of <see cref="M:CK.Core.CKSortedArrayList`1.Contains(`0)"/>  (logarithmic).
            </summary>
            <param name="item">The item to find.</param>
            <returns>True if the object is found; otherwise, false.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy the content of the internal array into the given array.
            </summary>
            <param name="array">Destination array.</param>
            <param name="arrayIndex">Index at which copying must start.</param>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.Remove(`0)">
            <summary>
            Removes a value and returns true if found; otherwise returns false.
            </summary>
            <param name="value">The value to remove.</param>
            <returns>True if the value has been found and removed, false otherwise.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.System#Collections#Generic#IList{T}#Insert(System.Int32,`0)">
            <summary>
            Explicit implementation to hide it as much as possible. 
            It calls the protected virtual <see cref="M:CK.Core.CKSortedArrayList`1.DoInsert(System.Int32,`0)"/> method
            that does the job of actually inserting the item at the given index... 
            even if this breaks the sort.
            </summary>
            <param name="index">Future index of the item.</param>
            <param name="value">Item to insert.</param>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.Add(`0)">
            <summary>
            Adds the item at its right position depending on the comparison function and returns true.
            May return false if, for any reason, the item has not been added. At this level (but this 
            may be overridden), if <see cref="P:CK.Core.CKSortedArrayList`1.AllowDuplicates"/> is false and the item already exists,
            false is returned and the item is not added.
            </summary>
            <param name="value">Item to add.</param>
            <returns>True if the item has actually been added; otherwise false.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item at the given position.
            </summary>
            <param name="index">Index to remove.</param>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.Clear">
            <summary>
            Clears the list.
            </summary>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.CheckPosition(System.Int32)">
            <summary>
            Checks that the item at the given index is between a lesser and a greater item and if not, 
            moves the item at its correct index.
            If the new index conflicts because <see cref="P:CK.Core.CKSortedArrayList`1.AllowDuplicates"/> is false (the default), a 
            negative value is returned, otherwise the new positive index is returned.
            </summary>
            <param name="index">Index of the element to check.</param>
            <returns>
            The new positive index if the position has been successfully updated, or a negative value
            if a duplicate exists (and <see cref="P:CK.Core.CKSortedArrayList`1.AllowDuplicates"/> is false).
            </returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.DoSet(System.Int32,`0)">
            <summary>
            Sets a value at a given position.
            </summary>
            <param name="index">The position to set.</param>
            <param name="newValue">The new item to inject.</param>
            <returns>The previous item at the position.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.DoInsert(System.Int32,`0)">
            <summary>
            Inserts a new item.
            </summary>
            <param name="index">Index to insert.</param>
            <param name="value">Item to insert.</param>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.DoClear">
            <summary>
            Clears the list.
            </summary>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.DoRemoveAt(System.Int32)">
            <summary>
            Removes the item at a given position.
            </summary>
            <param name="index">Index to remove.</param>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.DoMove(System.Int32,System.Int32)">
            <summary>
            Moves an item from a position to another one.
            </summary>
            <param name="from">Old index of the item.</param>
            <param name="newIndex">New index.</param>
            <returns>The new index of the element.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.GetEnumerator">
            <summary>
            Gets an enumerator.
            </summary>
            <returns></returns>
        </member>
        <member name="P:CK.Core.CKSortedArrayList`1.AllowDuplicates">
            <summary>
            Gets whether this list allows duplicated items.
            </summary>
        </member>
        <member name="P:CK.Core.CKSortedArrayList`1.Count">
            <summary>
            Gets the number of elements in this sorted list.
            </summary>
        </member>
        <member name="P:CK.Core.CKSortedArrayList`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Explicit implementation that always returns false.
            </summary>
        </member>
        <member name="P:CK.Core.CKSortedArrayList`1.Capacity">
            <summary>
            Gets or sets the current capacity of the internal array.
            When setting it, if the new capacity is less than the current <see cref="P:CK.Core.CKSortedArrayList`1.Count"/>, 
            an <see cref="T:System.ArgumentException"/> is thrown.
            </summary>
        </member>
        <member name="P:CK.Core.CKSortedArrayList`1.Item(System.Int32)">
            <summary>
            Gets the object at the given index.
            </summary>
            <param name="index">Zero based position of the item in this list.</param>
            <returns>The item.</returns>
        </member>
        <member name="P:CK.Core.CKSortedArrayList`1.System#Collections#Generic#IList{T}#Item(System.Int32)">
            <summary>
            Explicit implementation to hide it as much as possible. 
            The setter calls the protected virtual <see cref="M:CK.Core.CKSortedArrayList`1.DoSet(System.Int32,`0)"/> method
            that does the job of actually setting the item at the given index... 
            even if this breaks the sort.
            </summary>
            <param name="index">Index of the item.</param>
            <returns>The item.</returns>
        </member>
        <member name="P:CK.Core.CKSortedArrayList`1.Store">
            <summary>
            Direct access to the internal array to specialized classes.
            This must be used with care.
            </summary>
        </member>
        <member name="P:CK.Core.CKSortedArrayList`1.StoreCount">
            <summary>
            Direct access to the <see cref="P:CK.Core.CKSortedArrayList`1.Count"/> to specialized classes.
            This must be used with care.
            </summary>
        </member>
        <member name="P:CK.Core.CKSortedArrayList`1.StoreVersion">
            <summary>
            Direct access to the internal version to specialized classes.
            LSB (StoreVersion &amp;  1) is <see cref="P:CK.Core.CKSortedArrayList`1.AllowDuplicates"/>: the version 
            is incremented by two whenever the content change.
            This must be used with care.
            </summary>
        </member>
        <member name="T:CK.Core.ICKReadOnlyMultiKeyedCollection`2">
            <summary>
            Represents a generic read only keyed collections of covariant items with
            a contravariant key that can support duplicate items.
            </summary>
            <typeparam name="T">The type of the elements in the collection.</typeparam>
            <typeparam name="TKey">The type of the key associated to the elements.</typeparam>
        </member>
        <member name="T:CK.Core.ICKReadOnlyUniqueKeyedCollection`2">
            <summary>
            Represents a generic read only keyed collections of covariant items with
            a contravariant key. This interface can be supported by collections that 
            support duplicated items.
            </summary>
            <typeparam name="T">The type of the elements in the collection.</typeparam>
            <typeparam name="TKey">The type of the key associated to the elements.</typeparam>
        </member>
        <member name="M:CK.Core.ICKReadOnlyUniqueKeyedCollection`2.Contains(`1)">
            <summary>
            Checks whether any item in this keyed collection is associated to the
            given key value.
            </summary>
            <param name="key">The key to find.</param>
            <returns>True if the key exists, false otherwise.</returns>
        </member>
        <member name="M:CK.Core.ICKReadOnlyUniqueKeyedCollection`2.GetByKey(`1,System.Boolean@)">
            <summary>
            Gets the item with the associated key.
            When duplicated item exists, any item with the given key can be returned.
            </summary>
            <param name="key">The item key.</param>
            <param name="exists">True if the key has been found, false otherwise (see remarks).</param>
            <returns>The item that matches the key, default(T) if the key can not be found.</returns>
            <remarks>
            Due to current CLI limitation (out parameters are actually ref parameters), it is not possible 
            to define a method with an ( out T ) parameter where T is covariant: we can not define 
            the standard TryGetValue method but this "opposite" form.
            </remarks>
        </member>
        <member name="M:CK.Core.ICKReadOnlyMultiKeyedCollection`2.KeyCount(`1)">
            <summary>
            Gets the number of items in this keyed collection that are associated to the
            given key value.
            </summary>
            <param name="key">The key to find.</param>
            <returns>Number of items with the <paramref name="key"/>.</returns>
        </member>
        <member name="M:CK.Core.ICKReadOnlyMultiKeyedCollection`2.GetAllByKey(`1)">
            <summary>
            Gets an independant collection of the items that 
            are associated to the given key value.
            </summary>
            <param name="key">The key to find.</param>
            <returns>An independant collection of <typeparamref name="T"/>.</returns>
        </member>
        <member name="P:CK.Core.ICKReadOnlyMultiKeyedCollection`2.AllowDuplicates">
            <summary>
            Gets whether this collection supports duplicates.
            </summary>
        </member>
        <member name="M:CK.Core.CKSortedArrayKeyList`2.#ctor(System.Func{`0,`1},System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKSortedArrayKeyList`2"/>.
            </summary>
            <param name="keySelector">Function that associates a key to an item.</param>
            <param name="allowDuplicates">True to allow duplicates.</param>
        </member>
        <member name="M:CK.Core.CKSortedArrayKeyList`2.#ctor(System.Func{`0,`1},System.Comparison{`1},System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKSortedArrayKeyList`2"/> where a <see cref="T:System.Comparison`1"/> function
            is used to compare keys.
            </summary>
            <param name="keySelector">Function that associates a key to an item.</param>
            <param name="keyComparison">Function used to compare keys.</param>
            <param name="allowDuplicates">True to allow duplicates.</param>
        </member>
        <member name="M:CK.Core.CKSortedArrayKeyList`2.IndexOf(`1)">
            <summary>
            Gets the zero based position of on of the items that is associated to this key.
            </summary>
            <param name="key">The key to find.</param>
            <returns>The index or a negative value like <see cref="G:Util.BinarySearch{T,TKey}"/>.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayKeyList`2.Contains(`1)">
            <summary>
            True if this list contains at least one item with the given key.
            </summary>
            <param name="key">The key to find.</param>
            <returns>True if an item is found, false otherwise.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayKeyList`2.GetByKey(`1,System.Boolean@)">
            <summary>
            Gets the first item with a given key or the default value if no such item exist.
            </summary>
            <param name="key">The key.</param>
            <param name="exists">True if the key has been found, otherwise false.</param>
            <returns>The item or default(T) if not found.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayKeyList`2.KeyCount(`1)">
            <summary>
            Gets the number of items with a given key. It can be greater than 1 only if <see cref="P:CK.Core.CKSortedArrayList`1.AllowDuplicates">AllowDuplicates</see> is true.
            </summary>
            <param name="key">The key to find.</param>
            <returns>The number of item with the <paramref name="key"/>.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayKeyList`2.GetAllByKey(`1)">
            <summary>
            Gets an independent collection of the items that 
            are associated to the given key value.
            </summary>
            <param name="key">The key to find.</param>
            <returns>An independent collection of <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayKeyList`2.IndexOf(`0)">
            <summary>
            Gets the index of the element thanks to a linear search into the 
            internal array.
            If the key did not change, it is more efficient to find an element with <see cref="M:CK.Core.CKSortedArrayKeyList`2.IndexOf(`1)"/> that 
            uses a dichotomic search.
            </summary>
            <param name="value">The element to locate.</param>
            <returns>The index in array that, if found; otherwise, 1.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayKeyList`2.IndexOf(System.Object)">
            <summary>
            Covariant IndexOf method: if <paramref name="item"/> is of type <typeparamref name="T"/>
            the linear <see cref="M:CK.Core.CKSortedArrayKeyList`2.IndexOf(`0)"/> is used but if <paramref name="item"/> is of type <typeparamref name="TKey"/>,
            the logarithmic <see cref="M:CK.Core.CKSortedArrayKeyList`2.IndexOf(`1)"/> is used.
            </summary>
            <param name="item">Can be a <typeparamref name="T"/> or a <typeparamref name="TKey"/>.</param>
            <returns>The index of the item in the collection.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayKeyList`2.Contains(System.Object)">
            <summary>
            Covariant version of the contains predicate. 
            If <paramref name="item"/> is of type <typeparamref name="T"/> the <see cref="M:CK.Core.CKSortedArrayList`1.Contains(`0)"/> is used 
            but if <paramref name="item"/> is of type <typeparamref name="TKey"/>, the <see cref="M:CK.Core.CKSortedArrayKeyList`2.Contains(`1)"/> is used.
            </summary>
            <param name="item">Can be a <typeparamref name="T"/> or a <typeparamref name="TKey"/>.</param>
            <returns>True if a corresponding element in this list can be found.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayKeyList`2.Remove(`1)">
            <summary>
            Removes one item given a key: only one item is removed when <see cref="P:CK.Core.CKSortedArrayList`1.AllowDuplicates"/> is 
            true and more than one item are associated to this key.
            </summary>
            <param name="key">The key to remove.</param>
            <returns>True if an item has been removed, false otherwise.</returns>
        </member>
        <member name="P:CK.Core.CKSortedArrayKeyList`2.DebuggerView.Items">
            <summary>
            Gets the items as a flattened array view.
            </summary>
        </member>
        <member name="T:CK.Core.ICKObservableReadOnlyList`1">
            <summary>
            Definition of a <see cref="T:CK.Core.IObservableReadOnlyList`1"/> that extends <see cref="T:CK.Core.ICKReadOnlyList`1"/> (for the 
            contravariant <see cref="M:CK.Core.ICKReadOnlyCollection`1.Contains(System.Object)"/> and <see cref="M:CK.Core.ICKReadOnlyList`1.IndexOf(System.Object)"/> methods).
            It has no properties nor methods by itself: it is only here to federate its 2 real base interfaces (the <see cref="T:CK.Core.ICKObservableReadOnlyCollection`1"/> 
            enforces the fact that any list is actually a collection).
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="T:CK.Core.IObservableReadOnlyList`1">
            <summary>
            Definition of an <see cref="T:CK.Core.IObservableReadOnlyCollection`1"/> that is <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> (the index of the elements makes sense).
            This interface is "compatible" with the standard .Net <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/>: a specialization of ObservableCollection 
            that supports this interface does not need any extra code to be exposed as a true read only observable list.
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="T:CK.Core.IObservableReadOnlyCollection`1">
            <summary>
            Definition of a <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/> that is observable through <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> and <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>.
            It has no properties nor methods by itself: it is only here to federate its 3 base interfaces.
            This interface is "compatible" with the standard .Net <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/>: a specialization of ObservableCollection 
            that supports this interface does not need any extra code to be exposed as a true read only observable collection.
            </summary>
            <typeparam name="T">The type of elements in the collection.</typeparam>
        </member>
        <member name="T:CK.Core.ICKObservableReadOnlyCollection`1">
            <summary>
            Definition of a <see cref="T:CK.Core.IObservableReadOnlyCollection`1"/> that extends <see cref="T:CK.Core.ICKReadOnlyCollection`1"/> (for the 
            contravariant <see cref="M:CK.Core.ICKReadOnlyCollection`1.Contains(System.Object)"/> method).
            It has no properties nor methods by itself: it is only here to federate its 2 base interfaces.
            </summary>
            <typeparam name="T">The type of elements in the collection.</typeparam>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayKeyList`2.#ctor(System.Func{`0,`1},System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKObservableSortedArrayKeyList`2"/> with a default comparison function.
            </summary>
            <param name="keySelector">The function that select the key from an item.</param>
            <param name="allowDuplicates">True to allow duplicate items.</param>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayKeyList`2.#ctor(System.Func{`0,`1},System.Comparison{`1},System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKObservableSortedArrayKeyList`2"/> with a specific comparison function.
            </summary>
            <param name="keySelector">The function that select the key from an item.</param>
            <param name="keyComparison">Comparison function for keys.</param>
            <param name="allowDuplicates">True to allow duplicate items.</param>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayKeyList`2.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Raises the <see cref="E:CK.Core.CKObservableSortedArrayKeyList`2.CollectionChanged"/> event.
            </summary>
            <param name="e">Event argument.</param>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayKeyList`2.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)">
            <summary>
            Raises the <see cref="E:CK.Core.CKObservableSortedArrayKeyList`2.PropertyChanged"/> event (for "Count" and "Item[]" property).
            </summary>
            <param name="e">Event argument.</param>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayKeyList`2.DoInsert(System.Int32,`0)">
            <summary>
            Overridden to trigger the necessary events.
            </summary>
            <param name="index">Index to insert.</param>
            <param name="value">Item to insert.</param>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayKeyList`2.RaiseAdd(System.Int32,`0)">
            <summary>
            Raises the event corresponding to <see cref="M:CK.Core.CKObservableSortedArrayKeyList`2.DoInsert(System.Int32,`0)"/> (<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Add"/>).
            </summary>
            <param name="index">Inserted index.</param>
            <param name="value">Inserted item.</param>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayKeyList`2.DoRemoveAt(System.Int32)">
            <summary>
            Overridden to trigger the necessary events.
            </summary>
            <param name="index">Index to remove.</param>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayKeyList`2.RaiseRemove(System.Int32,`0)">
            <summary>
            Raises the event corresponding to <see cref="M:CK.Core.CKObservableSortedArrayKeyList`2.DoRemoveAt(System.Int32)"/> (<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Remove"/>).
            </summary>
            <param name="index">Removed index.</param>
            <param name="value">Removed item.</param>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayKeyList`2.DoSet(System.Int32,`0)">
            <summary>
            Overridden to trigger the necessary events.
            </summary>
            <param name="index">The position to set.</param>
            <param name="newValue">The new item to inject.</param>
            <returns>The previous item at the position.</returns>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayKeyList`2.RaiseReplace(System.Int32,`0,`0)">
            <summary>
            Raises the event corresponding to <see cref="M:CK.Core.CKObservableSortedArrayKeyList`2.DoSet(System.Int32,`0)"/> (<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Replace"/>).
            </summary>
            <param name="index">Replaced index.</param>
            <param name="newValue">New item.</param>
            <param name="oldValue">Replaced item.</param>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayKeyList`2.DoMove(System.Int32,System.Int32)">
            <summary>
            Overridden to trigger the necessary events.
            </summary>
            <param name="from">Old index of the item.</param>
            <param name="newIndex">New index.</param>
            <returns>The new index of the element.</returns>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayKeyList`2.RaiseMove(System.Int32,System.Int32)">
            <summary>
            Raises the event corresponding to <see cref="M:CK.Core.CKObservableSortedArrayKeyList`2.DoMove(System.Int32,System.Int32)"/> (<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Move"/>).
            </summary>
            <param name="from">Original index.</param>
            <param name="newIndex">Target index.</param>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayKeyList`2.DoClear">
            <summary>
            Overridden to trigger the necessary events.
            </summary>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayKeyList`2.RaiseReset">
            <summary>
            Raises the event corresponding to <see cref="M:CK.Core.CKObservableSortedArrayKeyList`2.DoClear"/> (<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Reset"/>).
            </summary>
        </member>
        <member name="E:CK.Core.CKObservableSortedArrayKeyList`2.CollectionChanged">
            <summary>
            Standard <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> event.
            </summary>
        </member>
        <member name="E:CK.Core.CKObservableSortedArrayKeyList`2.PropertyChanged">
            <summary>
            Standard <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> event.
            </summary>
        </member>
        <member name="T:CK.Core.CKObservableSortedArrayList`1">
            <summary>
            A <see cref="T:CK.Core.CKSortedArrayList`1"/> that is observable.
            </summary>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayList`1.#ctor">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKObservableSortedArrayList`1"/> with a default comparer and no duplicates.
            </summary>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayList`1.#ctor(System.Collections.Generic.IComparer{`0},System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKObservableSortedArrayList`1"/> with a <see cref="T:System.Collections.Generic.IComparer`1"/> 
            and that rejects or allows duplicates.
            </summary>
            <param name="comparer">The comparer.</param>
            <param name="allowDuplicates">True to allow duplicate items.</param>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayList`1.#ctor(System.Comparison{`0},System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKObservableSortedArrayList`1"/> with a comparison function 
            and that rejects or allows duplicates.
            </summary>
            <param name="comparison">Comparison function to use.</param>
            <param name="allowDuplicates">True to allow duplicate items.</param>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayList`1.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Raises the <see cref="E:CK.Core.CKObservableSortedArrayList`1.CollectionChanged"/> event.
            </summary>
            <param name="e">Event argument.</param>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayList`1.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)">
            <summary>
            Raises the <see cref="E:CK.Core.CKObservableSortedArrayList`1.PropertyChanged"/> event (for "Count" and "Item[]" property).
            </summary>
            <param name="e">Event argument.</param>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayList`1.DoInsert(System.Int32,`0)">
            <summary>
            Overridden to trigger the necessary events.
            </summary>
            <param name="index">Index to insert.</param>
            <param name="value">Item to insert.</param>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayList`1.RaiseAdd(System.Int32,`0)">
            <summary>
            Raises the event corresponding to <see cref="M:CK.Core.CKObservableSortedArrayList`1.DoInsert(System.Int32,`0)"/> (<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Add"/>).
            </summary>
            <param name="index">Inserted index.</param>
            <param name="value">Inserted item.</param>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayList`1.DoRemoveAt(System.Int32)">
            <summary>
            Overridden to trigger the necessary events.
            </summary>
            <param name="index">Index to remove.</param>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayList`1.RaiseRemove(System.Int32,`0)">
            <summary>
            Raises the event corresponding to <see cref="M:CK.Core.CKObservableSortedArrayList`1.DoRemoveAt(System.Int32)"/> (<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Remove"/>).
            </summary>
            <param name="index">Removed index.</param>
            <param name="value">Removed item.</param>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayList`1.DoSet(System.Int32,`0)">
            <summary>
            Overridden to trigger the necessary events.
            </summary>
            <param name="index">The position to set.</param>
            <param name="newValue">The new item to inject.</param>
            <returns>The previous item at the position.</returns>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayList`1.RaiseReplace(System.Int32,`0,`0)">
            <summary>
            Raises the event corresponding to <see cref="M:CK.Core.CKObservableSortedArrayList`1.DoSet(System.Int32,`0)"/> (<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Replace"/>).
            </summary>
            <param name="index">Replaced index.</param>
            <param name="newValue">New item.</param>
            <param name="oldValue">Replaced item.</param>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayList`1.DoMove(System.Int32,System.Int32)">
            <summary>
            Overridden to trigger the necessary events.
            </summary>
            <param name="from">Old index of the item.</param>
            <param name="newIndex">New index.</param>
            <returns>The new index of the element.</returns>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayList`1.RaiseMove(System.Int32,System.Int32)">
            <summary>
            Raises the event corresponding to <see cref="M:CK.Core.CKObservableSortedArrayList`1.DoMove(System.Int32,System.Int32)"/> (<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Move"/>).
            </summary>
            <param name="from">Original index.</param>
            <param name="newIndex">Target index.</param>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayList`1.DoClear">
            <summary>
            Overridden to trigger the necessary events.
            </summary>
        </member>
        <member name="M:CK.Core.CKObservableSortedArrayList`1.RaiseReset">
            <summary>
            Raises the event corresponding to <see cref="M:CK.Core.CKObservableSortedArrayList`1.DoClear"/> (<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Reset"/>).
            </summary>
        </member>
        <member name="E:CK.Core.CKObservableSortedArrayList`1.CollectionChanged">
            <summary>
            Standard <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> event.
            </summary>
        </member>
        <member name="E:CK.Core.CKObservableSortedArrayList`1.PropertyChanged">
            <summary>
            Standard <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> event.
            </summary>
        </member>
        <member name="T:CK.Core.Impl.CKReadOnlyCollectionDebuggerView`1">
            <summary>
            Debugger object for <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/>.
            </summary>
            <typeparam name="T">Type of elements in the collection.</typeparam>
        </member>
        <member name="M:CK.Core.Impl.CKReadOnlyCollectionDebuggerView`1.#ctor(System.Collections.Generic.IReadOnlyCollection{`0})">
            <summary>
            Called by the debugger when needed.
            </summary>
            <param name="collection">The collection to debug.</param>
        </member>
        <member name="P:CK.Core.Impl.CKReadOnlyCollectionDebuggerView`1.Items">
            <summary>
            Gets the items as a flattened array view.
            </summary>
        </member>
        <member name="T:CK.Core.Impl.ReadOnlyCollectionDebuggerView`2">
            <summary>
            Debugger for adapters with two types (an exposed type and an inner type).
            </summary>
            <typeparam name="T">Type of the exposed element.</typeparam>
            <typeparam name="TInner">Type of the inner element.</typeparam>
        </member>
        <member name="M:CK.Core.Impl.ReadOnlyCollectionDebuggerView`2.#ctor(System.Collections.Generic.IReadOnlyCollection{`0})">
            <summary>
            Called by the debugger when needed.
            </summary>
            <param name="collection">The collection to debug.</param>
        </member>
        <member name="P:CK.Core.Impl.ReadOnlyCollectionDebuggerView`2.Items">
            <summary>
            Gets the items as a flattened array view.
            </summary>
        </member>
        <member name="T:CK.Core.CKReadOnlyCollectionOnICollection`1">
            <summary>
            Adapts a <see cref="T:System.Collections.Generic.ICollection`1"/> object to the <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/> interface.
            </summary>
            <typeparam name="T">Type of the element.</typeparam>
        </member>
        <member name="M:CK.Core.CKReadOnlyCollectionOnICollection`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKReadOnlyCollectionOnICollection`1"/> around a <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="inner">Collection to wrap.</param>
        </member>
        <member name="M:CK.Core.CKReadOnlyCollectionOnICollection`1.Contains(System.Object)">
            <summary>
            Gets whether an item is contained or not.
            </summary>
            <param name="item">Item to challenge.</param>
            <returns>True if the item is contained in the collection.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyCollectionOnICollection`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>A IEnumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="P:CK.Core.CKReadOnlyCollectionOnICollection`1.Inner">
            <summary>
            Gets or sets the wrapped collection.
            </summary>
        </member>
        <member name="P:CK.Core.CKReadOnlyCollectionOnICollection`1.Count">
            <summary>
            Gets the number of items of the collection.
            </summary>
        </member>
        <member name="T:CK.Core.CKReadOnlyCollectionOnISet`1">
            <summary>
            Adapts a <see cref="T:System.Collections.Generic.HashSet`1"/> (or any <see cref="T:System.Collections.Generic.ISet`1"/>) object to the <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/> interface.
            </summary>
            <typeparam name="T">Type of the element.</typeparam>
        </member>
        <member name="M:CK.Core.CKReadOnlyCollectionOnISet`1.#ctor(System.Collections.Generic.ISet{`0})">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKReadOnlyCollectionOnISet`1"/> around a <see cref="T:System.Collections.Generic.ISet`1"/>.
            </summary>
            <param name="inner">Hash set to wrap.</param>
        </member>
        <member name="M:CK.Core.CKReadOnlyCollectionOnISet`1.Contains(System.Object)">
            <summary>
            Gets whether an item is contained or not.
            </summary>
            <param name="item">Item to challenge.</param>
            <returns>True if the item is contained in the collection.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyCollectionOnISet`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>A IEnumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="P:CK.Core.CKReadOnlyCollectionOnISet`1.Inner">
            <summary>
            Gets or sets the wrapped set.
            </summary>
        </member>
        <member name="P:CK.Core.CKReadOnlyCollectionOnISet`1.Count">
            <summary>
            Gets the number of items of the collection.
            </summary>
        </member>
        <member name="T:CK.Core.CKReadOnlyCollectionTypeConverter`2">
            <summary>
            Wraps a <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/> of a <typeparamref name="TOuter"/> type around a <see cref="T:System.Collections.Generic.ICollection`1"/>
            of <typeparamref name="TInner"/> (the <see cref="P:CK.Core.CKReadOnlyCollectionTypeConverter`2.Inner"/> collection).
            The converter from inner objects to outer objects is required (to expose the content). 
            An optional converter (outer to inner) enables O(1) <see cref="M:CK.Core.CKReadOnlyCollectionTypeConverter`2.Contains(System.Object)"/> method if the inner collection
            supports O(1) <see cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/> method (this is the case of dictionary Keys collection).
            </summary>
            <typeparam name="TOuter">Type of the object that must be exposed.</typeparam>
            <typeparam name="TInner">Actual type of the objects contained in the <see cref="P:CK.Core.CKReadOnlyCollectionTypeConverter`2.Inner"/> collection.</typeparam>
        </member>
        <member name="M:CK.Core.CKReadOnlyCollectionTypeConverter`2.#ctor(System.Collections.Generic.ICollection{`1},System.Converter{`1,`0},System.Converter{`0,`1})">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKReadOnlyCollectionTypeConverter`2"/> around a <see cref="T:System.Collections.Generic.ICollection`1"/>
            thanks to a <see cref="T:System.Converter`2"/> and an optional <see cref="T:System.Converter`2"/>.
            </summary>
            <param name="c">Collection to wrap.</param>
            <param name="innerToOuter">The converter function from <typeparamref name="TInner"/> to <typeparamref name="TOuter"/>.</param>
            <param name="outerToInner">
            Optional converter from <typeparamref name="TOuter"/> to <typeparamref name="TInner"/>. 
            When null, the <see cref="M:CK.Core.CKReadOnlyCollectionTypeConverter`2.Contains(System.Object)"/> method is O(n) instead of O(1) if the inner collection is an index.
            </param>
        </member>
        <member name="M:CK.Core.CKReadOnlyCollectionTypeConverter`2.#ctor(System.Collections.Generic.ICollection{`1},System.Converter{`1,`0})">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKReadOnlyCollectionTypeConverter`2"/> around a <see cref="T:System.Collections.Generic.ICollection`1"/>
            thanks to a <see cref="T:System.Converter`2"/>.
            </summary>
            <param name="c">Collection to wrap.</param>
            <param name="innerToOuter">The converter function from <typeparamref name="TInner"/> to <typeparamref name="TOuter"/>.</param>
        </member>
        <member name="M:CK.Core.CKReadOnlyCollectionTypeConverter`2.Contains(System.Object)">
            <summary>
            Gets whether an item is contained or not.
            </summary>
            <param name="item">Item to challenge.</param>
            <returns>True if the item is contained in the collection.</returns>
        </member>
        <member name="P:CK.Core.CKReadOnlyCollectionTypeConverter`2.Inner">
            <summary>
            Wrapped <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
        </member>
        <member name="P:CK.Core.CKReadOnlyCollectionTypeConverter`2.Count">
            <summary>
            Gets the number of items of the collection.
            </summary>
        </member>
        <member name="T:CK.Core.CKReadOnlyExtension">
            <summary>
            Provides extension methods for <see cref="T:CK.Core.ICKReadOnlyCollection`1"/>, <see cref="T:CK.Core.ICKReadOnlyList`1"/> and <see cref="T:CK.Core.ICKReadOnlyUniqueKeyedCollection`2"/>.
            </summary>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.GetByKey``2(CK.Core.ICKReadOnlyUniqueKeyedCollection{``0,``1},``1)">
            <summary>
            Gets the item with the associated key, forgetting the exists out parameter in <see cref="M:CK.Core.ICKReadOnlyUniqueKeyedCollection`2.GetByKey(`1,System.Boolean@)"/>.
            </summary>
            <typeparam name="T">Type of the elements in the collection.</typeparam>
            <typeparam name="TKey">Type of the key.</typeparam>
            <param name="this">Keyed collection of elements.</param>
            <param name="key">The item key.</param>
            <returns>The item that matches the key, default(T) if the key can not be found.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.ToArray``1(System.Collections.Generic.IReadOnlyCollection{``0})">
            <summary>
            Creates an array from a read only collection.
            This is a much more efficient version than the IEnumerable ToArray extension method
            since this implementation allocates one and only one array. 
            </summary>
            <typeparam name="T">Type of the array and lists elements.</typeparam>
            <param name="this">Read only collection of elements.</param>
            <returns>A new array that contains the same element as the collection.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.ToReadOnlyList``1(System.Collections.Generic.IList{``0})">
            <summary>
            Creates a <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/>.
            It is an independent storage (a copy).
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="this">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <returns>A read only list that contains the elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.AsReadOnlyList``1(System.Collections.Generic.IList{``0})">
            <summary>
            Attempts to consider a <see cref="T:System.Collections.Generic.IList`1"/> as a <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>.
            If the actual object supports IReadOnlyList&lt;T&gt; it is a direct cast (in .Net 4.5, the 
            standard List&lt;T&gt; extends IReadOnlyList&lt;T&gt;), otherwise a <see cref="M:CK.Core.CKReadOnlyListOnIList`1.#ctor(System.Collections.Generic.IList{`0})"/> 
            wrapper is created around the original list.
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="this">A <see cref="T:System.Collections.Generic.IList`1"/> to consider as a read only list.</param>
            <returns>A read only list that is the original list or contains the elements from the original list.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.ToReadOnlyList``2(System.Collections.Generic.IList{``1},System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.ICKReadOnlyList`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/>.
            It is an independent storage that keeps the references to the <paramref name="converter"/> results.
            </summary>
            <typeparam name="T">The type of the elements of the resulting read only list.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="this">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="converter">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <returns>A read only list that contains the conversion of elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.ToReadOnlyList``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:CK.Core.ICKReadOnlyList`1"/> from a sub sequence of a <see cref="T:System.Collections.Generic.IList`1"/>.
            It is an independent storage (a copy).
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="this">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <param name="count">Number of elements to take into account.</param>
            <returns>A read only list that contains the elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.ToReadOnlyList``2(System.Collections.Generic.IList{``1},System.Int32,System.Int32,System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.ICKReadOnlyList`1"/> from a sub sequence of a <see cref="T:System.Collections.Generic.IList`1"/> and a converter delegate.
            It is an independent storage that keeps the references to the <paramref name="converter"/> results.
            </summary>
            <typeparam name="T">The type of the elements of the resulting read only list.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="this">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <param name="count">Number of elements to take into account.</param>
            <param name="converter">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <returns>A read only list that contains the converted elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.ToReadOnlyList``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Creates a <see cref="T:CK.Core.ICKReadOnlyList`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/> starting at a given index.
            It is an independent storage (a copy).
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="this">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <returns>A read only list that contains the elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.ToReadOnlyList``2(System.Collections.Generic.IList{``1},System.Int32,System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.ICKReadOnlyList`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/> and a converter delegate, starting at a given index.
            It is an independent storage that keeps the references to the <paramref name="converter"/> results.
            </summary>
            <typeparam name="T">The type of the elements of out.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="this">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <param name="converter">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <returns>A read only list that contains converted elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.ToReadOnlyList``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Creates a <see cref="T:CK.Core.ICKReadOnlyList`1"/> that is a copy of the <see cref="T:System.Collections.Generic.ICollection`1"/> content.
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="this">A <see cref="T:System.Collections.Generic.ICollection`1"/> to create a read only list from.</param>
            <returns>A read only list that contains the elements from the input collection following the enumeration order.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.ToReadOnlyList``2(System.Collections.Generic.ICollection{``1},System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.ICKReadOnlyList`1"/> from a <see cref="T:System.Collections.Generic.ICollection`1"/>.
            It is an independent storage that keeps the references to the <paramref name="converter"/> results.
            </summary>
            <typeparam name="T">The type of the elements of the resulting read only list.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="converter">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <param name="this">A <see cref="T:System.Collections.Generic.ICollection`1"/> to create a read only list from. Can not be null.</param>
            <returns>A read only list that contains the elements from the input collection following the enumeration order.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.ToReadOnlyList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a <see cref="T:CK.Core.ICKReadOnlyList`1"/> from a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            It is an independent storage (a copy).
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="this">A <see cref="T:System.Collections.Generic.IEnumerable`1"/> to create a read only list from.</param>
            <returns>A read only list that contains the elements from the input sequence following the enumeration order.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.ToReadOnlyCollection``1(System.Collections.Generic.IList{``0})">
            <summary>
            Creates a <see cref="T:CK.Core.ICKReadOnlyCollection`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/>.
            It is an independent storage (a copy).
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="this">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only collection from.</param>
            <returns>A read only collection that contains the elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.ToReadOnlyCollection``2(System.Collections.Generic.IList{``1},System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.ICKReadOnlyCollection`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/> and a converter delegate.
            It is an independent storage that keeps the references to the <paramref name="converter"/> results.
            </summary>
            <typeparam name="T">The type of the elements of the resulting read only list.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only collection from.</param>
            <param name="converter">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <returns>A read only collection that contains the elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.ToReadOnlyCollection``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:CK.Core.ICKReadOnlyCollection`1"/> from a sub seqence of a <see cref="T:System.Collections.Generic.IList`1"/>.
            It is an independent storage (a copy).
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="this">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <param name="count">Number of elements to take into account.</param>
            <returns>A read only collection that contains the elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.ToReadOnlyCollection``2(System.Collections.Generic.IList{``1},System.Int32,System.Int32,System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.ICKReadOnlyCollection`1"/> from a sub seqence of a <see cref="T:System.Collections.Generic.IList`1"/> and a converter delegate.
            It is an independent storage that keeps the references to the <paramref name="converter"/> results.
            </summary>
            <typeparam name="T">The type of the elements of the resulting read only list.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="this">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <param name="count">Number of elements to take into account.</param>
            <param name="converter">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <returns>A read only collection that contains the converted elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.ToReadOnlyCollection``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Creates a <see cref="T:CK.Core.ICKReadOnlyCollection`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/>.
            It is an independent storage (a copy).
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="this">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only collection from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <returns>A read only collection that contains the elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.ToReadOnlyCollection``2(System.Collections.Generic.IList{``1},System.Int32,System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.ICKReadOnlyCollection`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/> and a converter delegate, starting at a given index.
            It is an independent storage that keeps the references to the <paramref name="converter"/> results.
            </summary>
            <typeparam name="T">The type of the elements of the resulting read only list.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="this">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <param name="converter">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <returns>A read only collection that contains converted elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.ToReadOnlyCollection``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Creates a <see cref="T:CK.Core.ICKReadOnlyCollection`1"/> from a <see cref="T:System.Collections.Generic.ICollection`1"/>.
            It is an independent storage (a copy).
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="this">A <see cref="T:System.Collections.Generic.ICollection`1"/> to create a read only list from.</param>
            <returns>A read only collection that contains the elements from the input collection.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.ToReadOnlyCollection``2(System.Collections.Generic.ICollection{``1},System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/> from a <see cref="T:System.Collections.Generic.ICollection`1"/>.
            It is an independent storage that keeps the references to the <paramref name="converter"/> results.
            </summary>
            <typeparam name="T">The type of the elements of the resulting read only collection.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.ICollection`1"/> to create a read only list from.</param>
            <param name="converter">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <returns>A read only collection that contains the conversion of elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.ToReadOnlyCollection``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a <see cref="T:CK.Core.ICKReadOnlyCollection`1"/> from a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            It is an independent storage (a copy).
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="this">A <see cref="T:System.Collections.Generic.IEnumerable`1"/> to create a read only list from.</param>
            <returns>A read only collection that contains the elements from the input sequence following the enumeration order.</returns>
        </member>
        <member name="T:CK.Core.CKReadOnlyListEmpty`1">
            <summary>
            Empty read only list. The <see cref="F:CK.Core.CKReadOnlyListEmpty`1.Empty"/> null object is also a <see cref="T:System.Collections.Generic.IList`1"/>:
            by casting it, it also provides an empty read only <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <typeparam name="T">Contained elements type.</typeparam>
        </member>
        <member name="F:CK.Core.CKReadOnlyListEmpty`1.Empty">
            <summary>
            Static empty <see cref="T:CK.Core.CKReadOnlyListEmpty`1"/>. Can also be used as an 
            empty <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
        </member>
        <member name="M:CK.Core.CKReadOnlyListEmpty`1.IndexOf(System.Object)">
            <summary>
            Gets the index of the an element: always <see cref="F:System.Int32.MinValue"/>.
            </summary>
            <param name="item">Element to find in the list</param>
            <returns>Index of the given element</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyListEmpty`1.Contains(System.Object)">
            <summary>
            Gets always false.
            </summary>
            <param name="item">Item to find</param>
            <returns>False in all cases, a <see cref="T:CK.Core.CKReadOnlyListEmpty`1"/> doesn't contains any elements.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyListEmpty`1.GetEnumerator">
            <summary>
            Gets the underlying empty enumerator.
            </summary>
            <returns>An empty enumerator.</returns>
        </member>
        <member name="P:CK.Core.CKReadOnlyListEmpty`1.Item(System.Int32)">
            <summary>
            Gets an element at the given index: always throws an <see cref="T:System.ArgumentOutOfRangeException"/>.
            </summary>
            <param name="i">index of the element to find</param>
            <returns>New <see cref="T:System.IndexOutOfRangeException"/>. 
            Because a <see cref="T:CK.Core.CKReadOnlyListEmpty`1"/> doesn't contains any elements.</returns>
        </member>
        <member name="P:CK.Core.CKReadOnlyListEmpty`1.Count">
            <summary>
            Gets the number of items of the list: it will always be 0.
            </summary>
        </member>
        <member name="T:CK.Core.CKReadOnlyListMono`1">
            <summary>
            Implements a mono element <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>.
            </summary>
            <typeparam name="T">The type of element in the read only list.</typeparam>
        </member>
        <member name="M:CK.Core.CKReadOnlyListMono`1.#ctor(`0)">
            <summary>
            Initializes a new <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> with one element (that can be null if <typeparamref name="T"/> is a reference type).
            </summary>
            <param name="val">Element contained by the <see cref="T:CK.Core.CKReadOnlyListMono`1"/> (can be null).</param>
        </member>
        <member name="M:CK.Core.CKReadOnlyListMono`1.IndexOf(System.Object)">
            <summary>
            Gets the index of the given item (uses <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>).
            </summary>
            <param name="item">Item to find</param>
            <returns>Index of the item (for this implementation, it is necessarily 0) or <see cref="F:System.Int32.MinValue"/> if it is not found</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyListMono`1.Contains(System.Object)">
            <summary>
            Gets if the given item is contained into the list (uses <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>).
            </summary>
            <param name="item">Item to find</param>
            <returns>True if the item is found, false otherwise.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyListMono`1.GetEnumerator">
            <summary>
            Gets the underlying enumerator, <see cref="T:CK.Core.CKEnumeratorMono`1"/> actually.
            </summary>
            <returns>An enumerator.</returns>
        </member>
        <member name="P:CK.Core.CKReadOnlyListMono`1.Item(System.Int32)">
            <summary>
            Gets the item at the given index.
            </summary>
            <param name="i">Index of the item to find.</param>
            <returns>Found item at the index. If the index is not 0 an <see cref="T:System.IndexOutOfRangeException"/> will be thrown.</returns>
        </member>
        <member name="P:CK.Core.CKReadOnlyListMono`1.Count">
            <summary>
            Gets the count of the list, 1 in all cases.
            </summary>
        </member>
        <member name="T:CK.Core.CKReadOnlyListOnIList`1">
            <summary>
            Adapts a <see cref="T:System.Collections.Generic.IList`1"/> object to the <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> interface.
            The other <see cref="T:CK.Core.CKReadOnlyListOnIList`2"/> generic can expose (wrap) a list of TInner 
            as a read only list of T where TInner is a T.
            </summary>
            <typeparam name="T">Type of the element.</typeparam>
        </member>
        <member name="M:CK.Core.CKReadOnlyListOnIList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKReadOnlyListOnIList`1"/> around a <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <param name="inner">List to wrap. Must not be null.</param>
        </member>
        <member name="M:CK.Core.CKReadOnlyListOnIList`1.IndexOf(System.Object)">
            <summary>
            Determines the index of a specific item in list.
            </summary>
            <param name="item">The item to locate in the list.</param>
            <returns>The index of item if found in the list; otherwise a negative value (see <see cref="M:CK.Core.ICKReadOnlyList`1.IndexOf(System.Object)"/>).</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyListOnIList`1.Contains(System.Object)">
            <summary>
            Whether an item is contained or not.
            </summary>
            <param name="item">Item to challenge.</param>
            <returns>True if the item is contained in the collection.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyListOnIList`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An IEnumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="P:CK.Core.CKReadOnlyListOnIList`1.Inner">
            <summary>
            Gets or sets the wrapped list. Must not be null (nor itself).
            </summary>
        </member>
        <member name="P:CK.Core.CKReadOnlyListOnIList`1.Item(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="i">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="i"/> is not a valid index in the list.</exception>
        </member>
        <member name="P:CK.Core.CKReadOnlyListOnIList`1.Count">
            <summary>
            Gets the number of items of the collection.
            </summary>
        </member>
        <member name="T:CK.Core.CKReadOnlyListOnIList`2">
            <summary>
            Adapts a <see cref="T:System.Collections.Generic.IList`1"/> object to the <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> interface
            where TInner is a T.
            </summary>
            <typeparam name="T">Type of the exposed element.</typeparam>
            <typeparam name="TInner">Type of the list element.</typeparam>
            <remarks>
            There is no way to define a beast like <c>ReadOnlyListOnIList&lt;T, TInner&gt; where TInner : T</c> that would 
            extend <see cref="T:System.Collections.Generic.IList`1"/> because of the GetEnumerator support.
            <para>
            The adapter object would have to implement both GetEnumerator() methods (for TInner and T), and even if the constraint states that
            TInner is T and the IEnumerator is covariant, this is rejected with the following error: cannot implement 
            both 'IEnumerable&lt;T&gt;' and 'System.Collections.Generic.IEnumerable&lt;TInner&gt;' because they may unify 
            for some type parameter substitutions.
            </para>
            </remarks>
        </member>
        <member name="M:CK.Core.CKReadOnlyListOnIList`2.#ctor(System.Collections.Generic.IList{`1})">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKReadOnlyListOnIList`1"/> around a <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <param name="list">List to wrap.</param>
        </member>
        <member name="M:CK.Core.CKReadOnlyListOnIList`2.IndexOf(System.Object)">
            <summary>
            Determines the index of a specific item in list.
            </summary>
            <param name="item">The item to locate in the list.</param>
            <returns>The index of item if found in the list; otherwise a negative value (see <see cref="M:CK.Core.ICKReadOnlyList`1.IndexOf(System.Object)"/>).</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyListOnIList`2.Contains(System.Object)">
            <summary>
            Whether an item is contained or not.
            </summary>
            <param name="item">Item to challenge.</param>
            <returns>True if the item is contained in the collection.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyListOnIList`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An IEnumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="P:CK.Core.CKReadOnlyListOnIList`2.Inner">
            <summary>
            Gets or sets the wrapped list.
            </summary>
        </member>
        <member name="P:CK.Core.CKReadOnlyListOnIList`2.Item(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="i">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="i"/> is not a valid index in the list.</exception>
        </member>
        <member name="P:CK.Core.CKReadOnlyListOnIList`2.Count">
            <summary>
            Gets the number of items of the collection.
            </summary>
        </member>
        <member name="T:CK.Core.CollectionExtension">
            <summary>
            Provides extension methods for collection &amp; list interfaces.
            </summary>
        </member>
        <member name="M:CK.Core.CollectionExtension.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds multiple items to a collection.
            </summary>
            <typeparam name="T">Collection items' type.</typeparam>
            <param name="this">This collection.</param>
            <param name="items">Multiple items to add. Can not be null.</param>
        </member>
        <member name="M:CK.Core.CollectionExtension.AddRangeArray``1(System.Collections.Generic.ICollection{``0},``0[])">
            <summary>
            Adds multiple items to a collection.
            </summary>
            <typeparam name="T">Collection items' type.</typeparam>
            <param name="this">This collection.</param>
            <param name="items">Items to add.</param>
        </member>
        <member name="M:CK.Core.CollectionExtension.RemoveWhereAndReturnsRemoved``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean})">
            <summary>
            Simple helper that removes elements in a <see cref="T:System.Collections.Generic.IList`1"/> and returns them as an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            Makes the transfer of items from one list to another easy when combined with <see cref="M:CK.Core.CollectionExtension.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})"/>.
            The returned enumerable MUST be consumed to actually remove the items from the list (this is what AddRange do).
            Calling <see cref="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0})">IEnumerable&lt;T&gt;.Count()</see> for instance resolves the enumeration.
            </summary>
            <typeparam name="T">The type of the elements in the list.</typeparam>
            <param name="this">This list.</param>
            <param name="removeCondition">Predicate that must return true for items that must be removed from this list.</param>
            <returns>Removed items (can be added into another one).</returns>
        </member>
        <member name="F:CK.Core.CollectionExtension.ItemArrayChangedEventArgs">
            <summary>
            Immutable reusable PropertyChangedEventArgs for "Item[]".
            </summary>
        </member>
        <member name="F:CK.Core.CollectionExtension.CountChangedEventArgs">
            <summary>
            Immutable reusable PropertyChangedEventArgs for "Count".
            </summary>
        </member>
        <member name="T:CK.Core.DictionaryExtension">
            <summary>
            Provides extension methods for <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:CK.Core.DictionaryExtension.GetValueWithDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Gets the value associated with the specified key if it exists otherwise returns the <paramref name="defaultValue"/>.
            </summary>
            <param name="this">This generic IDictionary.</param>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValue">Default value to use if the key does not exist.</param>
            <returns>
            The value associated with the specified key, if the key is found; otherwise, the <paramref name="defaultValue"/>. 
            </returns>
        </member>
        <member name="M:CK.Core.DictionaryExtension.GetValueWithDefaultFunc``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>
            Gets the value associated with the specified key if it exists otherwise calls the <paramref name="defaultValue"/> function.
            </summary>
            <param name="this">This generic IDictionary.</param>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValue">A delegate that will be called if the key does not exist.</param>
            <returns>
            The value associated with the specified key, if the key is found; otherwise, the result 
            of the <paramref name="defaultValue"/> delegate.
            </returns>
        </member>
        <member name="M:CK.Core.DictionaryExtension.GetOrSet``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>
            Gets the value associated with the specified key if it exists otherwise calls the <paramref name="createValue"/> function
            and adds the newly obtained value into the dictionary.
            </summary>
            <param name="this">This generic IDictionary.</param>
            <param name="key">The key whose value to get.</param>
            <param name="createValue">A delegate that will be called if the key does not exist.</param>
            <returns>
            The value associated with the specified key, if the key is found; otherwise, the result 
            of the <paramref name="createValue"/> delegate (this result has been added to the dictionary).
            </returns>
        </member>
        <member name="M:CK.Core.DictionaryExtension.AddRange``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Adds the content of a dictionary to this <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <typeparam name="TKey">The type of keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of values in the dictionary.</typeparam>
            <param name="this">This generic IDictionary.</param>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Collections.Generic.KeyValuePair`2"/> from which content will be copied.</param>
        </member>
        <member name="T:CK.Core.EnumerableExtension">
            <summary>
            Provides extension methods for <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:CK.Core.EnumerableExtension.IsSortedStrict``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Checks whether the enumerable is in strict (no duplicates) ascending order (uses the <see cref="P:System.Collections.Generic.Comparer`1.Default"/> Compare method).
            </summary>
            <typeparam name="T">Element type of the enumerable.</typeparam>
            <param name="this">This enumerable.</param>
            <returns>True if the enumerable is empty or is in strict ascending order.</returns>
        </member>
        <member name="M:CK.Core.EnumerableExtension.IsSortedLarge``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Checks whether the enumerable is in large (duplicates allowed) ascending order (uses the <see cref="P:System.Collections.Generic.Comparer`1.Default"/> Compare method).
            </summary>
            <typeparam name="T">Element type of the enumerable.</typeparam>
            <param name="this">This enumerable.</param>
            <returns>True if the enumerable is empty or is in large ascending order.</returns>
        </member>
        <member name="M:CK.Core.EnumerableExtension.IsSortedStrict``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
            <summary>
            Checks whether the enumerable is in strict (no duplicates) ascending order based on a comparison function.
            </summary>
            <typeparam name="T">Element type of the enumerable.</typeparam>
            <param name="this">This enumerable.</param>
            <param name="comparison">The delegate used to compare elements.</param>
            <returns>True if the enumerable is empty or is in strict ascending order.</returns>
        </member>
        <member name="M:CK.Core.EnumerableExtension.IsSortedLarge``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
            <summary>
            Checks whether the enumerable is in large (duplicates allowed) ascending order based on a comparison function.
            </summary>
            <typeparam name="T">Element type of the enumerable.</typeparam>
            <param name="this">This enumerable.</param>
            <param name="comparison">The delegate used to compare elements.</param>
            <returns>True if the enumerable is empty or is in large ascending order.</returns>
        </member>
        <member name="M:CK.Core.EnumerableExtension.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Returns the maximal element of the given sequence, based on a projection (typically
            one of the object property). The sequence MUST NOT 
            be empty otherwise an <see cref="T:System.InvalidOperationException"/> is thrown.
            </summary>
            <remarks>
            If more than one element has the maximal projected value, the first
            one encountered will be returned. This overload uses the default comparer
            for the projected type. This operator uses immediate execution, but
            only buffers a single result (the current maximal element).
            </remarks>
            <typeparam name="TSource">Type of the source sequence.</typeparam>
            <typeparam name="TKey">Type of the projected element.</typeparam>
            <param name="this">Source sequence.</param>
            <param name="selector">Selector to use to pick the results to compare</param>
            <returns>The maximal element, according to the projection.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="this"/> or <paramref name="selector"/> is null</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="this"/> is empty</exception>
        </member>
        <member name="M:CK.Core.EnumerableExtension.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Comparison{``1})">
            <summary>
            Returns the maximal element of the given sequence based on
            a projection and a <see cref="T:System.Comparison`1"/>. The sequence MUST NOT 
            be empty otherwise an <see cref="T:System.InvalidOperationException"/> is thrown.
            </summary>
            <remarks>
            If more than one element has the maximal projected value, the first
            one encountered will be returned. This overload uses the default comparer
            for the projected type. This operator uses immediate execution, but
            only buffers a single result (the current maximal element).
            </remarks>
            <typeparam name="TSource">Type of the source sequence.</typeparam>
            <typeparam name="TKey">Type of the projected element.</typeparam>
            <param name="this">Source sequence.</param>
            <param name="selector">Selector to use to pick the results to compare</param>
            <param name="comparison">Comparison function  to use to compare projected values</param>
            <returns>The maximal element, according to the projection.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="this"/>, <paramref name="selector"/> 
            or <paramref name="comparison"/> is null</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="this"/> is empty</exception>       
        </member>
        <member name="M:CK.Core.EnumerableExtension.IndexOf``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Gets the first index in the enumerable where the predicate evaluates to true.
            Returns -1 when not found.
            </summary>
            <typeparam name="TSource">Type of source sequence.</typeparam>
            <param name="this">Source sequence.</param>
            <param name="predicate">Predicate function.</param>
            <returns>Index where predicate is true. -1 if not found.</returns>
        </member>
        <member name="M:CK.Core.EnumerableExtension.IndexOf``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>
            Gets the first index in the enumerable where the predicate evaluates to true, the index of the element is available to the predicate.
            Returns -1 when not found.
            </summary>
            <typeparam name="TSource">Type of source sequence.</typeparam>
            <param name="this">Source sequence.</param>
            <param name="predicate">Predicate function that accepts the element and its index.</param>
            <returns>Index where predicate is true, or -1 if not found.</returns>
        </member>
        <member name="M:CK.Core.EnumerableExtension.Append``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IEnumerable`1"/> that appends one item to an existing enumerable.
            </summary>
            <typeparam name="TSource">Type of source sequence.</typeparam>
            <param name="this">Source sequence.</param>
            <param name="item">Item to append.</param>
            <returns>An enumerable that appends the item to trhe sequence.</returns>
        </member>
        <member name="T:CK.Core.EnumerableExtension.EAppend`1">
            <summary>
            Internal implementation of Append extension method.
            </summary>
            <typeparam name="T">Type of source sequence.</typeparam>
        </member>
        <member name="T:CK.Core.FIFOBuffer`1">
            <summary>
            Simple implementation of a fixed size FIFO stack based on a circular buffer. 
            The .Net <see cref="T:System.Collections.Generic.Queue`1"/>'s size increase as needed whereas this FIFO automatically loses the oldest items.
            Note that when <typeparamref name="T"/> is a reference type, null can be pushed and pop.
            This can easily be used as a LIFO stack thanks to <see cref="M:CK.Core.FIFOBuffer`1.PopLast"/> and <see cref="M:CK.Core.FIFOBuffer`1.PeekLast"/> methods.
            </summary>
            <typeparam name="T">Type of the items.</typeparam>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.#ctor(System.Int32)">
            <summary>
            Initializes a new <see cref="T:CK.Core.FIFOBuffer`1"/> with an initial capacity.
            </summary>
            <param name="capacity">Initial capacity (can be 0).</param>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.Truncate(System.Int32)">
            <summary>
            Truncates the queue: only the <paramref name="newCount"/> newest items are kept.
            Pops as many old items (the ones that have been pushed first) in order for <see cref="P:CK.Core.FIFOBuffer`1.Count"/> to be equal to newCount.
            </summary>
            <param name="newCount">The final number of items. If it is greater or equal to the current <see cref="P:CK.Core.FIFOBuffer`1.Count"/>, nothing is done.</param>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.Contains(System.Object)">
            <summary>
            Tests whether the buffer actually contains the given object.
            </summary>
            <param name="item">Object to test.</param>
            <returns>True if the object exists.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.IndexOf(System.Object)">
            <summary>
            Gets the index of the given object.
            </summary>
            <param name="item">Object to find.</param>
            <returns>The index of the object or -1 if not found.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.IndexOf(`0)">
            <summary>
            Gets the index of the given object.
            </summary>
            <param name="item">Object to find.</param>
            <returns>
            The index of the object or the bitwise complement of <see cref="P:CK.Core.FIFOBuffer`1.Count"/> if not 
            found (that is a negative value, see <see cref="M:CK.Core.ICKReadOnlyList`1.IndexOf(System.Object)"/>).
            </returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.RemoveAt(System.Int32)">
            <summary>
            Removes the element by index. Index 0 is the oldest item, the one returned by <see cref="M:CK.Core.FIFOBuffer`1.Peek"/> and <see cref="M:CK.Core.FIFOBuffer`1.Pop"/>.
            </summary>
            <param name="index">Index must be positive and less than <see cref="P:CK.Core.FIFOBuffer`1.Count"/>.</param>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.Clear">
            <summary>
            Clears the internal buffer.
            </summary>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.Push(`0)">
            <summary>
            Adds an item.
            </summary>
            <param name="item">Item to push.</param>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.Pop">
            <summary>
            Gets and removes the first item (the one that has been <see cref="M:CK.Core.FIFOBuffer`1.Push(`0)"/>ed first).
            <see cref="P:CK.Core.FIFOBuffer`1.Count"/> must be greater than 0 otherwise an exception is thrown.
            </summary>
            <returns>The first (oldest) item.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.PopLast">
            <summary>
            Gets and removes the last item (the last one that has been <see cref="M:CK.Core.FIFOBuffer`1.Push(`0)"/>ed).
            <see cref="P:CK.Core.FIFOBuffer`1.Count"/> must be greater than 0 otherwise an exception is thrown.
            </summary>
            <returns>The last (newest) item.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.Peek">
            <summary>
            Gets the first item (the one that has been <see cref="M:CK.Core.FIFOBuffer`1.Push(`0)"/>ed first).
            <see cref="P:CK.Core.FIFOBuffer`1.Count"/> must be greater than 0 otherwise an exception is thrown.
            </summary>
            <returns>The first (oldest) item.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.PeekLast">
            <summary>
            Gets the last item (the last one that has been <see cref="M:CK.Core.FIFOBuffer`1.Push(`0)"/>).
            <see cref="P:CK.Core.FIFOBuffer`1.Count"/> must be greater than 0 otherwise an exception is thrown.
            </summary>
            <returns>The last (newest) item.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.CopyTo(`0[])">
            <summary>
            Copies as much possible items into the given array. Order is from oldest to newest.
            If the target array is too small to contain <see cref="P:CK.Core.FIFOBuffer`1.Count"/> items, the newest ones
            are copied (the oldest, the ones that will <see cref="M:CK.Core.FIFOBuffer`1.Pop"/> first, are skipped).
            </summary>
            <param name="array">Array that will contain the items.</param>
            <returns>Number of items copied.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies as much possible items into the given array. Order is from oldest to newest. 
            If the target array is too small to contain <see cref="P:CK.Core.FIFOBuffer`1.Count"/> items, the newest ones
            are copied (the oldest, the ones that will <see cref="M:CK.Core.FIFOBuffer`1.Pop"/> first, are skipped).
            </summary>
            <param name="array">Array that will contain the items.</param>
            <param name="arrayIndex">Index in <paramref name="array"/> where copy must start.</param>
            <returns>Number of items copied.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.CopyTo(`0[],System.Int32,System.Int32)">
            <summary>
            Copies as much possible items into the given array. Order is from oldest to newest.
            If <paramref name="count"/> is less than <see cref="P:CK.Core.FIFOBuffer`1.Count"/>, the newest ones
            are copied (the oldest, the ones that will <see cref="M:CK.Core.FIFOBuffer`1.Pop"/> first, are skipped).
            </summary>
            <param name="array">Array that will contain the items.</param>
            <param name="arrayIndex">Index in <paramref name="array"/> where copy must start.</param>
            <param name="count">Number of items to copy.</param>
            <returns>Number of items copied.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.GetEnumerator">
            <summary>
            Gets the enumerator (from oldest to newest item).
            </summary>
            <returns>An enumerator.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.ToArray">
            <summary>
            Creates an array that contains <see cref="P:CK.Core.FIFOBuffer`1.Count"/> items from oldest to newest.
            </summary>
            <returns>An array with the contained items. Never null.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Non-generic version of <see cref="M:CK.Core.FIFOBuffer`1.GetEnumerator"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.ToString">
            <summary>
            Overridden to display the current count of items and capacity for this buffer.
            </summary>
            <returns>Current count and capacity.</returns>
        </member>
        <member name="P:CK.Core.FIFOBuffer`1.Capacity">
            <summary>
            Gets or sets the capacity (internal buffer will be resized).
            </summary>
        </member>
        <member name="P:CK.Core.FIFOBuffer`1.Count">
            <summary>
            Gets the actual count of element: it is necessary less than or equal to <see cref="P:CK.Core.FIFOBuffer`1.Capacity"/>.
            </summary>
        </member>
        <member name="P:CK.Core.FIFOBuffer`1.Item(System.Int32)">
            <summary>
            Gets the element by index. Index 0 is the oldest item, the one returned by <see cref="M:CK.Core.FIFOBuffer`1.Peek"/> and <see cref="M:CK.Core.FIFOBuffer`1.Pop"/>.
            </summary>
            <param name="index">Index must be positive and less than <see cref="P:CK.Core.FIFOBuffer`1.Count"/>.</param>
            <returns>The indexed element.</returns>
        </member>
        <member name="T:CK.Core.CriticalErrorCollector">
            <summary>
            This collector keeps <see cref="P:CK.Core.CriticalErrorCollector.Capacity"/> <see cref="T:CK.Core.CriticalErrorCollector.Error"/>s (and no more).
            It raises <see cref="E:CK.Core.CriticalErrorCollector.OnErrorFromBackgroundThreads"/> event on each <see cref="M:CK.Core.CriticalErrorCollector.Add(System.Exception,System.String)"/>.
            It is totally thread-safe and guaranties (as long as its Capacity is big enough) that no error can be lost
            (even errors raised while dispatching the event are themselves collected) and that errors are dispatched in
            sequence.
            <para>
            This class is typically used as a static property or field by any object that must handle unexpected errors. (It can also be used
            per-instance if it makes sense.)
            </para>
            </summary>
        </member>
        <member name="M:CK.Core.CriticalErrorCollector.#ctor">
            <summary>
            Initializes a new <see cref="T:CK.Core.CriticalErrorCollector"/> with a default <see cref="P:CK.Core.CriticalErrorCollector.Capacity"/> set to 128.
            </summary>
        </member>
        <member name="M:CK.Core.CriticalErrorCollector.Add(System.Exception,System.String)">
            <summary>
            Adds a critical, unexpected error.
            </summary>
            <param name="comment">Comment associated to the error (such as the name of the culprit). Can be null.</param>
            <param name="ex">The unexpected exception. Must not be null.</param>
        </member>
        <member name="M:CK.Core.CriticalErrorCollector.Clear(System.Int32@,System.Int32@)">
            <summary>
            Clears the list. Only errors that have been already raised by <see cref="E:CK.Core.CriticalErrorCollector.OnErrorFromBackgroundThreads"/>
            are removed from the internal buffer: it can be safely called at any time.
            </summary>
            <param name="cleared">Number of suppressed errors.</param>
            <param name="waitingToBeRaisedErrors">The number of errors waiting to be raised.</param>
        </member>
        <member name="M:CK.Core.CriticalErrorCollector.Clear">
            <summary>
            Clears the list. Only errors that have been already raised by <see cref="E:CK.Core.CriticalErrorCollector.OnErrorFromBackgroundThreads"/>
            are removed from the internal buffer: it can be safely called at any time.
            </summary>
        </member>
        <member name="M:CK.Core.CriticalErrorCollector.WaitOnErrorFromBackgroundThreadsPending">
            <summary>
            Blocks the caller thread until no more event is waiting to be raised by <see cref="E:CK.Core.CriticalErrorCollector.OnErrorFromBackgroundThreads"/> or is being processed.
            This is the right function to use instead of pooling <see cref="P:CK.Core.CriticalErrorCollector.OnErrorFromBackgroundThreadsPending"/>.
            </summary>
        </member>
        <member name="M:CK.Core.CriticalErrorCollector.ToArray">
            <summary>
            Obtains a copy of the last (up to) <see cref="P:CK.Core.CriticalErrorCollector.Capacity"/> errors from oldest to newest.
            The newest may have not been raised by <see cref="E:CK.Core.CriticalErrorCollector.OnErrorFromBackgroundThreads"/> yet.
            </summary>
            <returns>An independent array. May be empty but never null.</returns>
        </member>
        <member name="E:CK.Core.CriticalErrorCollector.OnErrorFromBackgroundThreads">
            <summary>
            Fires when an error has been <see cref="M:CK.Core.CriticalErrorCollector.Add(System.Exception,System.String)"/>ed (there cannot be more than one thread that raises this event at the same time).
            Raising this event is itself protected: if an exception is raised by one of the registered EventHandler, the culprit is removed 
            from the OnErrorFromBackgroundThreads list of delegates, the exception is appended in the collector, and a new event will 
            be raised (to the remaining handlers).
            <para>Caution: the event always fire on a background thread (adding an error is not a blocking operation).</para>
            </summary>
        </member>
        <member name="P:CK.Core.CriticalErrorCollector.Capacity">
            <summary>
            Gets or sets the maximal number of errors kept by this collector.
            Defaults to 128 (which should be enough).
            It can be safely changed at any time.
            </summary>
        </member>
        <member name="P:CK.Core.CriticalErrorCollector.OnErrorFromBackgroundThreadsPending">
            <summary>
            Gets whether any event is waiting to be raised by <see cref="E:CK.Core.CriticalErrorCollector.OnErrorFromBackgroundThreads"/> or is being processed.
            When this is false, it is guaranteed that any existing errors have been handled: if no more <see cref="M:CK.Core.CriticalErrorCollector.Add(System.Exception,System.String)"/> can be done
            it means that this collector has finished its job.
            Instead of pooling this property - with an horrible Thread.Sleep( 1 ), you should use <see cref="M:CK.Core.CriticalErrorCollector.WaitOnErrorFromBackgroundThreadsPending"/> 
            to more efficiently and securely wait for the end of this collector's job.
            </summary>
        </member>
        <member name="P:CK.Core.CriticalErrorCollector.NextSequenceNumber">
            <summary>
            Gets the next <see cref="F:CK.Core.CriticalErrorCollector.Error.SequenceNumber"/>.
            Getting this property makes sense only if this collector is not being solicited.
            </summary>
        </member>
        <member name="P:CK.Core.CriticalErrorCollector.DispatchQueuedWorkItemCount">
            <summary>
            Gets the number of internally created queued work items 
            since this collector exists.
            </summary>
        </member>
        <member name="P:CK.Core.CriticalErrorCollector.OptimizedDispatchQueuedWorkItemCount">
            <summary>
            Gets the number of work items that have been saved since another one 
            was ready to dispatch the events.
            This is a measure of an internal optimization that makes sense only under
            heavy loads (unit tests).
            </summary>
        </member>
        <member name="T:CK.Core.CriticalErrorCollector.Error">
            <summary>
            Encapsulates error information <see cref="M:CK.Core.CriticalErrorCollector.Add(System.Exception,System.String)"/>ed by external code
            or raised by a <see cref="E:CK.Core.CriticalErrorCollector.OnErrorFromBackgroundThreads"/> event itself.
            </summary>
        </member>
        <member name="F:CK.Core.CriticalErrorCollector.Error.LostErrorCount">
            <summary>
            Holds the count of errors that have been discarded: too many critical errors occur
            in a too short time.
            When this field is greater than zero, this indicates a serious problem.
            </summary>
        </member>
        <member name="F:CK.Core.CriticalErrorCollector.Error.SequenceNumber">
            <summary>
            Unique, increasing, sequence number.
            </summary>
        </member>
        <member name="F:CK.Core.CriticalErrorCollector.Error.Comment">
            <summary>
            The origin or a description of the <see cref="P:Exception"/>.
            Never null but can be empty if no comment is provided while calling <see cref="M:CK.Core.CriticalErrorCollector.Add(System.Exception,System.String)"/>.
            </summary>
        </member>
        <member name="F:CK.Core.CriticalErrorCollector.Error.Exception">
            <summary>
            The exception.
            </summary>
        </member>
        <member name="M:CK.Core.CriticalErrorCollector.Error.ToString">
            <summary>
            Overridden to return <see cref="F:CK.Core.CriticalErrorCollector.Error.Comment"/> and <see cref="P:Exception"/> message.
            </summary>
            <returns>Explicit content.</returns>
        </member>
        <member name="T:CK.Core.CriticalErrorCollector.ErrorEventArgs">
            <summary>
            Event argument of <see cref="E:CK.Core.CriticalErrorCollector.OnErrorFromBackgroundThreads"/>.
            </summary>
        </member>
        <member name="F:CK.Core.CriticalErrorCollector.ErrorEventArgs.LoggingErrors">
            <summary>
            The <see cref="T:CK.Core.CriticalErrorCollector.Error"/>s. When more than one error exist, the oldest come first.
            </summary>
        </member>
        <member name="T:CK.Core.DateTimeStamp">
            <summary>
            A date and time stamp encapsulates a <see cref="F:CK.Core.DateTimeStamp.TimeUtc"/> (<see cref="T:System.DateTime"/> guaranteed to be in Utc) and a <see cref="F:CK.Core.DateTimeStamp.Uniquifier"/>.
            </summary>
        </member>
        <member name="F:CK.Core.DateTimeStamp.MinValue">
            <summary>
            Represents the smallest possible value for a DateTimeStamp object.         
            </summary>
        </member>
        <member name="F:CK.Core.DateTimeStamp.Unknown">
            <summary>
            Represents an unknown, default, DateTimeStamp object.
            This is available to have a more expressive code than <c>new DateTimeStamp()</c>.
            </summary>
        </member>
        <member name="F:CK.Core.DateTimeStamp.MaxValue">
            <summary>
            Represents the largest possible value for a DateTimeStamp object.         
            </summary>
        </member>
        <member name="F:CK.Core.DateTimeStamp.Invalid">
            <summary>
            Represents an invalid DateTimeStamp object. See <see cref="P:CK.Core.DateTimeStamp.IsInvalid"/>.
            </summary>
        </member>
        <member name="F:CK.Core.DateTimeStamp.TimeUtc">
            <summary>
            DateTime in Utc.
            </summary>
        </member>
        <member name="F:CK.Core.DateTimeStamp.Uniquifier">
            <summary>
            Uniquifier: non zero when <see cref="F:CK.Core.DateTimeStamp.TimeUtc"/> collides.
            </summary>
        </member>
        <member name="M:CK.Core.DateTimeStamp.#ctor(System.DateTime,System.Byte)">
            <summary>
            Initializes a new <see cref="T:CK.Core.DateTimeStamp"/>.
            </summary>
            <param name="timeUtc">The log time. <see cref="P:System.DateTime.Kind"/> must be <see cref="F:System.DateTimeKind.Utc"/>.</param>
            <param name="uniquifier">Optional non zero uniquifier.</param>
        </member>
        <member name="M:CK.Core.DateTimeStamp.#ctor(CK.Core.DateTimeStamp,System.DateTime,System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.DateTimeStamp"/> that is that is guaranteed to be unique and ascending (unless <paramref name="ensureGreaterThanLastOne"/> 
            is false) regarding <paramref name="lastOne"/>.
            </summary>
            <param name="lastOne">Last time stamp.</param>
            <param name="time">Time (generally current <see cref="P:System.DateTime.UtcNow"/>).</param>
            <param name="ensureGreaterThanLastOne">False to only check for time equality collision instead of guarantying ascending log time.</param>
        </member>
        <member name="M:CK.Core.DateTimeStamp.#ctor(CK.Core.DateTimeStamp,CK.Core.DateTimeStamp)">
            <summary>
            Initializes a new <see cref="T:CK.Core.DateTimeStamp"/> that is that is guaranteed to be unique and ascending regarding <paramref name="lastOne"/>.
            </summary>
            <remarks>
            The <see cref="F:CK.Core.DateTimeStamp.Uniquifier"/> is optimized if possible (this simply calls <see cref="M:CK.Core.DateTimeStamp.#ctor(CK.Core.DateTimeStamp,System.DateTime,System.Boolean)"/> with ensureGreaterThanLastOne sets to true).
            </remarks>
            <param name="lastOne">Last time stamp.</param>
            <param name="newTime">DateTimeStamp to combine.</param>
        </member>
        <member name="M:CK.Core.DateTimeStamp.Match(System.String,System.Int32@,System.Int32,CK.Core.DateTimeStamp@)">
            <summary>
            Tries to match a <see cref="T:CK.Core.DateTimeStamp"/> at a given index in the string.
            </summary>
            <param name="s">The string to parse.</param>
            <param name="startAt">Index where the match must start. On success, index of the end of the match.</param>
            <param name="maxLength">
            Maximum index to consider in the string (it shortens the default <see cref="P:System.String.Length"/>), it can be zero or negative.
            If maxLength is greater than String.Length an <see cref="T:System.ArgumentException"/> is thrown.
            </param>
            <param name="time">Result time.</param>
            <returns>True if the time has been matched.</returns>
        </member>
        <member name="M:CK.Core.DateTimeStamp.CompareTo(CK.Core.DateTimeStamp)">
            <summary>
            Compares this <see cref="T:CK.Core.DateTimeStamp"/> to another one.
            </summary>
            <param name="other">The other DateTimeStamp to compare.</param>
            <returns>Positive value when this is greater than other, 0 when they are equal, a negative value otherwise.</returns>
        </member>
        <member name="M:CK.Core.DateTimeStamp.Equals(CK.Core.DateTimeStamp)">
            <summary>
            Checks equality.
            </summary>
            <param name="other">Other DateTimeStamp.</param>
            <returns>True when this is equal to other.</returns>
        </member>
        <member name="M:CK.Core.DateTimeStamp.CompareTo(System.Object)">
            <summary>
            Compares this DateTimeStamp to another object that must also be a stamp.
            </summary>
            <param name="value">The object to compare.</param>
            <returns>Positive value when this is greater than other, 0 when they are equal, a negative value otherwise.</returns>
        </member>
        <member name="M:CK.Core.DateTimeStamp.Equals(System.Object)">
            <summary>
            Overridden to check equality.
            </summary>
            <param name="other">Other object.</param>
            <returns>True when this is equal to other.</returns>
        </member>
        <member name="M:CK.Core.DateTimeStamp.GetHashCode">
            <summary>
            Overridden to match <see cref="M:CK.Core.DateTimeStamp.Equals(CK.Core.DateTimeStamp)"/>.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="F:CK.Core.DateTimeStamp.FormatWhenUniquifier">
            <summary>
            @"{0:yyyy-MM-dd HH\hmm.ss.fffffff}({1})" is the format that will be used to format log time when the <see cref="F:CK.Core.DateTimeStamp.Uniquifier"/> is not zero.
            It is based on <see cref="F:CK.Core.FileUtil.FileNameUniqueTimeUtcFormat"/> (that is used as-is when the Uniquifier is zero) for the date time format.
            </summary>
        </member>
        <member name="M:CK.Core.DateTimeStamp.ToString">
            <summary>
            Overridden to return a string based on <see cref="F:CK.Core.DateTimeStamp.FormatWhenUniquifier"/> or <see cref="F:CK.Core.FileUtil.FileNameUniqueTimeUtcFormat"/>.
            </summary>
            <returns>A string that can be successfully <see cref="M:CK.Core.DateTimeStamp.Match(System.String,System.Int32@,System.Int32,CK.Core.DateTimeStamp@)"/>ed.</returns>
        </member>
        <member name="M:CK.Core.DateTimeStamp.op_Equality(CK.Core.DateTimeStamp,CK.Core.DateTimeStamp)">
            <summary>
            Checks equality.
            </summary>
            <param name="t1">First stamp.</param>
            <param name="t2">Second stamp.</param>
            <returns>True when stamps are equals.</returns>
        </member>
        <member name="M:CK.Core.DateTimeStamp.op_Inequality(CK.Core.DateTimeStamp,CK.Core.DateTimeStamp)">
            <summary>
            Checks inequality.
            </summary>
            <param name="t1">First stamp.</param>
            <param name="t2">Second stamp.</param>
            <returns>True when stamps are different.</returns>
        </member>
        <member name="M:CK.Core.DateTimeStamp.op_GreaterThan(CK.Core.DateTimeStamp,CK.Core.DateTimeStamp)">
            <summary>
            Strict greater than operator.
            </summary>
            <param name="t1">First stamp.</param>
            <param name="t2">Second stamp.</param>
            <returns>True when stamps first is greater than second.</returns>
        </member>
        <member name="M:CK.Core.DateTimeStamp.op_GreaterThanOrEqual(CK.Core.DateTimeStamp,CK.Core.DateTimeStamp)">
            <summary>
            Large greater than operator.
            </summary>
            <param name="t1">First stamp.</param>
            <param name="t2">Second stamp.</param>
            <returns>True when stamps first is greater than or equal to second.</returns>
        </member>
        <member name="M:CK.Core.DateTimeStamp.op_LessThan(CK.Core.DateTimeStamp,CK.Core.DateTimeStamp)">
            <summary>
            Strict lower than operator.
            </summary>
            <param name="t1">First stamp.</param>
            <param name="t2">Second stamp.</param>
            <returns>True when stamps first is lower than second.</returns>
        </member>
        <member name="M:CK.Core.DateTimeStamp.op_LessThanOrEqual(CK.Core.DateTimeStamp,CK.Core.DateTimeStamp)">
            <summary>
            Large lower than operator.
            </summary>
            <param name="t1">First stamp.</param>
            <param name="t2">Second stamp.</param>
            <returns>True when stamps first is lower than or equal to second.</returns>
        </member>
        <member name="P:CK.Core.DateTimeStamp.IsKnown">
            <summary>
            Gets whether this <see cref="T:CK.Core.DateTimeStamp"/> is initialized.
            The default constructor of a structure can not be defined and it initializes the <see cref="F:CK.Core.DateTimeStamp.TimeUtc"/> with a zero that is <see cref="F:System.DateTime.MinValue"/>
            with a <see cref="P:System.DateTime.Kind"/> set to <see cref="F:System.DateTimeKind.Unspecified"/>.
            </summary>
        </member>
        <member name="P:CK.Core.DateTimeStamp.IsInvalid">
            <summary>
            Gets whether this <see cref="T:CK.Core.DateTimeStamp"/> is the <see cref="F:CK.Core.DateTimeStamp.Invalid"/> one.
            <see cref="F:CK.Core.DateTimeStamp.TimeUtc"/> has a <see cref="P:System.DateTime.Kind"/> set to <see cref="F:System.DateTimeKind.Local"/>.
            </summary>
        </member>
        <member name="P:CK.Core.DateTimeStamp.UtcNow">
            <summary>
            Gets the current <see cref="P:System.DateTime.UtcNow"/> as a DateTimeStamp.
            </summary>
        </member>
        <member name="T:CK.Core.FileUtil">
            <summary>
            Helper functions related to file system.
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.InexistingFile">
            <summary>
            Combination of <see cref="T:System.IO.FileAttributes"/> that can not exist: it can be used to 
            tag non existing files among other existing (i.e. valid) file attributes.
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.GzipFileHeader">
            <summary>
            The file header for gzipped files.
            </summary>
        </member>
        <member name="M:CK.Core.FileUtil.GetFiles(System.String,System.String)">
            <summary>
            Returns files in a directory according to multiple file masks (separated by ';'). 
            </summary>
            <param name="path">Path of the directory to read.</param>
            <param name="multiFileMask">File masks, for example: *.gif;*.jpg;*.png.</param>
            <returns>List of files' full name (without duplicates).</returns>
        </member>
        <member name="M:CK.Core.FileUtil.NormalizePathSeparator(System.String,System.Boolean)">
            <summary>
            Canonicalizes the path: all '/' and '\' are mapped to <see cref="F:System.IO.Path.DirectorySeparatorChar"/> 
            (and <see cref="F:System.IO.Path.AltDirectorySeparatorChar"/> will also be transformed).
            </summary>
            <param name="path">The path to standardize (must be not be null). It is trimmed and if the path is empty, the empty string is returned.</param>
            <param name="ensureTrailingBackslash">
            Ensures that the normalized path will end with a <see cref="F:System.IO.Path.DirectorySeparatorChar"/>.
            It should be true for path to directories because we consider that a directory path SHOULD end with 
            the slash as often as possible.
            When <paramref name="path"/> is empty, this is not applied to preserve the fact that the string is empty.
            </param>
            <returns>A standardized path, whatever the actual <c>Path.DirectorySeparatorChar</c> is
            on the current platform.</returns>
        </member>
        <member name="F:CK.Core.FileUtil.DirectorySeparatorString">
            <summary>
            Gets the <see cref="F:System.IO.Path.DirectorySeparatorChar"/> as a string.
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.AltDirectorySeparatorString">
            <summary>
            Gets the <see cref="F:System.IO.Path.AltDirectorySeparatorChar"/> as a string.
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.FileNameUniqueTimeUtcFormat">
            <summary>
            A display format for <see cref="T:System.DateTime"/> that supports round-trips, is readable and can be used in path 
            or url (the DateTime should be in UTC since <see cref="P:System.DateTime.Kind"/> is ignored).
            Use <see cref="M:CK.Core.FileUtil.MatchFileNameUniqueTimeUtcFormat(System.String,System.Int32@,System.Int32,System.DateTime@)"/> or <see cref="M:CK.Core.FileUtil.TryParseFileNameUniqueTimeUtcFormat(System.String,System.DateTime@,System.Boolean)"/> to parse it (it uses the correct <see cref="T:System.Globalization.DateTimeStyles"/>).
            It is: @"yyyy-MM-dd HH\hmm.ss.fffffff"
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.MissingFileLastWriteTimeUtc">
            <summary>
            The time returned by <see cref="M:System.IO.File.GetLastWriteTimeUtc(System.String)"/> when the file does not exist.
            From MSDN: If the file described in the path parameter does not exist, this method returns 12:00 midnight, January 1, 1601 A.D. (C.E.) Coordinated Universal Time (UTC).
            </summary>
        </member>
        <member name="M:CK.Core.FileUtil.MatchFileNameUniqueTimeUtcFormat(System.String,System.Int32@,System.Int32,System.DateTime@)">
            <summary>
            Tries to match a DateTime that follows the <see cref="F:CK.Core.FileUtil.FileNameUniqueTimeUtcFormat"/> in a string at a given position.
            </summary>
            <param name="s">The string to match.</param>
            <param name="startAt">
            Index where the match must start (can be equal to or greater than the length of the string: the match fails).
            On success, index of the end of the match.
            </param>
            <param name="maxLength">
            Maximum index to consider in the string (it can shorten the default <see cref="P:System.String.Length"/> if 
            set to a positive value, otherwise it is set to String.Length).
            If maxLength is greater than String.Length an <see cref="T:System.ArgumentException"/> is thrown.
            </param>
            <param name="time">Result time.</param>
            <returns>True if the time has been matched.</returns>
        </member>
        <member name="M:CK.Core.FileUtil.TryParseFileNameUniqueTimeUtcFormat(System.String,System.DateTime@,System.Boolean)">
            <summary>
            Tries to parse a string formatted with the <see cref="F:CK.Core.FileUtil.FileNameUniqueTimeUtcFormat"/>.
            The string must contain only the time unless <paramref name="allowSuffix"/> is true.
            </summary>
            <param name="s">The string to parse.</param>
            <param name="time">Result time on success.</param>
            <param name="allowSuffix">True to accept a string that starts with the time and contains more text.</param>
            <returns>True if the string has been successfully parsed.</returns>
        </member>
        <member name="M:CK.Core.FileUtil.IndexOfInvalidPathChars(System.String)">
            <summary>
            Finds the first character index of any characters that are invalid in a path.
            This method (and <see cref="M:CK.Core.FileUtil.IndexOfInvalidFileNameChars(System.String)"/>) avoid the allocation of 
            the array each time <see cref="M:System.IO.Path.GetInvalidPathChars"/> is called.
            </summary>
            <param name="path">Path to check. Can not be null.</param>
            <returns>A negative value if not found.</returns>
        </member>
        <member name="M:CK.Core.FileUtil.IndexOfInvalidFileNameChars(System.String)">
            <summary>
            Finds the first character index of any characters that are invalid in a file name.
            This method (and <see cref="M:CK.Core.FileUtil.IndexOfInvalidPathChars(System.String)"/>) avoid the allocation of 
            the array each time <see cref="M:System.IO.Path.GetInvalidFileNameChars"/> is called.
            </summary>
            <param name="path">Path to check. Can not be null.</param>
            <returns>A negative value if not found.</returns>
        </member>
        <member name="M:CK.Core.FileUtil.WriteUniqueTimedFile(System.String,System.String,System.DateTime,System.Byte[],System.Boolean,System.Int32)">
            <summary>
            Creates a new necessarily unique file and writes bytes content in a directory that must exist.
            The file name is based on a <see cref="T:System.DateTime"/>, with an eventual uniquifier if a file already exists with the same name.
            </summary>
            <param name="pathPrefix">The path prefix. Must not be null. Must be a valid path and may ends with a prefix for the file name itself.</param>
            <param name="fileSuffix">Suffix for the file name. Must not be null. Typically an extension (like ".txt").</param>
            <param name="time">The time that will be used to create the file name. It should be an UTC time.</param>
            <param name="content">The bytes to write. Can be null or empty if the file must only be created.</param>
            <param name="withUTF8Bom">True to write the UTF8 Byte Order Mask (the preamble).</param>
            <param name="maxTryBeforeGuid">Maximum value for short hexa uniquifier before using a base 64 guid suffix. Must between 0 and 15 (included).</param>
            <returns>The full path name of the created file.</returns>
        </member>
        <member name="M:CK.Core.FileUtil.CreateAndOpenUniqueTimedFile(System.String,System.String,System.DateTime,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Int32)">
            <summary>
            Creates and opens a new necessarily unique file in a directory that must exist.
            The file name is based on a <see cref="T:System.DateTime"/>, with an eventual uniquifier if a file already exists with the same name.
            You can use <see cref="P:System.IO.FileStream.Name"/> to obtain the file name.
            </summary>
            <param name="pathPrefix">The path prefix. Must not be null. Must be a valid path and may ends with a prefix for the file name itself.</param>
            <param name="fileSuffix">Suffix for the file name. Must not be null. Typically an extension (like ".txt").</param>
            <param name="time">The time that will be used to create the file name. It must be an UTC time.</param>
            <param name="access">
            A constant that determines how the file can be accessed by the FileStream object. 
            It can only be <see cref="F:System.IO.FileAccess.Write"/> or <see cref="F:System.IO.FileAccess.ReadWrite"/> (when set to <see cref="F:System.IO.FileAccess.Read"/> a <see cref="T:System.ArgumentException"/> is thrown).
            This sets the CanRead and CanWrite properties of the FileStream object. 
            CanSeek is true if path specifies a disk file.
            </param>
            <param name="share">
            A constant that determines how the file will be shared by processes.
            </param>
            <param name="bufferSize">
            A positive Int32 value greater than 0 indicating the buffer size. For bufferSize values between one and eight, the actual buffer size is set to eight bytes.
            </param>
            <param name="options">Specifies additional file options.</param>
            <param name="maxTryBeforeGuid">
            Maximum value for short hexadecimal uniquifier before using a base 64 guid suffix. Must greater than 0.</param>
            <returns>An opened <see cref="T:System.IO.FileStream"/>.</returns>
        </member>
        <member name="M:CK.Core.FileUtil.MoveToUniqueTimedFile(System.String,System.String,System.String,System.DateTime,System.Int32)">
            <summary>
            Moves (renames) a file to a necessarily unique named file.
            The file name is based on a <see cref="T:System.DateTime"/>, with an eventual uniquifier if a file already exists with the same name.
            </summary>
            <param name="sourceFilePath">Path of the file to move.</param>
            <param name="pathPrefix">The path prefix. Must not be null. Must be a valid path and may ends with a prefix for the file name itself.</param>
            <param name="fileSuffix">Suffix for the file name. Must not be null. Typically an extension (like ".txt").</param>
            <param name="time">The time that will be used to create the file name. It must be an UTC time.</param>
            <param name="maxTryBeforeGuid">
            Maximum value for short hexadecimal uniquifier before using a base 64 guid suffix. Must greater than 0.
            </param>
            <returns>An opened <see cref="T:System.IO.FileStream"/>.</returns>
        </member>
        <member name="M:CK.Core.FileUtil.EnsureUniqueTimedFile(System.String,System.String,System.DateTime,System.Int32)">
            <summary>
            Gets a path to a necessarily unique named file.
            The file name is based on a <see cref="T:System.DateTime"/>, with an eventual uniquifier if a file already exists with the same name.
            </summary>
            <param name="pathPrefix">The path prefix. Must not be null. Must be a valid path and may ends with a prefix for the file name itself.</param>
            <param name="fileSuffix">Suffix for the file name. Must not be null. Typically an extension (like ".txt").</param>
            <param name="time">The time that will be used to create the file name. It must be an UTC time.</param>
            <param name="maxTryBeforeGuid">
            Maximum value for short hexadecimal uniquifier before using a base 64 guid suffix. Must greater than 0.
            </param>
            <returns>A string to a necessarily unique named file path.</returns>
        </member>
        <member name="M:CK.Core.FileUtil.CopyDirectory(System.IO.DirectoryInfo,System.IO.DirectoryInfo,System.Boolean,System.Boolean,System.Func{System.IO.FileInfo,System.Boolean},System.Func{System.IO.DirectoryInfo,System.Boolean})">
            <summary>
            Recursively copy a directory, creates it if it does not already exists. 
            Throws an IOException, if a same file exists in the target directory.
            </summary>
            <param name="src">The source directory.</param>
            <param name="target">The target directory.</param>
            <param name="withHiddenFiles">False to skip hidden files.</param>
            <param name="withHiddenFolders">False to skip hidden folders.</param>
            <param name="fileFilter">Optional predicate for directories.</param>
            <param name="dirFilter">Optional predicate for files.</param>
        </member>
        <member name="M:CK.Core.FileUtil.WaitForWriteAcccess(System.String,System.Int32)">
            <summary>
            Waits for a file to be writable or not exist (it can then be created). Do not open the file.
            Waits approximately the number of seconds given before leaving and returning false.
            </summary>
            <param name="path">The path of the file to write to.</param>
            <param name="nbMaxSecond">Maximum number of seconds to wait before returning false.</param>
            <returns>True if the file has been correctly opened (and closed) in write mode.</returns>
        </member>
        <member name="M:CK.Core.FileUtil.CompressFileToGzipFile(System.String,System.String,System.Boolean,System.Int32)">
            <summary>
            Compresses a file to another file, using GZip.
            </summary>
            <param name="sourceFilePath">The source file path.</param>
            <param name="destinationPath">The destination path. If it doesn't exist, it will be created. If it exists, it will be replaced.</param>
            <param name="deleteSourceFileOnSuccess">if set to <c>true</c>, will delete source file if no errors occured during compression.</param>
            <param name="bufferSize">Size of the buffer, in bytes.</param>
        </member>
        <member name="T:CK.Core.TemporaryFile">
            <summary>
            Small helper to automatically delete a temporary file. 
            It is mainly a secure wrapper around <see cref="M:System.IO.Path.GetTempFileName">GetTempFileName</see> that 
            creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file: the <see cref="P:Path"/>
            property exposes it.
            </summary>
        </member>
        <member name="M:CK.Core.TemporaryFile.#ctor">
            <summary>
            Initializes a new short lived <see cref="T:CK.Core.TemporaryFile"/>.
            </summary>
        </member>
        <member name="M:CK.Core.TemporaryFile.#ctor(System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.TemporaryFile"/>.
            When <paramref name="shortLived"/> is true, the <see cref="F:System.IO.FileAttributes.Temporary"/> is set on the file.
            </summary>
            <param name="shortLived">True to set the <see cref="F:System.IO.FileAttributes.Temporary"/> on the file.</param>
        </member>
        <member name="M:CK.Core.TemporaryFile.#ctor(System.String)">
            <summary>
            Initializes a new short lived <see cref="T:CK.Core.TemporaryFile"/> with an extension - the file will have a name looking like : xxxx.tmp.extension        
            </summary>
            <param name="extension">The extension of the file (example : '.png' and 'png' would both work) </param>
        </member>
        <member name="M:CK.Core.TemporaryFile.#ctor(System.Boolean,System.String)">
            <summary>
            Initializes a new <see cref="T:CK.Core.TemporaryFile"/> with an extension.
            When <paramref name="shortLived"/> is true, the <see cref="F:System.IO.FileAttributes.Temporary"/> is set on the file.
            The file will have a name looking like : xxxx.tmp.extension
            </summary>
            <param name="shortLived">True to set the <see cref="F:System.IO.FileAttributes.Temporary"/> on the file.</param>
            <param name="extension">Optional extension of the file (example : '.png' and 'png' would both work).</param>
            <remarks>
            When extension is ".", the final path will end with a ".".
            </remarks>
        </member>
        <member name="M:CK.Core.TemporaryFile.Finalize">
            <summary>
            Finalizer attempts to delete the file.
            </summary>
        </member>
        <member name="M:CK.Core.TemporaryFile.Detach">
            <summary>
            Detaches the temporary file: it will no more be automatically destroyed.
            </summary>
        </member>
        <member name="M:CK.Core.TemporaryFile.Dispose">
            <summary>
            Attempts to delete the temporary file.
            </summary>
        </member>
        <member name="P:CK.Core.TemporaryFile.Path">
            <summary>
            Gets the complete file path of the temporary file.
            It is <see cref="F:System.String.Empty"/> when the file has been <see cref="M:CK.Core.TemporaryFile.Detach"/>ed.
            The file is not opened but exists, initially empty.
            </summary>
        </member>
        <member name="P:CK.Core.TemporaryFile.IsDetached">
            <summary>
            Gets whether the temporary file is detached (its <see cref="P:CK.Core.TemporaryFile.Path"/> is <see cref="F:System.String.Empty"/>).
            </summary>
        </member>
        <member name="T:CK.Core.GrantLevel">
            <summary>
            Standard grant level: this is a simple (but often enough) way to secure a resource.
            Among the different levels, depending on the actual resource, most of them are useless and can be 
            ignored.
            But for some kind of resources all of them make sense: a "service object" (a kind of executable process) for instance can
            benefits of all these levels.
            </summary>
        </member>
        <member name="F:CK.Core.GrantLevel.Blind">
            <summary>
            Actor doesn't even know that object exists.
            </summary>
        </member>
        <member name="F:CK.Core.GrantLevel.User">
            <summary>
            Actor can see the object names and may use services provided by the object 
            but cannot see the object itself.
            </summary>
        </member>
        <member name="F:CK.Core.GrantLevel.Viewer">
            <summary>
            Actor can view the object but cannot interact with it.
            </summary>
        </member>
        <member name="F:CK.Core.GrantLevel.Contributor">
            <summary>
            Actor can contribute to the object but cannot modifiy the object itself.
            </summary>
        </member>
        <member name="F:CK.Core.GrantLevel.Editor">
            <summary>
            Actor can edit the standard properties of the object. He may not be able to 
            change more sensitive aspects such as the different names of the object.
            </summary>
        </member>
        <member name="F:CK.Core.GrantLevel.SuperEditor">
            <summary>
            Actor can edit the object, its names and any property, but can not change
            the security settings.
            </summary>
        </member>
        <member name="F:CK.Core.GrantLevel.SafeAdministrator">
            <summary>
            Actor can edit all properties of the object and can 
            change the security settings by choosing an acl among defined security
            contexts. The actor can not destroy the object.
            </summary>
        </member>
        <member name="F:CK.Core.GrantLevel.Administrator">
            <summary>
            Actor has full control on the object including its destruction. It may create 
            and configure an independent Acl for the object.
            </summary>
        </member>
        <member name="T:CK.Core.IFluentInterface">
            <summary>
            Helper interface used to hide the base <see cref="T:System.Object"/> members from the fluent API to make 
            for much cleaner Visual Studio intellisense experience. (Excellent idea borrowed from EntLib.)
            Use it on an interface: it must be the first interface (if more than one interface are supported) 
            to hide those useless methods. 
            </summary>
        </member>
        <member name="M:CK.Core.IFluentInterface.GetType">
            <summary/>
        </member>
        <member name="M:CK.Core.IFluentInterface.GetHashCode">
            <summary/>
        </member>
        <member name="M:CK.Core.IFluentInterface.ToString">
            <summary/>
        </member>
        <member name="M:CK.Core.IFluentInterface.Equals(System.Object)">
            <summary/>
        </member>
        <member name="T:CK.Core.IMergeable">
            <summary>
            Simple interface to support merging of information from external objects.
            </summary>
        </member>
        <member name="M:CK.Core.IMergeable.Merge(System.Object,System.IServiceProvider)">
            <summary>
            Attempts to merge this object with the given one.
            This method should not raise any exception. Instead, false should be returned. 
            If an exception is raised, callers should handle the exception and behaves as if the method returned false.
            </summary>
            <param name="source">Source object to merge into this one.</param>
            <param name="services">Optional services (can be null) that can be injected into the merge process.</param>
            <returns>True if the merge succeeded, false if the merge failed or is not possible.</returns>
        </member>
        <member name="T:CK.Core.ISimpleServiceContainer">
            <summary>
            Defines a container for services.
            </summary>
        </member>
        <member name="M:CK.Core.ISimpleServiceContainer.Add(System.Type,System.Func{System.Object},System.Action{System.Object})">
            <summary>
            Registers a service associated to a callback (and an optional callback that will be called when the service will be removed).
            The <paramref name="serviceInstance"/> is called as long as no service has been obtained (serviceInstance returns null). 
            Once the actual service has been obtained, it is kept and serviceInstance is not called anymore.
            </summary>
            <param name="serviceType">Service type to register. It must not already exist in this container otherwise an exception is thrown.</param>
            <param name="serviceInstance">Delegate to call when needed. Can not be null.</param>
            <param name="onRemove">Optional action that will be called whenever <see cref="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.ISimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>
            is called and a service as been successfuly obtained.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ISimpleServiceContainer.Add(System.Type,System.Object,System.Action{System.Object})">
            <summary>
            Registers a service with its implementation (and an optional callback that will be called when the service will be removed).
            </summary>
            <param name="serviceType">Service type to register. It must not already exist in this container otherwise an exception is thrown.</param>
            <param name="serviceInstance">Implementation of the service. Can not be null.</param>
            <param name="onRemove">Optional action that will be called whenever <see cref="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.ISimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)">
            <summary>
            Unregisters a service. Can be called even if the service does not exist.
            The service is first removed and then the OnRemove associated action is called if it exists:
            this enables OnRemove action to be bound to a method that safely calls back this Remove method.
            </summary>
            <param name="serviceType">Service type to unregister.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ISimpleServiceContainer.Clear">
            <summary>
            Unregisters all the services. Any "on remove" actions are executed.
            </summary>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ISimpleServiceContainer.AddDisabled(System.Type)">
            <summary>
            Disables a service: null will always be returned by this <see cref="M:System.IServiceProvider.GetService(System.Type)"/>
            regardless of any fallbacks that may exist for this container.
            </summary>
            <remarks>
            This is not the same as calling <see cref="M:CK.Core.ISimpleServiceContainer.Add(System.Type,System.Func{System.Object},System.Action{System.Object})"/> with a null instance. A null instance for a service (a callback that always returns null)
            is nearly the same as calling <see cref="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)"/>: any fallbacks (to a base <see cref="T:System.IServiceProvider"/> for example) can occur.
            This one is stronger since this must prevent fallbacks.
            </remarks>
            <param name="serviceType">Service type to disable. It must not already exist in this container otherwise an exception is thrown.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="T:CK.Core.ISimpleTypeFinder">
            <summary>
            This simple interface allows to resolve types from names.
            </summary>
            <remarks>
            Types mapping (ie. changing the simple rule that says that the name of a type is simply the type's assembly qualified name) is an 
            option that should be used with care.    
            </remarks>
        </member>
        <member name="M:CK.Core.ISimpleTypeFinder.ResolveType(System.String,System.Boolean)">
            <summary>
            Maps and resolves the <see cref="T:System.Type"/> from the assembly qualified name set as parameter.
            You should use the <see cref="F:CK.Core.SimpleTypeFinder.Default"/> or <see cref="F:CK.Core.SimpleTypeFinder.WeakDefault"/> standard
            implementations.
            If <paramref name="throwOnError"/> is true, a <see cref="T:System.TypeLoadException"/> will be fired if the resolution fails.
            </summary>
            <param name="externalName">Assembly qualified name of the type</param>
            <param name="throwOnError">
            True to ALWAYS throw a <see cref="T:System.TypeLoadException"/> if the type is not found. 
            It may also throw <see cref="T:System.ArgumentNullException"/> and <see cref="T:System.ArgumentException"/> when the assembly qualified name is not valid
            False prevents any exception from being thrown and simply returns null.
            </param>
            <returns>The type or null if not found and <paramref name="throwOnError"/> is false.</returns>
            <exception cref="T:System.TypeLoadException">
            When <paramref name="throwOnError"/> is true, always throws a TypeLoadException whatever the actual exception is.
            The original error (not a <see cref="T:System.TypeLoadException"/>) is available in the <see cref="P:System.Exception.InnerException"/>.
            </exception>
        </member>
        <member name="T:CK.Core.ISimpleTypeNaming">
            <summary>
            This simple interface allows to obtain names from types.
            This can be used in conjuction with <see cref="T:CK.Core.ISimpleTypeFinder"/>.
            </summary>
        </member>
        <member name="M:CK.Core.ISimpleTypeNaming.GetTypeName(System.Type)">
            <summary>
            Gets an external type name.
            </summary>
            <param name="t">The type for which an external type name must be obtained.</param>
            <returns>
            A string that represents the given type. 
            Can default to <see cref="P:System.Type.AssemblyQualifiedName"/>.
            </returns>
        </member>
        <member name="T:CK.Core.R">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:CK.Core.R.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:CK.Core.R.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:CK.Core.R.ActivityMonitorBoundClientMultipleRegister">
            <summary>
              Looks up a localized string similar to A &apos;{0}&apos; can be registered in only one IActivityMonitor.Output at the same time. Unregister it before Registering it in another monitor..
            </summary>
        </member>
        <member name="P:CK.Core.R.ActivityMonitorConcurrentThreadAccess">
            <summary>
              Looks up a localized string similar to Concurrent accesses from 2 threads to the same ActivityMonitor has been detected. Only one thread at a time can interact with an ActivityMonitor..
            </summary>
        </member>
        <member name="P:CK.Core.R.ActivityMonitorDependentTokenMustBeDelayedLaunch">
            <summary>
              Looks up a localized string similar to Dependent token must have been created with CreateToken( true ) to enable Lauch( token ) to be called later (or CreateTokenWithTopic)..
            </summary>
        </member>
        <member name="P:CK.Core.R.ActivityMonitorErrorWhileGetConclusionText">
            <summary>
              Looks up a localized string similar to Unexpected error while getting conclusion text: &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:CK.Core.R.ActivityMonitorInvalidLogLevel">
            <summary>
              Looks up a localized string similar to The level must be a valid level (Trace, Info, Warn, Error or Fatal)..
            </summary>
        </member>
        <member name="P:CK.Core.R.ActivityMonitorReentrancyCallOnly">
            <summary>
              Looks up a localized string similar to Only reentrant calls to this method are supported..
            </summary>
        </member>
        <member name="P:CK.Core.R.ActivityMonitorReentrancyError">
            <summary>
              Looks up a localized string similar to A reentrant call in an ActivityMonitor has been detected. A monitor usage must not trigger another operation on the same monitor..
            </summary>
        </member>
        <member name="P:CK.Core.R.ActivityMonitorReentrancyReleaseError">
            <summary>
              Looks up a localized string similar to Internal error: Error during release reentrancy operation. Thread id={0} entered whereas release is called from thread &apos;{1}&apos;, id={2}..
            </summary>
        </member>
        <member name="P:CK.Core.R.ActivityMonitorTagMustBeRegistered">
            <summary>
              Looks up a localized string similar to The Tag (CKTrait) must be registered in ActivityMonitor.Tags..
            </summary>
        </member>
        <member name="P:CK.Core.R.AggregatedExceptionsMustContainAtLeastOne">
            <summary>
              Looks up a localized string similar to AggregatedExceptions must contain at least one exception..
            </summary>
        </member>
        <member name="P:CK.Core.R.AppSettingsAlreadyInitialized">
            <summary>
              Looks up a localized string similar to ApplicationSettings have already been initialized.It can be initialized only once..
            </summary>
        </member>
        <member name="P:CK.Core.R.AppSettingsDefaultInitializationFailed">
            <summary>
              Looks up a localized string similar to Unable to initialize AppSettings, the default fallback to System.Configuration.ConfigurationManager.AppSettings can not be generated since System.Configuration assembly is not available..
            </summary>
        </member>
        <member name="P:CK.Core.R.AppSettingsRequiredConfigurationBadType">
            <summary>
              Looks up a localized string similar to Required AppSettings configuration named &apos;{0}&apos; is missising: it must be a &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:CK.Core.R.AppSettingsRequiredConfigurationMissing">
            <summary>
              Looks up a localized string similar to Required AppSettings configuration named &apos;{0}&apos; is missising..
            </summary>
        </member>
        <member name="P:CK.Core.R.ArgumentCountNegative">
            <summary>
              Looks up a localized string similar to Argument count can not be negative..
            </summary>
        </member>
        <member name="P:CK.Core.R.ArgumentMustNotBeNullOrWhiteSpace">
            <summary>
              Looks up a localized string similar to Argument must not be null or whitespace..
            </summary>
        </member>
        <member name="P:CK.Core.R.ClosedByBridgeRemoved">
            <summary>
              Looks up a localized string similar to Prematurely closed by Bridge removed..
            </summary>
        </member>
        <member name="P:CK.Core.R.DateTimeMustBeUtc">
            <summary>
              Looks up a localized string similar to DateTime must be Utc. Use DateTime.UtcNow to obtain it for instance..
            </summary>
        </member>
        <member name="P:CK.Core.R.DirectServicesCanNotBeDisabled">
            <summary>
              Looks up a localized string similar to Service {0} is direcly supported by the container. It can not be disabled..
            </summary>
        </member>
        <member name="P:CK.Core.R.ErrorWhileCollectorRaiseError">
            <summary>
              Looks up a localized string similar to An error handler raised the error. It has been removed from the CriticalErrorCollector.OnErrorFromBackgroundThreads event..
            </summary>
        </member>
        <member name="P:CK.Core.R.ExceptionWhileResolvingType">
            <summary>
              Looks up a localized string similar to An exception occured while resolving type: {0}..
            </summary>
        </member>
        <member name="P:CK.Core.R.ExpectedXmlAttribute">
            <summary>
              Looks up a localized string similar to Expected attribute &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:CK.Core.R.ExpectedXmlEndElement">
            <summary>
              Looks up a localized string similar to Expected EndElement token named {0}..
            </summary>
        </member>
        <member name="P:CK.Core.R.FactoryTesterMismatch">
            <summary>
              Looks up a localized string similar to The &apos;factory&apos; function must create an item that satisfies the &apos;tester&apos; function..
            </summary>
        </member>
        <member name="P:CK.Core.R.FIFOBufferEmpty">
            <summary>
              Looks up a localized string similar to FIFOBuffer is empty..
            </summary>
        </member>
        <member name="P:CK.Core.R.FileMustExist">
            <summary>
              Looks up a localized string similar to File must exist..
            </summary>
        </member>
        <member name="P:CK.Core.R.FileUtilNoReadOnlyWhenCreateFile">
            <summary>
              Looks up a localized string similar to Access set to FileAccess.Read is stupid when creating a file..
            </summary>
        </member>
        <member name="P:CK.Core.R.FileUtilUnableToCreateUniqueTimedFile">
            <summary>
              Looks up a localized string similar to Unable to create a unique timed file..
            </summary>
        </member>
        <member name="P:CK.Core.R.InnerExceptionMustBeTheFirstAggregatedException">
            <summary>
              Looks up a localized string similar to The InnerException must be the first AggregatedExceptions..
            </summary>
        </member>
        <member name="P:CK.Core.R.InvalidAssemblyQualifiedName">
            <summary>
              Looks up a localized string similar to &quot;{0}&quot; is not a valid assembly qualified name..
            </summary>
        </member>
        <member name="P:CK.Core.R.InvalidRootLogPath">
            <summary>
              Looks up a localized string similar to {2} = &apos;{0}&apos; is invalid: unable to create a test file in &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:CK.Core.R.MustBeAMarshalByRefObject">
            <summary>
              Looks up a localized string similar to refObject Must be a MarshalByRefObject..
            </summary>
        </member>
        <member name="P:CK.Core.R.PossibleWrongOverloadUseWithException">
            <summary>
              Looks up a localized string similar to Possible use of the wrong overload: Use the form that takes a first parameter of type Exception and then the string text instead of this ( string format, object arg0, ... ) method to log the exception, or calls this overload explicitely with the Exception.Message string..
            </summary>
        </member>
        <member name="P:CK.Core.R.RootLogPathMustBeSet">
            <summary>
              Looks up a localized string similar to {0} must be set to a valid, writeable, folder. You can set it programmatically at the start of your program or use the &lt;appSettings&gt; section of the application config file: &lt;configuration&gt;\r\n &lt;appSettings&gt;\r\n  &lt;add key=&quot;{0}&quot; value=&quot;(path)&quot; /&gt;\r\n &lt;/appSettings&gt;\r\n&lt;/configuration&gt;.
            </summary>
        </member>
        <member name="P:CK.Core.R.ServiceAlreadyDirectlySupported">
            <summary>
              Looks up a localized string similar to Service {0} is directly supported by the container..
            </summary>
        </member>
        <member name="P:CK.Core.R.ServiceAlreadyRegistered">
            <summary>
              Looks up a localized string similar to Service {0} is already registered by the container..
            </summary>
        </member>
        <member name="P:CK.Core.R.ServiceImplCallbackTypeMismatch">
            <summary>
              Looks up a localized string similar to Service {0} is not implemented by object {1} returned by the callback..
            </summary>
        </member>
        <member name="P:CK.Core.R.ServiceImplTypeMismatch">
            <summary>
              Looks up a localized string similar to Service {0} is not implemented by object {1}..
            </summary>
        </member>
        <member name="P:CK.Core.R.SimpleMultiActionNullAction">
            <summary>
              Looks up a localized string similar to One of the action is null..
            </summary>
        </member>
        <member name="P:CK.Core.R.SystemActivityMonitorRootLogPathSetOnlyOnce">
            <summary>
              Looks up a localized string similar to SystemActivityMonitor.RootLogPath must be set only once and before any access to it if defined in application config (in the AppSettings section)..
            </summary>
        </member>
        <member name="P:CK.Core.R.TraitsMustBelongToTheSameContext">
            <summary>
              Looks up a localized string similar to Traits must belong to the same context..
            </summary>
        </member>
        <member name="P:CK.Core.R.UnregisteredServiceInServiceProvider">
            <summary>
              Looks up a localized string similar to Unable to find service &apos;{0}&apos;..
            </summary>
        </member>
        <member name="T:CK.Core.SetOperation">
            <summary>
            Defines the six basic operations available between two sets.
            </summary>
        </member>
        <member name="F:CK.Core.SetOperation.None">
            <summary>
            No operation.
            </summary>
        </member>
        <member name="F:CK.Core.SetOperation.Union">
            <summary>
            Union of the sets (keeps items of first or second set).
            </summary>
        </member>
        <member name="F:CK.Core.SetOperation.Intersect">
            <summary>
            Intersection of the sets (keeps only items that belong to both sets).
            </summary>
        </member>
        <member name="F:CK.Core.SetOperation.Except">
            <summary>
            Exclusion (keeps only items of the first that do not belong to the second one).
            </summary>
        </member>
        <member name="F:CK.Core.SetOperation.SymetricExcept">
            <summary>
            Symetric exclusion (keeps items that belong to first or second set but not to both) - The XOR operation.
            </summary>
        </member>
        <member name="F:CK.Core.SetOperation.Replace">
            <summary>
            Replace the first set by the second one.
            </summary>
        </member>
        <member name="T:CK.Core.SimpleServiceContainer">
            <summary>
            Service container (that is a <see cref="T:System.IServiceProvider"/>) subordinated to an optional base IServiceProvider 
            that acts as a fallback if the service is not found at this level.
            Service creation may be deferred thanks to callback registration and an optional remove callback can be registered
            with each entry.
            </summary>
            <remarks>
            This container is registered as the service associated to <see cref="T:System.IServiceProvider"/> and <see cref="T:CK.Core.ISimpleServiceContainer"/>
            thanks to the overridable <see cref="M:CK.Core.SimpleServiceContainer.GetDirectService(System.Type)"/>. This method may be overridden to return other built-in services: these services
            take precedence over the registered services.
            </remarks>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.#ctor">
            <summary>
            Initializes a new <see cref="T:CK.Core.SimpleServiceContainer"/>.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.#ctor(System.IServiceProvider)">
            <summary>
            Initializes a new <see cref="T:CK.Core.SimpleServiceContainer"/> with a <see cref="P:CK.Core.SimpleServiceContainer.BaseProvider"/>.
            </summary>
            <param name="baseProvider">Base <see cref="T:System.IServiceProvider"/> provider.</param>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Add(System.Type,System.Func{System.Object},System.Action{System.Object})">
            <summary>
            Registers a service associated to a callback (and an optional callback that will be called when the service will be removed).
            The <paramref name="serviceInstance"/> is called as long as no service has been obtained (serviceInstance returns null). 
            Once the actual service has been obtained, it is kept and serviceInstance is not called anymore.
            </summary>
            <param name="serviceType">Service type to register. It must not already exist in this container otherwise an exception is thrown.</param>
            <param name="serviceInstance">Delegate to call when needed. Can not be null.</param>
            <param name="onRemove">Optional action that will be called whenever <see cref="M:CK.Core.SimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.SimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>
            is called and a service as been successfully obtained.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Add(System.Type,System.Object,System.Action{System.Object})">
            <summary>
            Registers a service with its implementation (and an optional callback that will be called when the service will be removed).
            </summary>
            <param name="serviceType">Service type to register. It must not already exist in this container otherwise an exception is thrown.</param>
            <param name="serviceInstance">Implementation of the service. Can not be null.</param>
            <param name="onRemove">Optional action that will be called whenever <see cref="M:CK.Core.SimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.SimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.AddDisabled(System.Type)">
            <summary>
            Disables a service: null will always be returned by this <see cref="M:System.IServiceProvider.GetService(System.Type)"/>
            regardless of any fallbacks from <see cref="P:CK.Core.SimpleServiceContainer.BaseProvider"/>. 
            Direct services returned by <see cref="M:CK.Core.SimpleServiceContainer.GetDirectService(System.Type)"/> can not be disabled.
            </summary>
            <remarks>
            This is not the same as calling <see cref="M:CK.Core.SimpleServiceContainer.Add(System.Type,System.Func{System.Object},System.Action{System.Object})"/> with a null instance. A null instance for a service (a callback that always returns null)
            is nearly the same as calling <see cref="M:CK.Core.SimpleServiceContainer.Remove(System.Type)"/>: any fallbacks (to a base <see cref="T:System.IServiceProvider"/> for example) can occur.
            This is stronger since this must prevent fallbacks.
            </remarks>
            <param name="serviceType">Service type to disable. It must not already exist in this container otherwise an exception is thrown.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Remove(System.Type)">
            <summary>
            Unregisters a service. Can be called even if the service does not exist.
            The service is first removed and then the OnRemove associated action is called if it exists.
            </summary>
            <param name="serviceType">Service type to unregister.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Clear">
            <summary>
            Unregisters all the services. Any "on remove" actions are executed.
            </summary>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.GetService(System.Type)">
            <summary>
            Implements <see cref="M:System.IServiceProvider.GetService(System.Type)"/>.
            </summary>
            <param name="serviceType">Type of the service to obtain.</param>
            <returns>Built-in service, registered service, service from <see cref="P:CK.Core.SimpleServiceContainer.BaseProvider"/> or null.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.GetDirectService(System.Type)">
            <summary>
            Must return built-in services if any. These services take precedence over any registered services.
            This base implementation returns this object for <see cref="T:System.IServiceProvider"/> and <see cref="T:CK.Core.ISimpleServiceContainer"/>.
            </summary>
            <param name="serviceType">Type of the service to obtain.</param>
            <returns>A built-in service or null.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Finalize">
            <summary>
            Ensures that potential unmanaged resources are correctly released by calling <see cref="M:CK.Core.SimpleServiceContainer.Dispose(System.Boolean)"/> with false.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Dispose">
            <summary>
            Disposing calls <see cref="M:CK.Core.SimpleServiceContainer.Clear"/> to unregister all services. Any "on remove" actions are executed.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Dispose(System.Boolean)">
            <summary>
            When <paramref name="disposing"/> is true, calls <see cref="M:CK.Core.SimpleServiceContainer.Clear"/> to unregister all services. 
            Any "on remove" actions are executed.
            <param name="disposing">Whether <see cref="M:CK.Core.SimpleServiceContainer.Dispose"/> has been called.</param>
            </summary>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.DoAdd(System.Type,CK.Core.SimpleServiceContainer.ServiceEntry)">
            <summary>
            Correct ArgumentException throw by a Dictionary when adding an existing key. 
            </summary>
        </member>
        <member name="P:CK.Core.SimpleServiceContainer.BaseProvider">
            <summary>
            Gets or sets the <see cref="T:System.IServiceProvider"/> that is queried whenever a service
            is not found in this container.
            </summary>
        </member>
        <member name="T:CK.Core.SimpleTypeFinder">
            <summary>
            Very simple default implementation of the <see cref="T:CK.Core.ISimpleTypeFinder"/>: it can be used as a base class.
            Static <see cref="F:CK.Core.SimpleTypeFinder.Default"/> and <see cref="F:CK.Core.SimpleTypeFinder.WeakDefault"/> are available.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleTypeFinder.Default">
            <summary>
            Default implementation for <see cref="T:CK.Core.ISimpleTypeFinder"/>.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleTypeFinder.WeakDefault">
            <summary>
            An implementation of <see cref="T:CK.Core.ISimpleTypeFinder"/> that can be used to load types regardless of 
            the version, culture, architecture and public key token (strongly-named assemblies) of the type names.
            (See <see cref="M:CK.Core.SimpleTypeFinder.WeakenAssemblyQualifiedName(System.String,System.String@)"/>.)
            </summary>
            <remarks>
            The type name used is in the following format: "TypeNamespace.TypeName, AssemblyName".
            </remarks>
        </member>
        <member name="M:CK.Core.SimpleTypeFinder.ResolveType(System.String,System.Boolean)">
            <summary>
            Simple implementation that checks that the assembly qualified name set as parameter is valid, then calls <see cref="M:System.Type.GetType(System.String,System.Boolean)"/>.
            </summary>
            <param name="assemblyQualifiedName">The assembly qualified name of a type.</param>
            <param name="throwOnError">
            True to ALWAYS throw a <see cref="T:System.TypeLoadException"/> if the type is not found.
            It may also throw <see cref="T:System.ArgumentNullException"/> and <see cref="T:System.ArgumentException"/> when the assembly qualified name is not valid
            False prevents any exception from being thrown and simply returns null.
            </param>
            <returns>The type or null if not found and <paramref name="throwOnError"/> is false.</returns>
            <exception cref="T:System.TypeLoadException">
            When <paramref name="throwOnError"/> is true, always throws this kind of exception.
            The original error (not a <see cref="T:System.TypeLoadException"/>) is available in the <see cref="P:System.Exception.InnerException"/>.
            </exception>
        </member>
        <member name="M:CK.Core.SimpleTypeFinder.WeakenAssemblyQualifiedName(System.String,System.String@)">
            <summary>
            Helper method to remove version, architecture, publiTokenKey and culture from the assembly qualified name into its assembly name passed as parameter.
            "CK.Core.SimpleTypeFinder, CK.Core, version=1.0.0, culture='fr-FR'" gives "CK.Core.SimpleTypeFinder, CK.Core".
            Used to remove strong name from an strongly-named assembly qualified name
            </summary>
            <param name="assemblyQualifiedName">The assembly qualified name to weaken.</param>
            <param name="weakTypeName">The weakened assembly qualified name on output or an empty string.</param>
            <returns>True if the split has been successfully done. False otherwise.</returns>
        </member>
        <member name="M:CK.Core.SimpleTypeFinder.SplitAssemblyQualifiedName(System.String,System.String@,System.String@)">
            <summary>
            Helper method to split the assembly qualified name into its assembly name and full type name.
            "CK.Core.SimpleTypeFinder, CK.Core, version=1.0.0, culture='fr-FR'" gives "CK.Core.SimpleTypeFinder" and "CK.Core, version=1.0.0, culture='fr-FR'".
            </summary>
            <param name="assemblyQualifiedName">The assembly qualified name to split.</param>
            <param name="fullTypeName">Full type name on output or an empty string.</param>
            <param name="assemblyFullName">Weaken type name on output or an empty string.</param>
            <returns>True if the weakening has been successfully done. False otherwise.</returns>
        </member>
        <member name="M:CK.Core.SimpleTypeFinder.SplitAssemblyFullName(System.String,System.String@,System.String@)">
            <summary>
            Helper method to split an assembly full name in two parts: 
            "CK.Core, version=1.0.0, culture='fr-FR'" gives "CK.Core" and "version=1.0.0, culture='fr-FR'".
            </summary>
            <param name="assemblyFullName">The assembly full name.</param>
            <param name="assemblyName">Set to assembly name only.</param>
            <param name="versionCultureAndPublicKeyToken">Set to extra information.</param>
            <returns>True if the split worked. False otherwise.</returns>
        </member>
        <member name="T:CK.Core.CKTrait">
            <summary>
            A trait is an immutable object (thread-safe), associated to a unique string inside a <see cref="P:CK.Core.CKTrait.Context"/>, that can be atomic ("Alt", "Home", "Ctrl") or 
            combined ("Alt|Ctrl", "Alt|Ctrl|Home"). The only way to obtain a CKTrait is to call <see cref="M:CK.Core.CKTraitContext.FindOrCreate(System.String)"/> (from 
            a string) or to use one of the available combination methods (<see cref="M:CK.Core.CKTrait.Union(CK.Core.CKTrait)"/>, <see cref="M:CK.Core.CKTrait.Except(CK.Core.CKTrait)"/>, <see cref="M:CK.Core.CKTrait.SymmetricExcept(CK.Core.CKTrait)"/> or <see cref="M:CK.Core.CKTrait.Intersect(CK.Core.CKTrait)"/> ).
            </summary>
            <remarks>
            A CKTrait is not serializable: since it is relative to <see cref="T:CK.Core.CKTraitContext"/>, it must be recreated in the right context. A CKTraitContext is typically
            a static object that exists in the origin application domain. A CKTrait must be serialized as its <see cref="M:CK.Core.CKTrait.ToString"/> representation and it is up to the 
            code to call <see cref="M:CK.Core.CKTraitContext.FindOrCreate(System.String)"/> on the appropriate context when deserializing it.
            </remarks>
        </member>
        <member name="M:CK.Core.CKTrait.#ctor(CK.Core.CKTraitContext)">
            <summary>
            Initializes the new empty trait of a Context.
            </summary>
        </member>
        <member name="M:CK.Core.CKTrait.#ctor(CK.Core.CKTraitContext,System.String)">
            <summary>
            Initializes a new atomic trait.
            </summary>
        </member>
        <member name="M:CK.Core.CKTrait.#ctor(CK.Core.CKTraitContext,System.String,CK.Core.ICKReadOnlyList{CK.Core.CKTrait})">
            <summary>
            Initializes a new combined trait.
            </summary>
        </member>
        <member name="M:CK.Core.CKTrait.ToString">
            <summary>
            Gets the multi traits in an ordered manner separated by +.
            </summary>
            <returns>This multi trait as a string.</returns>
        </member>
        <member name="M:CK.Core.CKTrait.CompareTo(CK.Core.CKTrait)">
            <summary>
            Compares this trait with another one.
            The <see cref="P:CK.Core.CKTrait.Context"/> is the primary key (see <see cref="M:CK.Core.CKTraitContext.CompareTo(CK.Core.CKTraitContext)"/>), then comes 
            the number of traits (more traits is greater) and then comes the string representation of the trait in 
            reverse lexical order (<see cref="P:System.StringComparer.Ordinal"/>): "A" is greater than "B".
            </summary>
            <param name="other">The trait to compare to.</param>
            <returns>A negative, zero or positive value.</returns>
        </member>
        <member name="M:CK.Core.CKTrait.Equals(CK.Core.CKTrait)">
            <summary>
            Checks equality of this trait with another one.
            </summary>
            <param name="other">The trait to compare to.</param>
            <returns>True on equality.</returns>
        </member>
        <member name="M:CK.Core.CKTrait.IsSupersetOf(CK.Core.CKTrait)">
            <summary>
            Checks if each and every atomic traits of <paramref name="other"/> exists in this trait.
            </summary>
            <param name="other">The trait(s) to find.</param>
            <returns>True if all the specified traits appear in this trait.</returns>
            <remarks>
            Note that <see cref="P:CK.Core.CKTraitContext.EmptyTrait"/> is contained (in the sense of this IsSupersetOf method) by definition in any trait 
            (including itself): this is the opposite of the <see cref="M:CK.Core.CKTrait.Overlaps(CK.Core.CKTrait)"/> method.
            </remarks>
        </member>
        <member name="M:CK.Core.CKTrait.Overlaps(CK.Core.CKTrait)">
            <summary>
            Checks if one of the atomic traits of <paramref name="other"/> exists in this trait.
            </summary>
            <param name="other">The trait to find.</param>
            <returns>Returns true if one of the specified traits appears in this trait.</returns>
            <remarks>
            When true, this ensures that <see cref="M:CK.Core.CKTrait.Intersect(CK.Core.CKTrait)"/>( <paramref name="other"/> ) != <see cref="P:CK.Core.CKTraitContext.EmptyTrait"/>. 
            The empty trait is not contained (in the sense of this ContainsOne method) in any trait (including itself). This is the opposite
            of the <see cref="M:CK.Core.CKTrait.IsSupersetOf(CK.Core.CKTrait)"/> method.
            </remarks>
        </member>
        <member name="M:CK.Core.CKTrait.Intersect(CK.Core.CKTrait)">
            <summary>
            Obtains a <see cref="T:CK.Core.CKTrait"/> that contains the atomic traits from both this trait and <paramref name="other"/>.
            </summary>
            <param name="other">Trait that must be kept.</param>
            <returns>The resulting trait.</returns>
        </member>
        <member name="M:CK.Core.CKTrait.Union(CK.Core.CKTrait)">
            <summary>
            Obtains a <see cref="T:CK.Core.CKTrait"/> that combines this one and 
            the trait(s) specified by the parameter. 
            </summary>
            <param name="other">Trait to add.</param>
            <returns>The resulting trait.</returns>
        </member>
        <member name="M:CK.Core.CKTrait.Except(CK.Core.CKTrait)">
            <summary>
            Obtains a <see cref="T:CK.Core.CKTrait"/> from which trait(s) specified by the parameter are removed.
            </summary>
            <param name="other">Trait to remove.</param>
            <returns>The resulting trait.</returns>
        </member>
        <member name="M:CK.Core.CKTrait.SymmetricExcept(CK.Core.CKTrait)">
            <summary>
            Obtains a <see cref="T:CK.Core.CKTrait"/> where the atomic traits of <paramref name="other"/> are removed (resp. added) depending 
            on whether they exist (resp. do not exist) in this trait. This is like an Exclusive Or (XOR).
            </summary>
            <param name="other">Trait to toggle.</param>
            <returns>The resulting trait.</returns>
        </member>
        <member name="M:CK.Core.CKTrait.Apply(CK.Core.CKTrait,CK.Core.SetOperation)">
            <summary>
            Applies the given <see cref="T:CK.Core.SetOperation"/>.
            </summary>
            <param name="other">Trait to combine.</param>
            <param name="operation">Set operation.</param>
            <returns>Resulting trait.</returns>
        </member>
        <member name="M:CK.Core.CKTrait.Process(CK.Core.CKTrait,CK.Core.CKTrait,System.Func{CK.Core.CKTrait,System.Boolean},System.Func{CK.Core.CKTrait,System.Boolean},System.Func{CK.Core.CKTrait,System.Boolean})">
            <summary>
            Common process function where 3 predicates drive the result: each atomic trait is submitted to one of the 3 predicates
            depending on whether it is only in the left, only in the right or appears in both traits.
            When returning false, a predicate stops the process.
            </summary>
            <remarks>
            When this predicate is 'adding the trait to a list', we can draw the following table where '1' means the predicate exists and '0' means
            no predicate (or the 'always true' one):
            
                        0, 0, 0 =  -- 'Empty'
            Intersect   0, 0, 1 = Intersect (keep commons) => /Toggle
                        0, 1, 0 =  -- 'Cleanup' (keep theirs only) => /Remove 
                        0, 1, 1 =  -- 'Other' (keep theirs and commons, reject mine) => /This
            Except      1, 0, 0 = Remove (keep mine only) => /Cleanup
                        1, 0, 1 =  -- 'This' (keep mine and commons and reject theirs) => /Other
            Toggle      1, 1, 0 = Toggle (keep mine, theirs, but reject commons) => /Intersect
            Union       1, 1, 1 = Add
            
            This shows that our 4 methods Intersect, Remove, Toggle and Add cover the interesting cases - others are either symetric or useless.
            </remarks>
        </member>
        <member name="P:CK.Core.CKTrait.Context">
            <summary>
            Gets the <see cref="T:CK.Core.CKTraitContext"/> to which this trait belongs. 
            </summary>
        </member>
        <member name="P:CK.Core.CKTrait.AtomicTraits">
            <summary>
            Gets the atomic traits that this trait contains.
            This list does not contain the empty trait and is sorted according to the name of the atomic traits (lexical order): this is the 
            same as the <see cref="M:CK.Core.CKTrait.ToString"/> representation.
            Note that it is in reverse order regarding <see cref="M:CK.Core.CKTrait.CompareTo(CK.Core.CKTrait)"/> ("A" that is stronger than "B" appears before "B").
            </summary>
        </member>
        <member name="P:CK.Core.CKTrait.IsEmpty">
            <summary>
            Gets a boolean indicating whether this trait is the empty trait (<see cref="P:CK.Core.CKTrait.AtomicTraits"/> is empty
            and <see cref="P:CK.Core.CKTrait.Fallbacks"/> contains only itself).
            </summary>
        </member>
        <member name="P:CK.Core.CKTrait.IsAtomic">
            <summary>
            Gets a boolean indicating whether this trait contains zero 
            (the empty trait is considered as an atomic trait) or only one atomic trait.
            </summary>
            <remarks>
            For atomic traits (and the empty trait itself), <see cref="P:CK.Core.CKTrait.Fallbacks"/> contains only the <see cref="P:CK.Core.CKTraitContext.EmptyTrait"/>.
            </remarks>
        </member>
        <member name="P:CK.Core.CKTrait.FallbacksCount">
            <summary>
            Gets the number of <see cref="P:CK.Core.CKTrait.Fallbacks"/>. It is 2^<see cref="P:CK.Core.CKTrait.AtomicTraits"/>.<see cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count"/> - 1 since this
            trait itself does not appear in the fallbacks, but it is always 1 for atomic and the empty trait (the empty trait always ends the list).
            </summary>
        </member>
        <member name="P:CK.Core.CKTrait.Fallbacks">
            <summary>
            Gets an enumeration of fallbacks to consider for this trait ordered from best to worst.
            This trait does not start the list but the <see cref="P:CK.Core.CKTraitContext.EmptyTrait"/> always ends this list.
            </summary>
            <remarks>
            For atomic traits (and the empty trait itself), <see cref="P:CK.Core.CKTrait.Fallbacks"/> contains only the <see cref="P:CK.Core.CKTraitContext.EmptyTrait"/>.
            </remarks>
        </member>
        <member name="T:CK.Core.CKTraitContext">
            <summary>
            Thread-safe registration root for <see cref="T:CK.Core.CKTrait"/> objects.
            </summary>
        </member>
        <member name="M:CK.Core.CKTraitContext.#ctor(System.String,System.Char)">
            <summary>
            Initializes a new context for traits with the given separator.
            </summary>
            <param name="name">Name for the context. Must not be null nor whitespace.</param>
            <param name="separator">Separator if it must differ from '|'.</param>
        </member>
        <member name="M:CK.Core.CKTraitContext.CompareTo(CK.Core.CKTraitContext)">
            <summary>
            Compares this context to another one.
            The key is <see cref="P:CK.Core.CKTraitContext.Separator"/>, then <see cref="P:CK.Core.CKTraitContext.Name"/> and if they are equal, a unique number is 
            used to order the two contexts.
            </summary>
            <param name="other">Context to compare.</param>
            <returns>0 for the exact same object (ReferenceEquals), greater/lower than 0 otherwise.</returns>
        </member>
        <member name="M:CK.Core.CKTraitContext.FindOrCreate(System.String)">
            <summary>
            Obtains a <see cref="T:CK.Core.CKTrait"/> (either combined or atomic).
            </summary>
            <param name="traits">Atomic trait or traits separated by <see cref="P:CK.Core.CKTraitContext.Separator"/>.</param>
            <returns>A trait.</returns>
        </member>
        <member name="M:CK.Core.CKTraitContext.FindIfAllExist(System.String)">
            <summary>
            Finds a <see cref="T:CK.Core.CKTrait"/> (either combined or atomic) only if all 
            of its atomic traits already exists: if any of the atomic traits are not already 
            registered, null is returned.
            </summary>
            <param name="traits">Atomic trait or traits separated by <see cref="P:CK.Core.CKTraitContext.Separator"/>.</param>
            <returns>A trait or null if the trait does not exists.</returns>
        </member>
        <member name="M:CK.Core.CKTraitContext.FindOnlyExisting(System.String,System.Func{System.String,System.Boolean})">
            <summary>
            Finds a <see cref="T:CK.Core.CKTrait"/> with only already existing atomic traits (null when not found).
            </summary>
            <param name="traits">Atomic trait or traits separated by <see cref="P:CK.Core.CKTraitContext.Separator"/>.</param>
            <param name="collector">Optional collector for unknown trait. As soon as the collector returns false, the process stops.</param>
            <returns>A trait that contains only already existing trait or null if none already exists.</returns>
        </member>
        <member name="M:CK.Core.CKTraitContext.FindOrCreate(System.Collections.Generic.List{CK.Core.CKTrait})">
            <summary>
            Obtains a trait from a list of atomic (already sorted) traits.
            Used by the Add, Toggle, Remove, Intersect methods.
            </summary>
        </member>
        <member name="M:CK.Core.CKTraitContext.FindOrCreate(CK.Core.CKTrait[],System.Int32)">
            <summary>
            Obtains a trait from a list of atomic (already sorted) traits.
            Used by fall back generation.
            </summary>
        </member>
        <member name="P:CK.Core.CKTraitContext.Separator">
            <summary>
            Gets the separator to use to separate combined traits. It is | by default.
            </summary>
        </member>
        <member name="P:CK.Core.CKTraitContext.Name">
            <summary>
            Gets the name of this context.
            </summary>
        </member>
        <member name="P:CK.Core.CKTraitContext.EmptyTrait">
            <summary>
            Gets the empty trait for this context. It corresponds to the empty string.
            </summary>
        </member>
        <member name="P:CK.Core.CKTraitContext.EnumWithEmpty">
            <summary>
            Gets the fallback for empty and atomic traits.
            </summary>
        </member>
        <member name="T:CK.Core.INamedVersionedUniqueId">
            <summary>
            Extends <see cref="T:CK.Core.IVersionedUniqueId"/> to associate a <see cref="P:PublicName"/> descriptor.
            </summary>
        </member>
        <member name="T:CK.Core.IVersionedUniqueId">
            <summary>
            Extends <see cref="T:CK.Core.IUniqueId"/> to associate a <see cref="P:Version"/> number.
            </summary>
        </member>
        <member name="P:CK.Core.IVersionedUniqueId.Version">
            <summary>
            Gets the version number associated to this object.
            Never null: defaults to <see cref="F:CK.Core.Util.EmptyVersion"/>.
            </summary>
        </member>
        <member name="P:CK.Core.INamedVersionedUniqueId.PublicName">
            <summary>
            Gets the public name of this object. 
            It must never be null (defaults to <see cref="F:System.String.Empty"/>) and can be any string 
            in any culture (english US should be used as much a possible).
            </summary>
        </member>
        <member name="T:CK.Core.SimpleNamedVersionedUniqueId">
            <summary>
            Minimal implementation of the minimal <see cref="T:CK.Core.INamedVersionedUniqueId"/> interface.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleNamedVersionedUniqueId.Empty">
            <summary>
            Empty <see cref="T:CK.Core.INamedVersionedUniqueId"/> bount to the <see cref="F:System.Guid.Empty"/>, <see cref="F:CK.Core.Util.EmptyVersion"/> and <see cref="F:System.String.Empty"/>.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleNamedVersionedUniqueId.InvalidId">
            <summary>
            Gets a <see cref="T:CK.Core.INamedVersionedUniqueId"/> that must be used to denote an invalid key.
            This value MUST NOT be used for anything else than a temporary marker.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleNamedVersionedUniqueId.EmptyArray">
            <summary>
            Empty array of <see cref="T:CK.Core.IUniqueId"/>.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleNamedVersionedUniqueId.#ctor(System.String,System.Version,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleNamedVersionedUniqueId"/> where its <see cref="P:CK.Core.SimpleNamedVersionedUniqueId.UniqueId"/> is built from the string
            representation of a <see cref="T:System.Guid"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> expressed as a string.</param>
            <param name="version">Version object. If null, <see cref="F:CK.Core.Util.EmptyVersion"/> is used.</param>
            <param name="publicName">Public name for the object. If null, <see cref="F:System.String.Empty"/> is used.</param>
        </member>
        <member name="M:CK.Core.SimpleNamedVersionedUniqueId.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleNamedVersionedUniqueId"/> where its <see cref="P:CK.Core.SimpleNamedVersionedUniqueId.UniqueId"/> is built from the string
            representation of a <see cref="T:System.Guid"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> expressed as a string.</param>
            <param name="version">Version as a string. If null, <see cref="F:CK.Core.Util.EmptyVersion"/> is used.</param>
            <param name="publicName">Public name of the object. If null, <see cref="F:System.String.Empty"/> is used.</param>
        </member>
        <member name="M:CK.Core.SimpleNamedVersionedUniqueId.#ctor(System.Guid,System.Version,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleNamedVersionedUniqueId"/> where its <see cref="P:CK.Core.SimpleNamedVersionedUniqueId.UniqueId"/> is built from the string
            representation of a <see cref="T:System.Guid"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> for the <see cref="P:CK.Core.SimpleNamedVersionedUniqueId.UniqueId"/>.</param>
            <param name="version">Version as a string. If null, <see cref="F:CK.Core.Util.EmptyVersion"/> is used.</param>
            <param name="publicName">Public name of the object. If null, <see cref="F:System.String.Empty"/> is used.</param>
        </member>
        <member name="P:CK.Core.SimpleNamedVersionedUniqueId.UniqueId">
            <summary>
            Gets the unique identifier that this object represents.
            </summary>
        </member>
        <member name="P:CK.Core.SimpleNamedVersionedUniqueId.Version">
            <summary>
            Gets the version of this object.
            </summary>
        </member>
        <member name="P:CK.Core.SimpleNamedVersionedUniqueId.PublicName">
            <summary>
            Gets the public name of this object.
            </summary>
        </member>
        <member name="T:CK.Core.SimpleUniqueId">
            <summary>
            Minimal implementation of the minimal <see cref="T:CK.Core.IUniqueId"/> interface.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleUniqueId.Empty">
            <summary>
            Empty <see cref="T:CK.Core.IUniqueId"/> bount to the <see cref="F:System.Guid.Empty"/>.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleUniqueId.InvalidId">
            <summary>
            Gets a <see cref="T:CK.Core.IUniqueId"/> that must be used to denote an invalid key.
            This value MUST NOT be used for anything else than a marker.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleUniqueId.EmptyArray">
            <summary>
            Empty array of <see cref="T:CK.Core.IUniqueId"/>.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleUniqueId.#ctor(System.String)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleUniqueId"/> where its <see cref="P:CK.Core.SimpleUniqueId.UniqueId"/> is built from the string
            representation of a <see cref="T:System.Guid"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> expressed as a string.</param>
        </member>
        <member name="M:CK.Core.SimpleUniqueId.#ctor(System.Guid)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleUniqueId"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> for the <see cref="P:CK.Core.SimpleUniqueId.UniqueId"/>.</param>
        </member>
        <member name="P:CK.Core.SimpleUniqueId.UniqueId">
            <summary>
            Gets the unique identifier that this object represents.
            </summary>
        </member>
        <member name="T:CK.Core.SimpleVersionedUniqueId">
            <summary>
            Minimal implementation of the minimal <see cref="T:CK.Core.INamedVersionedUniqueId"/> interface.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleVersionedUniqueId.Empty">
            <summary>
            Empty <see cref="T:CK.Core.INamedVersionedUniqueId"/> bount to the <see cref="F:System.Guid.Empty"/> and <see cref="F:CK.Core.Util.EmptyVersion"/>.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleVersionedUniqueId.InvalidId">
            <summary>
            Gets a <see cref="T:CK.Core.INamedVersionedUniqueId"/> that must be used to denote an invalid key.
            This value MUST NOT be used for anything else than a temporary marker.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleVersionedUniqueId.#ctor(System.String,System.Version)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleVersionedUniqueId"/> where its <see cref="P:CK.Core.SimpleVersionedUniqueId.UniqueId"/> is built from the string
            representation of a <see cref="T:System.Guid"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> expressed as a string.</param>
            <param name="version">Version object. If null, <see cref="F:CK.Core.Util.EmptyVersion"/> is used.</param>
        </member>
        <member name="M:CK.Core.SimpleVersionedUniqueId.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleVersionedUniqueId"/> where its <see cref="P:CK.Core.SimpleVersionedUniqueId.UniqueId"/> is built from the string
            representation of a <see cref="T:System.Guid"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> expressed as a string.</param>
            <param name="version">Version as a string. If null, <see cref="F:CK.Core.Util.EmptyVersion"/> is used.</param>
        </member>
        <member name="M:CK.Core.SimpleVersionedUniqueId.#ctor(System.Guid,System.Version)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleVersionedUniqueId"/> where its <see cref="P:CK.Core.SimpleVersionedUniqueId.UniqueId"/> is built from the string
            representation of a <see cref="T:System.Guid"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> for the <see cref="P:CK.Core.SimpleVersionedUniqueId.UniqueId"/>.</param>
            <param name="version">Version as a string. If null, <see cref="F:CK.Core.Util.EmptyVersion"/> is used.</param>
        </member>
        <member name="P:CK.Core.SimpleVersionedUniqueId.UniqueId">
            <summary>
            Gets the unique identifier that this object represents.
            </summary>
        </member>
        <member name="P:CK.Core.SimpleVersionedUniqueId.Version">
            <summary>
            Gets the version of this object.
            </summary>
        </member>
        <member name="T:CK.Core.UriExtension">
            <summary>
            Helper functions related to <see cref="T:System.Uri"/>.
            </summary>
        </member>
        <member name="M:CK.Core.UriExtension.AssumeUrlParameter(System.Uri,System.String,System.String)">
            <summary>
            Ensures that the given parameter occurs in this <see cref="T:System.Uri"/> with the given value.
            </summary>
            <param name="this">This uri.</param>
            <param name="parameter">Name of the parameter.</param>
            <param name="val">Value of the parameter. It must be url safe since this method 
            will not escape it.</param>
            <returns>A new <see cref="T:System.Uri"/> with the appended or updated parameter.</returns>
        </member>
        <member name="M:CK.Core.UriExtension.RemoveUrlParameter(System.Uri,System.String)">
            <summary>
            Removes the given parameter from the <see cref="T:System.Uri"/>.
            </summary>
            <param name="this">This uri.</param>
            <param name="parameter">Parameter name to remove.</param>
            <returns>A new <see cref="T:System.Uri"/> without the parameter.</returns>
        </member>
        <member name="M:CK.Core.UriExtension.AppendUrlParameter(System.Uri,System.String,System.String)">
            <summary>
            Appends the given parameter and value to this <see cref="T:System.Uri"/>. If the parameter name already exists
            in the uri (and you do not want duplicated parameters), use <see cref="M:CK.Core.UriExtension.AssumeUrlParameter(System.Uri,System.String,System.String)"/>
            instead.
            </summary>
            <param name="this">This uri</param>
            <param name="parameter">Name of the parameter.</param>
            <param name="val">Value of the parameter. It must be url safe since this method 
            will not escape it.</param>
            <returns>A new <see cref="T:System.Uri"/> with the parameter and value added.</returns>
        </member>
        <member name="T:CK.Core.UriHelper">
            <summary>
            Helper functions related to <see cref="T:System.Uri"/>.
            </summary>
        </member>
        <member name="M:CK.Core.UriHelper.AddUrlParameter(System.String,System.String,System.String,System.Boolean)">
            <summary>
            When val is null, the parameter will be removed.
            </summary>
        </member>
        <member name="M:CK.Core.UriHelper.AssumeUrlParameter(System.String,System.String,System.String)">
            <summary>
            Ensures that the given parameter occurs in the query string with the given value.
            </summary>
            <param name="u">Url that may already contain the parameter: in such case, its value
            will be updated.</param>
            <param name="parameter">Name of the parameter.</param>
            <param name="val">Value of the parameter. It must be url safe since this method 
            will not escape it.</param>
            <returns>The url with the appended or updated parameter.</returns>
        </member>
        <member name="M:CK.Core.UriHelper.RemoveUrlParameter(System.String,System.String)">
            <summary>
            Removes the given parameter from the url.
            </summary>
            <param name="u">Original url</param>
            <param name="parameter">Parameter name to remove.</param>
            <returns>An url without the parameter.</returns>
        </member>
        <member name="M:CK.Core.UriHelper.AppendUrlParameter(System.String,System.String,System.String)">
            <summary>
            Appends the given parameter and value to the url. If the parameter name already exists
            in the url (and you do not want duplicated parameters), use <see cref="M:AssumeUrlParameter"/>
            instead.
            </summary>
            <param name="u">Url</param>
            <param name="parameter">Name of the parameter.</param>
            <param name="val">Value of the parameter. It must be url safe since this method 
            will not escape it.</param>
            <returns>An url with the parameter and value added.</returns>
        </member>
        <member name="T:CK.Core.Util">
            <summary>
            Utility class.
            </summary>
            <summary>
            Utility class.
            Offers useful functions, constants, singletons and delegates.
            </summary>
            <summary>
            Utility class.
            </summary>
            <summary>
            Utility class.
            </summary>
            <summary>
            Utility class.
            </summary>
            <summary>
            Utility class.
            </summary>
        </member>
        <member name="F:CK.Core.Util.SqlServerEpoch">
            <summary>
            Gets 1900, January the 1st. This is the 'zero' of Sql Server datetime and smalldatetime
            types.
            </summary>
        </member>
        <member name="F:CK.Core.Util.UnixEpoch">
            <summary>
            Gets 1970, January the 1st. This is the 'zero' of numerous date/time system
            like Unix file system or javascript.
            </summary>
        </member>
        <member name="F:CK.Core.Util.UtcMinValue">
            <summary>
            Represents the smallest possible value for a <see cref="T:System.DateTime"/> in <see cref="F:System.DateTimeKind.Utc"/>.         
            </summary>
        </member>
        <member name="F:CK.Core.Util.UtcMaxValue">
            <summary>
            Represents the largest possible value for a <see cref="T:System.DateTime"/> in <see cref="F:System.DateTimeKind.Utc"/>.         
            </summary>
        </member>
        <member name="M:CK.Core.Util.ActionDispose(System.IDisposable)">
            <summary>
            Centralized <see cref="M:System.IDisposable.Dispose"/> action call: it adapts an <see cref="T:System.IDisposable"/> interface to an <see cref="T:System.Action"/>.
            Can be safely called if <paramref name="obj"/> is null. 
            See <see cref="M:CK.Core.Util.CreateDisposableAction(System.Action)"/> to wrap an action in a <see cref="T:System.IDisposable"/> interface.
            </summary>
            <param name="obj">The disposable object to dispose (can be null).</param>
        </member>
        <member name="M:CK.Core.Util.CreateDisposableAction(System.Action)">
            <summary>
            Wraps an action in a <see cref="T:System.IDisposable"/> interface
            Can be safely called if <paramref name="a"/> is null (the dispose call will do nothing).
            See <see cref="M:CK.Core.Util.ActionDispose(System.IDisposable)"/> to adapt an <see cref="T:System.IDisposable"/> interface to an <see cref="T:System.Action"/>.
            </summary>
            <param name="a">The action to call when <see cref="M:System.IDisposable.Dispose"/> is called.</param>
        </member>
        <member name="M:CK.Core.Util.ActionVoid``1(``0)">
            <summary>
            Centralized void action call for any type. 
            This method is one of the safest method never written in the world. 
            It does absolutely nothing.
            </summary>
            <param name="obj">Any object.</param>
        </member>
        <member name="M:CK.Core.Util.ActionVoid``2(``0,``1)">
            <summary>
            Centralized void action call for any pair of types. 
            This method is one of the safest method never written in the world. 
            It does absolutely nothing.
            </summary>
            <param name="o1">Any object.</param>
            <param name="o2">Any object.</param>
        </member>
        <member name="M:CK.Core.Util.ActionVoid``3(``0,``1,``2)">
            <summary>
            Centralized void action call for any 3 types. 
            This method is one of the safest method never written in the world. 
            It does absolutely nothing.
            </summary>
            <param name="o1">Any object.</param>
            <param name="o2">Any object.</param>
            <param name="o3">Any object.</param>
        </member>
        <member name="M:CK.Core.Util.FuncIdentity``1(``0)">
            <summary>
            Centralized identity function for any type.
            </summary>
            <typeparam name="T">Type of the function parameter and return value.</typeparam>
            <param name="value">Any value returned unchanged.</param>
            <returns>The <paramref name="value"/> provided is returned as-is.</returns>
        </member>
        <member name="M:CK.Core.Util.ToPredicate``1(System.Action{``0},System.Boolean)">
            <summary>
            Wraps an action in a predicate that returns always the provided result.
            </summary>
            <typeparam name="T">The type of the action's parameter.</typeparam>
            <param name="this">The action (a method that accepts <typeparamref name="T"/> as its only argument).</param>
            <param name="result">result that will be returned.</param>
            <returns>A predicate that performs the action and returns true.</returns>
        </member>
        <member name="M:CK.Core.Util.AlwaysTrue``1(System.Action{``0})">
            <summary>
            Wraps an action in a predicate that returns always true.
            </summary>
            <typeparam name="T">The type of the action's parameter.</typeparam>
            <param name="a">The action (a method that accepts <typeparamref name="T"/> as its only argument).</param>
            <returns>A predicate that performs the action and returns true.</returns>
        </member>
        <member name="M:CK.Core.Util.AlwaysFalse``1(System.Action{``0})">
            <summary>
            Wraps an action in a predicate that returns always false.
            </summary>
            <typeparam name="T">The type of the action's parameter.</typeparam>
            <param name="a">The action (a method that accepts <typeparamref name="T"/> as its only argument).</param>
            <returns>A predicate that performs the action and returns false.</returns>
        </member>
        <member name="M:CK.Core.Util.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Comparison{``0})">
            <summary>
            Binary search implementation that relies on a <see cref="T:System.Comparison`1"/>.
            </summary>
            <typeparam name="T">Type of the elements.</typeparam>
            <param name="array">An array of elements.</param>
            <param name="startIndex">The starting index in the array.</param>
            <param name="length">The number of elements to consider in the array.</param>
            <param name="value">The value to locate.</param>
            <param name="comparison">The comparison function.</param>
            <returns>Same as <see cref="M:System.Array.BinarySearch(System.Array,System.Object)"/>: negative index if not found which is the bitwise complement of (the index of the next element plus 1).</returns>
        </member>
        <member name="M:CK.Core.Util.BinarySearch``2(``0[],System.Int32,System.Int32,``1,System.Func{``0,``1,System.Int32})">
            <summary>
            Binary search implementation that relies on an extended comparer: a function that knows how to 
            compare the elements of the array to a key of another type.
            </summary>
            <typeparam name="T">Type of the elements.</typeparam>
            <typeparam name="TKey">Type of the key.</typeparam>
            <param name="array">An array of elements.</param>
            <param name="startIndex">The starting index in the array.</param>
            <param name="length">The number of elements to consider in the array.</param>
            <param name="key">The value of the key.</param>
            <param name="comparison">The comparison function.</param>
            <returns>Same as <see cref="M:System.Array.BinarySearch(System.Array,System.Object)"/>: negative index if not found which is the bitwise complement of (the index of the next element plus 1).</returns>
        </member>
        <member name="M:CK.Core.Util.BinarySearch``1(System.Collections.Generic.IReadOnlyList{``0},System.Int32,System.Int32,``0,System.Comparison{``0})">
            <summary>
            Binary search implementation that relies on a <see cref="T:System.Comparison`1"/>.
            </summary>
            <typeparam name="T">Type of the elements.</typeparam>
            <param name="sortedList">Read only list of elements.</param>
            <param name="startIndex">The starting index in the list.</param>
            <param name="length">The number of elements to consider in the list.</param>
            <param name="value">The value to locate.</param>
            <param name="comparison">The comparison function.</param>
            <returns>Same as <see cref="M:System.Array.BinarySearch(System.Array,System.Object)"/>: negative index if not found which is the bitwise complement of (the index of the next element plus 1).</returns>
        </member>
        <member name="M:CK.Core.Util.BinarySearch``2(System.Collections.Generic.IReadOnlyList{``0},System.Int32,System.Int32,``1,System.Func{``0,``1,System.Int32})">
            <summary>
            Binary search implementation that relies on an extended comparer: a function that knows how to 
            compare the elements of the list to a key of another type.
            </summary>
            <typeparam name="T">Type of the elements.</typeparam>
            <typeparam name="TKey">Type of the key.</typeparam>
            <param name="sortedList">Read only list of elements.</param>
            <param name="startIndex">The starting index in the list.</param>
            <param name="length">The number of elements to consider in the list.</param>
            <param name="key">The value of the key.</param>
            <param name="comparison">The comparison function.</param>
            <returns>Same as <see cref="M:System.Array.BinarySearch(System.Array,System.Object)"/>: negative index if not found which is the bitwise complement of (the index of the next element plus 1).</returns>
        </member>
        <member name="M:CK.Core.Util.InterlockedSet``1(``0@,System.Func{``0,``0})">
            <summary>
            Thread-safe way to set any reference type. Uses <see cref="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)"/> and <see cref="T:System.Threading.SpinWait"/>.
            </summary>
            <typeparam name="T">Any reference type.</typeparam>
            <param name="target">Reference (address) to set.</param>
            <param name="transformer">Function that knows how to obtain the desired object from the current one. This function may be called more than once.</param>
            <returns>The object that has actually been set. Note that it may differ from the "current" target value if another thread already changed it.</returns>
        </member>
        <member name="M:CK.Core.Util.InterlockedSet``2(``0@,``1,System.Func{``0,``1,``0})">
            <summary>
            Thread-safe way to set any reference type. Uses <see cref="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)"/> and <see cref="T:System.Threading.SpinWait"/>.
            </summary>
            <typeparam name="T">Any reference type.</typeparam>
            <typeparam name="TArg">Type of the first parameter.</typeparam>
            <param name="target">Reference (address) to set.</param>
            <param name="a">Argument of the transformer.</param>
            <param name="transformer">Function that knows how to obtain the desired object from the current one. This function may be called more than once.</param>
            <returns>The object that has actually been set. Note that it may differ from the "current" target value if another thread already changed it.</returns>
        </member>
        <member name="M:CK.Core.Util.InterlockedSet``3(``0@,``1,``2,System.Func{``0,``1,``2,``0})">
            <summary>
            Thread-safe way to set any reference type. Uses <see cref="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)"/> and <see cref="T:System.Threading.SpinWait"/>.
            </summary>
            <typeparam name="T">Any reference type.</typeparam>
            <typeparam name="TArg1">Type of the first parameter.</typeparam>
            <typeparam name="TArg2">Type of the second parameter.</typeparam>
            <param name="target">Reference (address) to set.</param>
            <param name="a1">First argument of the transformer.</param>
            <param name="a2">Second argument of the transformer.</param>
            <param name="transformer">Function that knows how to obtain the desired object from the current one. This function may be called more than once.</param>
            <returns>The object that has actually been set. Note that it may differ from the "current" target value if another thread already changed it.</returns>
        </member>
        <member name="M:CK.Core.Util.InterlockedSet``4(``0@,``1,``2,``3,System.Func{``0,``1,``2,``3,``0})">
            <summary>
            Thread-safe way to set any reference type. Uses <see cref="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)"/> and <see cref="T:System.Threading.SpinWait"/>.
            </summary>
            <typeparam name="T">Any reference type.</typeparam>
            <typeparam name="TArg1">Type of the first parameter.</typeparam>
            <typeparam name="TArg2">Type of the second parameter.</typeparam>
            <typeparam name="TArg3">Type of the third parameter.</typeparam>
            <param name="target">Reference (address) to set.</param>
            <param name="a1">First argument of the transformer.</param>
            <param name="a2">Second argument of the transformer.</param>
            <param name="a3">Third argument of the transformer.</param>
            <param name="transformer">Function that knows how to obtain the desired object from the current one. This function may be called more than once.</param>
            <returns>The object that has actually been set. Note that it may differ from the "current" target value if another thread already changed it.</returns>
        </member>
        <member name="M:CK.Core.Util.InterlockedSet``5(``0@,``1,``2,``3,``4,System.Func{``0,``1,``2,``3,``4,``0})">
            <summary>
            Thread-safe way to set any reference type. Uses <see cref="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)"/> and <see cref="T:System.Threading.SpinWait"/>.
            </summary>
            <typeparam name="T">Any reference type.</typeparam>
            <typeparam name="TArg1">Type of the first parameter.</typeparam>
            <typeparam name="TArg2">Type of the second parameter.</typeparam>
            <typeparam name="TArg3">Type of the third parameter.</typeparam>
            <typeparam name="TArg4">Type of the fourth parameter.</typeparam>
            <param name="target">Reference (address) to set.</param>
            <param name="a1">First argument of the transformer.</param>
            <param name="a2">Second argument of the transformer.</param>
            <param name="a3">Third argument of the transformer.</param>
            <param name="a4">Fourth argument of the transformer.</param>
            <param name="transformer">Function that knows how to obtain the desired object from the current one. This function may be called more than once.</param>
            <returns>The object that has actually been set. Note that it may differ from the "current" target value if another thread already changed it.</returns>
        </member>
        <member name="M:CK.Core.Util.InterlockedSet``6(``0@,``1,``2,``3,``4,``5,System.Func{``0,``1,``2,``3,``4,``5,``0})">
            <summary>
            Thread-safe way to set any reference type. Uses <see cref="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)"/> and <see cref="T:System.Threading.SpinWait"/>.
            </summary>
            <typeparam name="T">Any reference type.</typeparam>
            <typeparam name="TArg1">Type of the first parameter.</typeparam>
            <typeparam name="TArg2">Type of the second parameter.</typeparam>
            <typeparam name="TArg3">Type of the third parameter.</typeparam>
            <typeparam name="TArg4">Type of the fourth parameter.</typeparam>
            <typeparam name="TArg5">Type of the fifth parameter.</typeparam>
            <param name="target">Reference (address) to set.</param>
            <param name="a1">First argument of the transformer.</param>
            <param name="a2">Second argument of the transformer.</param>
            <param name="a3">Third argument of the transformer.</param>
            <param name="a4">Fourth argument of the transformer.</param>
            <param name="a5">Fifth argument of the transformer.</param>
            <param name="transformer">Function that knows how to obtain the desired object from the current one. This function may be called more than once.</param>
            <returns>The object that has actually been set. Note that it may differ from the "current" target value if another thread already changed it.</returns>
        </member>
        <member name="M:CK.Core.Util.InterlockedRemove``1(``0[]@,``0)">
            <summary>
            Atomically removes an item in an array.
            </summary>
            <typeparam name="T">Type of the item array.</typeparam>
            <param name="items">Reference (address) of the array. Can be null.</param>
            <param name="o">Item to remove.</param>
            <returns>The array containing the new item. Note that it may differ from the "current" items content since another thread may have already changed it.</returns>
        </member>
        <member name="M:CK.Core.Util.InterlockedRemove``1(``0[]@,System.Func{``0,System.Boolean})">
            <summary>
            Atomically removes the first item from an array that matches a predicate.
            </summary>
            <typeparam name="T">Type of the item array.</typeparam>
            <param name="items">Reference (address) of the array. Can be null.</param>
            <param name="predicate">Predicate that identifies the item to remove.</param>
            <returns>The array containing the new item. Note that it may differ from the "current" items content since another thread may have already changed it.</returns>
        </member>
        <member name="M:CK.Core.Util.InterlockedRemoveAll``1(``0[]@,System.Func{``0,System.Boolean})">
            <summary>
            Atomically removes one or more items from an array that match a predicate.
            </summary>
            <typeparam name="T">Type of the item array.</typeparam>
            <param name="items">Reference (address) of the array. Can be null.</param>
            <param name="predicate">Predicate that identifies items to remove.</param>
            <returns>The array containing the new item. Note that it may differ from the "current" items content since another thread may have already changed it.</returns>
        </member>
        <member name="M:CK.Core.Util.InterlockedAddUnique``1(``0[]@,``0,System.Boolean)">
            <summary>
            Atomically adds an item to an array (that can be null) if it does not already exist in the array.
            </summary>
            <typeparam name="T">Type of the item array.</typeparam>
            <param name="items">Reference (address) of the array. Can be null.</param>
            <param name="o">The item to insert at position 0 (if <paramref name="prepend"/> is true) or at the end only if it does not already appear in the array.</param>
            <param name="prepend">True to insert the item at the head of the array (index 0) instead of at its end.</param>
            <returns>The array containing the new item. Note that it may differ from the "current" items content since another thread may have already changed it.</returns>
        </member>
        <member name="M:CK.Core.Util.InterlockedAdd``1(``0[]@,``0,System.Boolean)">
            <summary>
            Atomically adds an item to an array (that can be null).
            </summary>
            <typeparam name="T">Type of the item array.</typeparam>
            <param name="items">Reference (address) of the array. Can be null.</param>
            <param name="o">The item to insert at position 0 (if <paramref name="prepend"/> is true) or at the end.</param>
            <param name="prepend">True to insert the item at the head of the array (index 0) instead of at its end.</param>
            <returns>The array containing the new item. Note that it may differ from the "current" items content since another thread may have already changed it.</returns>
        </member>
        <member name="M:CK.Core.Util.InterlockedAdd``2(``0[]@,System.Func{``1,System.Boolean},System.Func{``1},System.Boolean)">
            <summary>
            Atomically adds an item to an existing array (that can be null) if no existing item satisfies a condition.
            </summary>
            <typeparam name="T">Type of the item array.</typeparam>
            <typeparam name="TItem">Type of the item to add: can be any specialization of T.</typeparam>
            <param name="items">Reference (address) of the array. Can be null.</param>
            <param name="tester">Predicate that must be satisfied for at least one existing item.</param>
            <param name="factory">Factory that will be called if no existing item satisfies <paramref name="tester"/>. It will be called only once if needed.</param>
            <param name="prepend">True to insert the item at the head of the array (index 0) instead of at its end.</param>
            <returns>
            The array containing the an item that satisfies the tester function. 
            Note that it may differ from the "current" items content since another thread may have already changed it.
            </returns>
            <remarks>
            The factory function MUST return an item that satisfies the tester function otherwise a <see cref="T:System.InvalidOperationException"/> is thrown.
            </remarks>
        </member>
        <member name="F:CK.Core.Util.EmptyDisposable">
            <summary>
            A void, immutable, <see cref="T:System.IDisposable"/> that does absolutely nothing.
            </summary>
        </member>
        <member name="F:CK.Core.Util.EmptyStringArray">
            <summary>
            Gets a static empty <see cref="T:System.String"/> array.
            </summary>
        </member>
        <member name="F:CK.Core.Util.EmptyVersion">
            <summary>
            The empty version is defined as the Major.Minor.Build.Revision set to "0.0.0.0".
            </summary>
        </member>
        <member name="T:CK.Core.Util.Converter">
            <summary>
            Offers converter functions.
            </summary>
        </member>
        <member name="F:CK.Core.Util.Converter.HexChars">
            <summary>
            '0'...'F' array. This is public for performance reasons.
            Obviously: do NOT modify it! 
            </summary>
        </member>
        <member name="F:CK.Core.Util.Converter.HexCharsLower">
            <summary>
            '0'...'f' array. This is public for performance reasons.
            Obviously: do NOT modify it! 
            </summary>
        </member>
        <member name="M:CK.Core.Util.Converter.BytesToHexaString(System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            Converts an array of bytes to an hexadecimal string.
            </summary>
            <param name="bytes">A non null array of bytes.</param>
            <param name="zeroxPrefix">False to not prefix the result with 0x.</param>
            <param name="lowerCase">True to use upper case A...F (instead of a...f).</param>
            <returns>The bytes expressed as a an hexadecimal string.</returns>
        </member>
        <member name="T:CK.Core.Util.EmptyArray`1">
            <summary>
            Empty array centralization.
            </summary>
            <typeparam name="T">Any type.</typeparam>
        </member>
        <member name="F:CK.Core.Util.EmptyArray`1.Empty">
            <summary>
            Empty array to use (and reuse!).
            </summary>
        </member>
        <member name="T:CK.Core.Util.Hash">
            <summary>
            Provides methods to combine hash values: use <see cref="P:CK.Core.Util.Hash.StartValue"/> and then 
            chain calls to the <see cref="M:Combine"/> methods.
            Based on Daniel J. Bernstein algorithm (http://cr.yp.to/cdb/cdb.txt).
            </summary>
        </member>
        <member name="M:CK.Core.Util.Hash.Combine(System.Int64,System.Int32)">
            <summary>
            Combines an existing hash value with a new one.
            </summary>
            <param name="hash">Current hash.</param>
            <param name="value">Value to combine.</param>
            <returns>A combined hash.</returns>
        </member>
        <member name="M:CK.Core.Util.Hash.Combine(System.Int64,System.Object)">
            <summary>
            Combines an existing hash value with an object's hash (object can be null).
            </summary>
            <param name="hash">Current hash.</param>
            <param name="o">Object whose hash must be combined (can be null).</param>
            <returns>A combined hash.</returns>
        </member>
        <member name="M:CK.Core.Util.Hash.Combine(System.Int64,System.Collections.IEnumerable)">
            <summary>
            Combines an existing hash value with multiples object's hash.
            </summary>
            <param name="hash">Current hash.</param>
            <param name="c">Multiple objects. Can be null.</param>
            <returns>A combined hash.</returns>
        </member>
        <member name="M:CK.Core.Util.Hash.Combine(System.Int64,System.Object[])">
            <summary>
            Combines an existing hash value with multiples object's written directly as parameters.
            </summary>
            <param name="hash">Current hash.</param>
            <param name="objects">Multiple objects.</param>
            <returns>A combined hash.</returns>
        </member>
        <member name="P:CK.Core.Util.Hash.StartValue">
             <summary>
             Gets a very classical start value (see remarks) that can be then be used 
             by the multiple <see cref="M:Combine"/> methods. Use <see cref="M:System.Int64.GetHashCode"/> to
             obtain a final integer (Int32) hash code.
             </summary>
             <remarks>
             It seems that this value has nothing special (mathematically speaking) except that it 
             has been used and reused by many people since DJB choose it.
            </remarks>
        </member>
        <member name="T:CK.Core.Util.Matcher">
            <summary>
            Provides simple methods to that follows the Match and Forward pattern.
            The string must never be null.
            On success, the startAt index is updated so that is positioned after the match.
            The startAt index (where the match must start) can not be negative. It may be equal to or greater than maxLength: the match fails without throwing an exception.
            The maxLength can not be greater than the length of the string, but may be 0 or negative (the match fails).
            </summary>
        </member>
        <member name="M:CK.Core.Util.Matcher.CheckMatchArguments(System.String,System.Int32,System.Int32)">
            <summary>
            Checks standard arguments for Match and Forward pattern.
            </summary>
            <param name="s">The string. Can not be null.</param>
            <param name="startAt">Can not be negative.</param>
            <param name="maxLength">Can not be greater than the length of the string, but may be 0 or negative (the match fails)</param>
            <returns>False if startAt is greater or equal to maxLength. True if the match is possible.</returns>
        </member>
        <member name="M:CK.Core.Util.Matcher.Match(System.String,System.Int32@,System.Int32,System.Char)">
            <summary>
            Matches an exact single character at a given position in a string.
            </summary>
            <param name="s">The string to parse.</param>
            <param name="startAt">
            Index where the match must start (can be equal to or greater than <paramref name="maxLength"/>: the match fails).
            On success, index of the end of the match.
            </param>
            <param name="maxLength">
            Maximum index to consider in the string (it shortens the default <see cref="P:System.String.Length"/>), it can be zero or negative.
            If maxLength is greater than String.Length an <see cref="T:System.ArgumentException"/> is thrown.
            </param>
            <param name="match">The character that must match.</param>
            <returns>True on success, false if the match failed.</returns>
        </member>
        <member name="M:CK.Core.Util.Matcher.Match(System.String,System.Int32@,System.Int32,System.String,System.StringComparison)">
            <summary>
            Matches a string at a given position in a string.
            </summary>
            <param name="s">The string to parse.</param>
            <param name="startAt">
            Index where the match must start (can be equal to or greater than <paramref name="maxLength"/>: the match fails).
            On success, index of the end of the match.
            </param>
            <param name="match">The string that must match. Can not be null.</param>
            <param name="maxLength">
            Maximum index to consider in the string (it shortens the default <see cref="P:System.String.Length"/>), it can be zero or negative.
            If maxLength is greater than String.Length an <see cref="T:System.ArgumentException"/> is thrown.
            </param>
            <param name="comparisonType">Specifies the culture, case, and sort rules.</param>
            <returns>True on success, false if the match failed.</returns>
        </member>
        <member name="M:CK.Core.Util.Matcher.MatchWhiteSpaces(System.String,System.Int32@,System.Int32)">
            <summary>
            Matches a sequence of white spaces.
            </summary>
            <param name="s">The string to parse.</param>
            <param name="startAt">
            Index where the match must start (can be equal to or greater than the length of the string: the match fails).
            On success, index of the end of the match.
            </param>
            <param name="maxLength">
            Maximum index to consider in the string (it shortens the default <see cref="P:System.String.Length"/>), it can be zero or negative.
            If maxLength is greater than String.Length an <see cref="T:System.ArgumentException"/> is thrown.
            </param>
            <returns>True on success, false if the match failed.</returns>
        </member>
        <member name="M:CK.Core.Util.Matcher.MatchFileNameUniqueTimeUtcFormat(System.String,System.Int32@,System.Int32,System.DateTime@)">
            <summary>
            Directly calls <see cref="M:CK.Core.FileUtil.MatchFileNameUniqueTimeUtcFormat(System.String,System.Int32@,System.Int32,System.DateTime@)"/>.
            </summary>
            <param name="s">The string to match.</param>
            <param name="startAt">
            Index where the match must start (can be equal to or greater than the length of the string: the match fails).
            On success, index of the end of the match.
            </param>
            <param name="maxLength">
            Maximum index to consider in the string (it can shorten the default <see cref="P:System.String.Length"/> if 
            set to a positive value, otherwise it is set to String.Length).
            If maxLength is greater than String.Length an <see cref="T:System.ArgumentException"/> is thrown.
            </param>
            <param name="time">Result time.</param>
            <returns>True if the time has been matched.</returns>
        </member>
        <member name="T:CK.Core.Util.Math">
            <summary>
            Offers simple mathematic functions.
            </summary>
        </member>
        <member name="M:CK.Core.Util.Math.Log2(System.UInt32)">
            <summary>
            Compute the Log2 (logarithm base 2) of a given number.
            </summary>
            <param name="v">Integer to compute</param>
            <returns>Log2 of the given integer</returns>
        </member>
        <member name="M:CK.Core.Util.Math.Log2ForPower2(System.UInt32)">
            <summary>
            Compute the Log2ForPower2 (logarithm base 2 power 2) of a given number.
            </summary>
            <param name="v">Integer to compute. It MUST be a power of 2.</param>
            <returns>Result</returns>
        </member>
        <member name="M:CK.Core.Util.Math.BitCount(System.Byte)">
            <summary>
            Counts the number of bits in the given byte.
            </summary>
            <param name="v">The value for which number of bits must be computed.</param>
            <returns>The number of bits.</returns>
        </member>
        <member name="T:CK.Core.WeakRef`1">
            <summary>
            A generic weak reference, which references an object while still allowing  
            that object to be reclaimed by garbage collection.
            It is named WeakRef to avoid annoying name clash with the non-generic .Net <see cref="T:System.WeakReference"/>.
            </summary>   
            <typeparam name="T">The type of the object that is referenced.</typeparam>
            <remarks>
            An implicit cast exists from <typeparamref name="T"/> to <see cref="T:CK.Core.WeakRef`1"/> 
            BUT NOT the opposite, and it is absolutely normal!
            </remarks>
        </member>
        <member name="M:CK.Core.WeakRef`1.#ctor(`0)">
            <summary>       
            Initializes a new instance of a weak reference to 
            the specified object.       
            </summary>       
            <param name="target">The object to reference. Can be null.</param>       
        </member>
        <member name="M:CK.Core.WeakRef`1.#ctor(`0,System.Boolean)">
            <summary>       
            Initializes a new instance of the WeakReference{T} class, referencing
            the specified object and using the specified resurrection tracking.
            </summary>       
            <param name="target">An object to track. Can be null.</param>
            <param name="trackResurrection">Indicates when to stop tracking the object. If true, the object is tracked
            after finalization; if false, the object is only tracked until finalization.</param>
        </member>
        <member name="M:CK.Core.WeakRef`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Required serialization constructor.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/>.</param>
        </member>
        <member name="M:CK.Core.WeakRef`1.op_Implicit(`0)~CK.Core.WeakRef{`0}">
            <summary>
            Casts an object of the type T to a weak reference of T.
            </summary>
        </member>
        <member name="P:CK.Core.WeakRef`1.Target">
            <summary>
            Gets or sets the object (the target) referenced by this weak reference.
            </summary>
        </member>
        <member name="T:CK.Core.XmlExtension">
            <summary>
            Extension methods for <see cref="T:System.Xml.XmlReader"/> and <see cref="T:System.Xml.Linq.XElement"/>
            classes.
            </summary>
        </member>
        <member name="M:CK.Core.XmlExtension.ReadEndElement(System.Xml.XmlReader,System.String)">
            <summary>
            Little helper that only increases source code readability: it calls <see cref="M:System.Xml.XmlReader.ReadEndElement"/>
            that checks the name of the closing element. This "helper" forces the developper to explicitely
            write this name.
            </summary>
            <param name="this">This <see cref="T:System.Xml.XmlReader"/>.</param>
            <param name="name">Name of the closing element.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeBoolean(System.Xml.XmlReader,System.String,System.Boolean)">
            <summary>
            Gets a boolean attribute by name.
            </summary>
            <param name="this">This <see cref="T:System.Xml.XmlReader"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeDateTime(System.Xml.XmlReader,System.String,System.DateTime)">
            <summary>
            Gets a <see cref="T:System.DateTime"/> attribute by name. It uses <see cref="F:System.Xml.XmlDateTimeSerializationMode.RoundtripKind"/>.
            </summary>
            <param name="this">This <see cref="T:System.Xml.XmlReader"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeVersion(System.Xml.XmlReader,System.String,System.Version)">
            <summary>
            Gets a <see cref="T:System.Version"/> attribute by name.
            </summary>
            <param name="this">This <see cref="T:System.Xml.XmlReader"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeInt(System.Xml.XmlReader,System.String,System.Int32)">
            <summary>
            Gets an <see cref="T:System.Int32"/> attribute by name.
            </summary>
            <param name="r">This <see cref="T:System.Xml.XmlReader"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeEnum``1(System.Xml.XmlReader,System.String,``0)">
            <summary>
            Gets an enum value.
            </summary>
            <typeparam name="T">Type of the enum. There is no way (in c#) to constraint the type to Enum - nor to Delegate, this is why 
            the constraint restricts only the type to be a value type.</typeparam>
            <param name="this">This <see cref="T:System.Xml.XmlReader"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist or can not be parsed.</param>
            <returns>The parsed value or the default value.</returns>
        </member>
        <member name="M:CK.Core.XmlExtension.GetLineColumString(System.Xml.IXmlLineInfo,System.String,System.String)">
            <summary>
            Gets line and column information (if it exists) as a string from any <see cref="T:System.Xml.Linq.XObject"/> (such as <see cref="T:System.Xml.Linq.XAttribute"/> or <see cref="T:System.Xml.Linq.XElement"/>).
            </summary>
            <param name="this">This <see cref="T:System.Xml.IXmlLineInfo"/>.</param>
            <param name="format">Default format is "- @Line,Column".</param>
            <param name="noLineInformation">Defaults to a null string when <see cref="M:System.Xml.IXmlLineInfo.HasLineInfo"/> is false.</param>
            <returns>A string based on <paramref name="format"/> or <paramref name="noLineInformation"/>.</returns>
        </member>
        <member name="M:CK.Core.XmlExtension.AttributeRequired(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            Gets the attribute by its name or throws an <see cref="T:System.Xml.XmlException"/> if it does not exist.
            </summary>
            <param name="this">This <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <param name="name">Name of the attribute.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttribute(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.String)">
            <summary>
            Gets a string attribute by name.
            </summary>
            <param name="this">This <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeBoolean(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Boolean)">
            <summary>
            Gets a boolean attribute by name.
            </summary>
            <param name="this">This <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeDateTime(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.DateTime)">
            <summary>
            Gets a <see cref="T:System.DateTime"/> attribute by name. It uses <see cref="F:System.Xml.XmlDateTimeSerializationMode.RoundtripKind"/>.
            </summary>
            <param name="this">This <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeInt(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Int32)">
            <summary>
            Gets an <see cref="T:System.Int32"/> attribute by name.
            </summary>
            <param name="this">This <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeEnum``1(System.Xml.Linq.XElement,System.Xml.Linq.XName,``0)">
            <summary>
            Gets an enum value.
            </summary>
            <typeparam name="T">Type of the enum. There is no way (in c#) to constraint the type to Enum - nor to Delegate, this is why 
            the constraint restricts only the type to be a value type.</typeparam>
            <param name="this">This <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist or can not be parsed.</param>
            <returns>The parsed value or the default value.</returns>
        </member>
    </members>
</doc>
